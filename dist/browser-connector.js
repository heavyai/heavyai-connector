(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("apache-arrow"));
	else if(typeof define === 'function' && define.amd)
		define(["apache-arrow"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("apache-arrow")) : factory(root["Arrow"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__2003__) {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2190:
/***/ ((module) => {


/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError;
  if ('function' != typeof fn) throw new TypeError;
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;


/***/ }),

/***/ 6314:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var filter = __webpack_require__(2190);

module.exports = function availableTypedArrays() {
	return filter([
		'BigInt64Array',
		'BigUint64Array',
		'Float32Array',
		'Float64Array',
		'Int16Array',
		'Int32Array',
		'Int8Array',
		'Uint16Array',
		'Uint32Array',
		'Uint8Array',
		'Uint8ClampedArray'
	], function (typedArray) {
		return typeof __webpack_require__.g[typedArray] === 'function';
	});
};


/***/ }),

/***/ 7123:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DbCon": () => /* binding */ DbCon,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "Client": () => /* reexport safe */ _thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__.Client,
/* harmony export */   "Processor": () => /* reexport safe */ _thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__.Processor
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6729);
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var apache_arrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2003);
/* harmony import */ var apache_arrow__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(apache_arrow__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9539);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2818);
/* harmony import */ var _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2607);
/* harmony import */ var _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4221);
/* harmony import */ var thrift__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9262);
/* harmony import */ var _process_query_results__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5141);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2033);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4494);
/* harmony import */ var _thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1396);
/* harmony import */ var _thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3962);
/* harmony import */ var _thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var COMPRESSION_LEVEL_DEFAULT = 3;

function arrayify(maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
} // custom version of XHRConnection which can set `withCredentials` for CORS


function CustomXHRConnection(host, port, opts) {
  var _this = this;

  thrift__WEBPACK_IMPORTED_MODULE_6__.XHRConnection.call(this, host, port, opts);

  if (opts.headers["Content-Type"] === "application/vnd.apache.thrift.binary") {
    // this is copy/paste from thrift with the noted changes below
    this.flush = function () {
      if (_this.url === undefined || _this.url === "") {
        return _this.send_buf;
      }

      var xreq = _this.getXmlHttpRequestObject(); // removed overrideMimeType since we're expecting binary data
      // added responseType


      xreq.responseType = "arraybuffer";

      xreq.onreadystatechange = function () {
        if (xreq.readyState === 4 && xreq.status === 200) {
          // changed responseText -> response
          _this.setRecvBuffer(xreq.response);
        }
      };

      xreq.open("POST", _this.url, true);
      Object.keys(_this.headers).forEach(function (headerKey) {
        xreq.setRequestHeader(headerKey, _this.headers[headerKey]);
      });
      xreq.send(_this.send_buf);
    };
  }
}

util__WEBPACK_IMPORTED_MODULE_2___default().inherits(CustomXHRConnection, thrift__WEBPACK_IMPORTED_MODULE_6__.XHRConnection);

CustomXHRConnection.prototype.getXmlHttpRequestObject = function () {
  var obj = thrift__WEBPACK_IMPORTED_MODULE_6__.XHRConnection.prototype.getXmlHttpRequestObject.call(this);
  obj.withCredentials = CustomXHRConnection.withCredentials;
  return obj;
}; // Custom version of TJSONProtocol - thrift 0.14.0 throws an exception if
// anything other than a string or Buffer is passed to writeString. For
// example: we use a number for a nonce that is defined as a string type. So,
// let's just coerce things to a string.


function CustomTJSONProtocol() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol.apply(this, args);
}

util__WEBPACK_IMPORTED_MODULE_2___default().inherits(CustomTJSONProtocol, thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol);

CustomTJSONProtocol.prototype.writeString = function (arg) {
  if (!(arg instanceof Buffer)) {
    arg = String(arg);
  }

  return thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol.prototype.writeString.call(this, arg);
}; // Additionally, the browser version of connector relied on thrift's old
// behavior of returning a Number for a 64-bit int. Technically, javascript
// does not have 64-bits of precision in a Number, so this can end up giving
// incorrect results.
//
// Lastly, the browser version relied on thrift returning a string from a
// binary type.


if (true) {
  CustomTJSONProtocol.prototype.readI64 = function () {
    var n = thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol.prototype.readI64.call(this);
    return n.toNumber(true);
  };

  CustomTJSONProtocol.prototype.readBinary = function () {
    return thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol.prototype.readString.call(this);
  };
} // Custom version of the binary protocol to override writeString, readI64, and
// readBinary as above.


function CustomBinaryProtocol() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol.apply(this, args);
}

util__WEBPACK_IMPORTED_MODULE_2___default().inherits(CustomBinaryProtocol, thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol);

CustomBinaryProtocol.prototype.writeString = function (arg) {
  if (!(arg instanceof Buffer)) {
    arg = String(arg);
  }

  return thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol.prototype.writeString.call(this, arg);
};

if (true) {
  CustomBinaryProtocol.prototype.readI64 = function () {
    var n = thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol.prototype.readI64.call(this);
    return n.toNumber(true);
  };

  CustomBinaryProtocol.prototype.readBinary = function () {
    return thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol.prototype.readBinary.call(this).toString("base64");
  };
}

function buildClient(url, useBinaryProtocol) {
  var urlObj = new URL(url);
  var protocol = urlObj.protocol;
  var hostname = urlObj.hostname;
  var port = urlObj.port;

  if (port === "") {
    port = protocol === "https:" ? "443" : "80";
  }

  var client = null;

  if (false) { var connection; } else {
    var _connection = new CustomXHRConnection(hostname, port, {
      transport: thrift__WEBPACK_IMPORTED_MODULE_6__.TBufferedTransport,
      protocol: useBinaryProtocol ? CustomBinaryProtocol : CustomTJSONProtocol,
      path: "/",
      headers: {
        "Content-Type": "application/vnd.apache.thrift.".concat(useBinaryProtocol ? "binary" : "json")
      },
      https: protocol === "https:"
    });

    _connection.on("error", console.error); // eslint-disable-line no-console


    client = (0,thrift__WEBPACK_IMPORTED_MODULE_6__.createXHRClient)(_thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__, _connection);
  }

  return client;
}

var DbCon = /*#__PURE__*/function () {
  function DbCon() {
    var _this2 = this;

    _classCallCheck(this, DbCon);

    _defineProperty(this, "updateQueryTimes", function (conId, queryId, estimatedQueryTime, execution_time_ms) {
      _this2.queryTimes[queryId] = execution_time_ms;
    });

    _defineProperty(this, "events", new (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default())());

    _defineProperty(this, "EVENT_NAMES", {
      ERROR: "error",
      METHOD_CALLED: "method-called"
    });

    _defineProperty(this, "handleErrors", function (method) {
      return function () {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return method.apply(_this2, args)["catch"](function (error) {
          _this2.events.emit(_this2.EVENT_NAMES.ERROR, error);

          throw error;
        });
      };
    });

    _defineProperty(this, "callbackify", function (method, arity) {
      return function () {
        var callback = null;

        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        if (args.length === arity + 1) {
          callback = args.pop();
        }

        var promise = _this2[method].apply(_this2, args);

        if (callback) {
          promise["catch"](function (err) {
            return callback(err);
          }).then(function (res) {
            return callback(null, res);
          });
        }

        return promise;
      };
    });

    _defineProperty(this, "overSingleClient", "SINGLE_CLIENT");

    _defineProperty(this, "overAllClients", "ALL_CLIENTS");

    _defineProperty(this, "wrapThrift", function (methodName, overClients, processArgs) {
      return function () {
        if (_this2._sessionId) {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }

          var processedArgs = processArgs(args);

          if (true) {
            _this2.events.emit(_this2.EVENT_NAMES.METHOD_CALLED, methodName);
          }

          if (overClients === _this2.overSingleClient) {
            return _this2._client[0][methodName].apply(_this2._client[0], [_this2._sessionId[0]].concat(processedArgs));
          } else {
            return Promise.all(_this2._client.map(function (client, index) {
              return client[methodName].apply(client, [_this2._sessionId[index]].concat(processedArgs));
            }));
          }
        } else {
          return Promise.reject(new Error("You are not connected to a server. Try running the connect method first."));
        }
      };
    });

    _defineProperty(this, "connect", this.callbackify("connectAsync", 0));

    _defineProperty(this, "disconnectAsync", this.handleErrors(function () {
      return Promise.all(_this2._client.map(function (client, c) {
        return client.disconnect(_this2._sessionId[c])["catch"](function (error) {
          // ignore timeout errors
          if (error && !_this2.isTimeoutError(error)) {
            throw error;
          }
        });
      })).then(function () {
        _this2._sessionId = null;
        _this2._client = null;
        _this2._numConnections = 0;
        _this2.serverPingTimes = null;
        return _this2;
      });
    }));

    _defineProperty(this, "disconnect", this.callbackify("disconnectAsync", 0));

    _defineProperty(this, "getStatusAsync", this.handleErrors(this.wrapThrift("get_status", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getStatus", this.callbackify("getStatusAsync", 0));

    _defineProperty(this, "getHardwareInfoAsync", this.handleErrors(this.wrapThrift("get_hardware_info", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getHardwareInfo", this.callbackify("getHardwareInfoAsync", 0));

    _defineProperty(this, "getFirstGeoFileInArchiveAsync", this.handleErrors(this.wrapThrift("get_first_geo_file_in_archive", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getFilesInArchiveAsync", this.handleErrors(this.wrapThrift("get_all_files_in_archive", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getUsersAsync", this.handleErrors(this.wrapThrift("get_users", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "importTableStatusAsync", this.handleErrors(this.wrapThrift("import_table_status", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getRolesAsync", this.handleErrors(this.wrapThrift("get_roles", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getDashboardsAsync", this.handleErrors(this.wrapThrift("get_dashboards", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getDashboardAsync", this.handleErrors(this.wrapThrift("get_dashboard", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "createDashboardAsync", this.handleErrors(this.wrapThrift("create_dashboard", this.overAllClients, function (args) {
      return args;
    })));

    _defineProperty(this, "replaceDashboardAsync", this.handleErrors(this.wrapThrift("replace_dashboard", this.overAllClients, function (args) {
      return args;
    })));

    _defineProperty(this, "deleteDashboardAsync", this.handleErrors(this.wrapThrift("delete_dashboard", this.overAllClients, function (args) {
      return args;
    })));

    _defineProperty(this, "deleteDashboardsAsync", this.handleErrors(this.wrapThrift("delete_dashboards", this.overAllClients, function (args) {
      return args;
    })));

    _defineProperty(this, "shareDashboardAsync", this.handleErrors(this.wrapThrift("share_dashboard", this.overAllClients, function (_ref) {
      var _ref2 = _slicedToArray(_ref, 4),
          dashboardId = _ref2[0],
          groups = _ref2[1],
          objects = _ref2[2],
          permissions = _ref2[3];

      return [dashboardId, groups, objects, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDashboardPermissions(permissions)];
    })));

    _defineProperty(this, "shareDashboardsAsync", this.handleErrors(this.wrapThrift("share_dashboards", this.overAllClients, function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 3),
          dashboardIds = _ref4[0],
          groups = _ref4[1],
          permissions = _ref4[2];

      return [dashboardIds, groups, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDashboardPermissions(permissions)];
    })));

    _defineProperty(this, "unshareDashboardAsync", this.handleErrors(this.wrapThrift("unshare_dashboard", this.overAllClients, function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 4),
          dashboardId = _ref6[0],
          groups = _ref6[1],
          objects = _ref6[2],
          permissions = _ref6[3];

      return [dashboardId, groups, objects, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDashboardPermissions(permissions)];
    })));

    _defineProperty(this, "unshareDashboardsAsync", this.handleErrors(this.wrapThrift("unshare_dashboards", this.overAllClients, function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 3),
          dashboardIds = _ref8[0],
          groups = _ref8[1],
          permissions = _ref8[2];

      return [dashboardIds, groups, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDashboardPermissions(permissions)];
    })));

    _defineProperty(this, "getDashboardGranteesAsync", this.handleErrors(this.wrapThrift("get_dashboard_grantees", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getDbObjectsForGranteeAsync", this.handleErrors(this.wrapThrift("get_db_objects_for_grantee", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getDbObjectPrivsAsync", this.handleErrors(this.wrapThrift("get_db_object_privs", this.overSingleClient, function (_ref9) {
      var _ref10 = _slicedToArray(_ref9, 2),
          objectName = _ref10[0],
          type = _ref10[1];

      return [objectName, _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDBObjectType[type]];
    })));

    _defineProperty(this, "getAllRolesForUserAsync", this.handleErrors(this.wrapThrift("get_all_roles_for_user", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getAllEffectiveRolesForUserAsync", this.handleErrors(this.wrapThrift("get_all_effective_roles_for_user", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "hasObjectPrivilegesAsync", this.handleErrors(this.wrapThrift("has_object_privilege", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "hasDbPrivilegesAsync", function (granteeName, dbName, dbPrivs) {
      return _this2.hasObjectPrivilegesAsync(granteeName, dbName, _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDBObjectType.DatabaseDBObjectType, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDBObjectPermissions({
        database_permissions_: new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDatabasePermissions(dbPrivs)
      }));
    });

    _defineProperty(this, "getSessionInfoAsync", this.handleErrors(this.wrapThrift("get_session_info", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "createCustomExpressionAsync", this.handleErrors(this.wrapThrift("create_custom_expression", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getCustomExpressionsAsync", this.handleErrors(this.wrapThrift("get_custom_expressions", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "updateCustomExpressionAsync", this.handleErrors(this.wrapThrift("update_custom_expression", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "deleteCustomExpressionsAsync", this.handleErrors(this.wrapThrift("delete_custom_expressions", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "detectColumnTypesAsync", this.handleErrors(function (filename, copyParams) {
      var detectColumnTypes = _this2.wrapThrift("detect_column_types", _this2.overSingleClient, function () {
        return [filename, _helpers__WEBPACK_IMPORTED_MODULE_8__/* .convertObjectToThriftCopyParams */ .Dq(copyParams)];
      });

      return detectColumnTypes().then(function (res) {
        _this2.importerRowDesc = res.row_set.row_desc;
        return res;
      });
    }));

    _defineProperty(this, "queryAsync", this.handleErrors(function (query, options) {
      var columnarResults = true;
      var eliminateNullRows = false;
      var queryId = null;
      var returnTiming = false;
      var limit = -1;
      var curNonce = (_this2._nonce++).toString();

      if (options) {
        columnarResults = options.hasOwnProperty("columnarResults") ? options.columnarResults : columnarResults;
        eliminateNullRows = options.hasOwnProperty("eliminateNullRows") ? options.eliminateNullRows : eliminateNullRows;
        queryId = options.hasOwnProperty("queryId") ? options.queryId : queryId;
        returnTiming = options.hasOwnProperty("returnTiming") ? options.returnTiming : returnTiming;
        limit = options.hasOwnProperty("limit") ? options.limit : limit;
        curNonce = options.hasOwnProperty("logValues") ? _typeof(options.logValues) === "object" ? JSON.stringify(options.logValues) : options.logValues : curNonce;
      }

      var lastQueryTime = queryId in _this2.queryTimes ? _this2.queryTimes[queryId] : _this2.DEFAULT_QUERY_TIME;
      var conId = 0;
      var processResultsOptions = {
        returnTiming: returnTiming,
        eliminateNullRows: eliminateNullRows,
        query: query,
        queryId: queryId,
        conId: conId,
        estimatedQueryTime: lastQueryTime,
        startTime: Date.now()
      };
      var AT_MOST_N = -1;

      var sqlExecute = _this2.wrapThrift("sql_execute", _this2.overSingleClient, function (args) {
        return args;
      });

      var runQuery = function runQuery() {
        return sqlExecute(query, columnarResults, curNonce, limit, AT_MOST_N)["catch"](function (err) {
          if (err.name === "NetworkError") {
            _this2.removeConnection(0);

            if (_this2._numConnections === 0) {
              err.msg = "No remaining database connections";
              throw err;
            }

            return runQuery();
          }

          throw err;
        });
      };

      return _this2.processResults(processResultsOptions, runQuery());
    }));

    _defineProperty(this, "query", this.callbackify("queryAsync", 2));

    _defineProperty(this, "queryDFAsync", this.handleErrors(function (query, options) {
      var deviceId = 0;
      var limit = -1;

      var sqlExecuteDF = _this2.wrapThrift("sql_execute_df", _this2.overSingleClient, function () {
        return [query, _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TDeviceType.CPU, deviceId, limit, _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TArrowTransport.WIRE];
      });

      return sqlExecuteDF().then(function (data) {
        if (_this2._logging) {
          // eslint-disable-next-line no-console
          console.log(query, "on Server", 0, "- Execution Time:", data.execution_time_ms, "ms");
        }

        var buf = Buffer.from(data.df_buffer, "base64");
        var results = (0,apache_arrow__WEBPACK_IMPORTED_MODULE_1__.tableFromIPC)(buf);

        if (options && Boolean(options.returnTiming)) {
          results = {
            results: results,
            timing: {
              execution_time_ms: data.execution_time_ms
            }
          };
        }

        return results;
      });
    }));

    _defineProperty(this, "queryDF", this.callbackify("queryDFAsync", 2));

    _defineProperty(this, "validateQuery", this.handleErrors(function (query) {
      var sqlValidate = _this2.wrapThrift("sql_validate", _this2.overSingleClient, function (args) {
        return args;
      });

      return sqlValidate(query).then(function (fields) {
        var rowDict = fields.reduce(function (accum, value) {
          accum[value.col_name] = value;
          return accum;
        }, {});
        return _this2.convertFromThriftTypes(rowDict);
      });
    }));

    _defineProperty(this, "getTablesAsync", this.handleErrors(function () {
      var getTables = _this2.wrapThrift("get_tables", _this2.overSingleClient, function (args) {
        return args;
      });

      return getTables().then(function (tables) {
        return tables.map(function (table) {
          return {
            name: table,
            label: "obs"
          };
        });
      });
    }));

    _defineProperty(this, "getTables", this.callbackify("getTablesAsync", 0));

    _defineProperty(this, "getTablesWithMetaAsync", this.handleErrors(function () {
      var getTablesMeta = _this2.wrapThrift("get_tables_meta", _this2.overSingleClient, function (args) {
        return args;
      });

      return getTablesMeta().then(function (tables) {
        return tables.map(function (table) {
          return {
            name: table.table_name,
            num_cols: Number(table.num_cols.toString()),
            col_datum_types: table.col_types.map(function (type) {
              return _this2._datumEnum[type.type];
            }),
            is_view: table.is_view,
            is_replicated: table.is_replicated,
            shard_count: Number(table.shard_count.toString()),
            max_rows: isFinite(table.max_rows) ? Number(table.max_rows.toString()) : -1
          };
        });
      });
    }));

    _defineProperty(this, "getTablesWithMeta", this.callbackify("getTablesWithMetaAsync", 0));

    _defineProperty(this, "getTablesMetaAsync", this.handleErrors(this.wrapThrift("get_tables_meta", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getTablesMeta", this.callbackify("getTablesMetaAsync", 0));

    _defineProperty(this, "getTableEpochByNameAsync", this.handleErrors(this.wrapThrift("get_table_epoch_by_name", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getTableEpochByName", this.callbackify("getTableEpochByNameAsync", 0));

    _defineProperty(this, "getTableFunctionNamesAsync", this.handleErrors(this.wrapThrift("get_table_function_names", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getTableFunctionNames", this.callbackify("getTableFunctionNamesAsync", 0));

    _defineProperty(this, "getRuntimeTableFunctionNamesAsync", this.handleErrors(this.wrapThrift("get_runtime_table_function_names", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getRuntimeTableFunctionNames", this.callbackify("getRuntimeTableFunctionNamesAsync", 0));

    _defineProperty(this, "getTableFunctionDetailsAsync", this.handleErrors(this.wrapThrift("get_table_function_details", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getTableFunctionDetails", this.callbackify("getTableFunctionDetailsAsync", 0));

    _defineProperty(this, "getCompletionHintsAsync", this.handleErrors(this.wrapThrift("get_completion_hints", this.overSingleClient, function (_ref11) {
      var _ref12 = _slicedToArray(_ref11, 2),
          queryString = _ref12[0],
          cursor = _ref12[1].cursor;

      return [queryString, cursor];
    })));

    _defineProperty(this, "getCompletionHints", this.callbackify("getCompletionHintsAsync", 2));

    _defineProperty(this, "buildTFileTypeMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TFileType) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TFileType.hasOwnProperty(key)) {
          _this2.TFileTypeMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TFileType[key]] = key;
        }
      }
    });

    _defineProperty(this, "buildTImportHeaderRowMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TImportHeaderRow) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TImportHeaderRow.hasOwnProperty(key)) {
          _this2.TImportHeaderRowMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TImportHeaderRow[key]] = key;
        }
      }
    });

    _defineProperty(this, "buildTEncodingTypeMap", function () {
      for (var encoding in _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TEncodingType) {
        if (_thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TEncodingType.hasOwnProperty(encoding)) {
          _this2.TEncodingTypeMap[_thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TEncodingType[encoding]] = encoding;
        }
      }
    });

    _defineProperty(this, "buildTRasterPointTypeMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointType) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointType.hasOwnProperty(key)) {
          _this2.TRasterPointTypeMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointType[key]] = key;
        }
      }
    });

    _defineProperty(this, "buildTRasterPointTransformMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointTransform) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointTransform.hasOwnProperty(key)) {
          _this2.TRasterPointTransformMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointTransform[key]] = key;
        }
      }
    });

    _defineProperty(this, "buildTSourceTypeMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TSourceType) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TSourceType.hasOwnProperty(key)) {
          _this2.TSourceTypeMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TSourceType[key]] = key;
        }
      }
    });

    _defineProperty(this, "getFieldsAsync", this.handleErrors(function (tableName) {
      var getTableDetails = _this2.wrapThrift("get_table_details", _this2.overSingleClient, function (args) {
        return args;
      });

      return getTableDetails(tableName).then(function (fields) {
        if (fields) {
          var rowDict = fields.row_desc.reduce(function (accum, value) {
            accum[value.col_name] = value;
            return accum;
          }, {});
          return _objectSpread(_objectSpread({}, fields), {}, {
            columns: _this2.convertFromThriftTypes(rowDict)
          });
        } else {
          throw new Error("Table (".concat(tableName, ") not found"));
        }
      });
    }));

    _defineProperty(this, "getFields", this.callbackify("getFieldsAsync", 1));

    _defineProperty(this, "createTableAsync", this.handleErrors(this.wrapThrift("create_table", this.overAllClients, function (_ref13) {
      var _ref14 = _slicedToArray(_ref13, 4),
          tableName = _ref14[0],
          rowDescObj = _ref14[1],
          createParams = _ref14[2],
          options = _ref14[3];

      return [tableName, (options === null || options === void 0 ? void 0 : options.useUnmodifiedRowDesc) ? rowDescObj : _helpers__WEBPACK_IMPORTED_MODULE_8__/* .mutateThriftRowDesc */ .HP(rowDescObj, _this2.importerRowDesc), createParams];
    })));

    _defineProperty(this, "createTable", this.callbackify("createTableAsync", 4));

    _defineProperty(this, "importTableAsync", this.handleErrors(this.wrapThrift("import_table", this.overAllClients, function (_ref15) {
      var _ref16 = _slicedToArray(_ref15, 3),
          tableName = _ref16[0],
          fileName = _ref16[1],
          copyParams = _ref16[2];

      return [tableName, fileName, _helpers__WEBPACK_IMPORTED_MODULE_8__/* .convertObjectToThriftCopyParams */ .Dq(copyParams)];
    })));

    _defineProperty(this, "importTableGeoAsync", this.handleErrors(this.wrapThrift("import_geo_table", this.overAllClients, function (_ref17) {
      var _ref18 = _slicedToArray(_ref17, 4),
          tableName = _ref18[0],
          fileName = _ref18[1],
          copyParams = _ref18[2],
          rowDescObj = _ref18[3];

      return [tableName, fileName, _helpers__WEBPACK_IMPORTED_MODULE_8__/* .convertObjectToThriftCopyParams */ .Dq(copyParams), _helpers__WEBPACK_IMPORTED_MODULE_8__/* .mutateThriftRowDesc */ .HP(rowDescObj, _this2.importerRowDesc), new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TCreateParams()];
    })));

    _defineProperty(this, "renderVegaAsync", this.handleErrors(function (widgetid, vega, options) {
      var queryId = null;
      var compressionLevel = COMPRESSION_LEVEL_DEFAULT;

      if (options) {
        queryId = options.hasOwnProperty("queryId") ? options.queryId : queryId;
        compressionLevel = options.hasOwnProperty("compressionLevel") ? options.compressionLevel : compressionLevel;
      }

      var lastQueryTime = queryId in _this2.queryTimes ? _this2.queryTimes[queryId] : _this2.DEFAULT_QUERY_TIME;
      var curNonce = (_this2._nonce++).toString();

      if (options) {
        curNonce = options.hasOwnProperty("logValues") ? _typeof(options.logValues) === "object" ? JSON.stringify(options.logValues) : options.logValues : curNonce;
      }

      var conId = 0;
      _this2._lastRenderCon = conId;
      var processResultsOptions = {
        isImage: true,
        query: "render: ".concat(vega),
        queryId: queryId,
        conId: conId,
        estimatedQueryTime: lastQueryTime
      };

      var renderVega = _this2.wrapThrift("render_vega", _this2.overSingleClient, function (args) {
        return args;
      });

      return _this2.processResults(processResultsOptions, renderVega(widgetid, vega, compressionLevel, curNonce));
    }));

    _defineProperty(this, "renderVega", this.callbackify("renderVegaAsync", 3));

    _defineProperty(this, "getResultRowForPixelAsync", this.handleErrors(function (widgetId, pixel, tableColNamesMap) {
      var pixelRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;

      if (!(pixel instanceof _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TPixel)) {
        pixel = new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TPixel(pixel);
      }

      var columnFormat = true; // BOOL

      var curNonce = (_this2._nonce++).toString();
      return _this2._client[_this2._lastRenderCon].get_result_row_for_pixel(_this2._sessionId[_this2._lastRenderCon], widgetId, pixel, tableColNamesMap, columnFormat, pixelRadius, curNonce).then(function (results) {
        results = Array.isArray(results) ? results.pixel_rows : [results];
        var processResultsOptions = {
          isImage: false,
          eliminateNullRows: false,
          query: "pixel request",
          queryId: -2
        };
        var processor = (0,_process_query_results__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(_this2._logging, _this2.updateQueryTimes);
        var numPixels = results.length;

        for (var p = 0; p < numPixels; p++) {
          results[p].row_set = processor(processResultsOptions, _this2._datumEnum, results[p]);
        }

        return results;
      });
    }));

    _defineProperty(this, "getResultRowForPixel", this.callbackify("getResultRowForPixelAsync", 4));

    this._useBinaryProtocol = false;
    this._host = null;
    this._user = null;
    this._password = null;
    this._port = null;
    this._dbName = null;
    this._client = null;
    this._sessionId = null;
    this._protocol = null;
    this._disableAutoReconnect = false;
    this._datumEnum = {};
    this.TFileTypeMap = {};
    this.TEncodingTypeMap = {};
    this.TImportHeaderRowMap = {};
    this.TRasterPointTypeMap = {};
    this.TRasterPointTransformMap = {};
    this.TSourceTypeMap = {};
    this._logging = false;
    this._platform = "heavydb";
    this._nonce = 0;
    this._balanceStrategy = "adaptive";
    this._numConnections = 0;
    this._lastRenderCon = 0;
    this.queryTimes = {};
    this.serverQueueTimes = null;
    this.serverPingTimes = null;
    this.pingCount = null;
    this.DEFAULT_QUERY_TIME = 50;
    this.NUM_PINGS_PER_SERVER = 4;
    this.importerRowDesc = null; // invoke initialization methods

    this.invertDatumTypes();
    this.buildTFileTypeMap();
    this.buildTEncodingTypeMap();
    this.buildTImportHeaderRowMap();
    this.buildTRasterPointTypeMap();
    this.buildTRasterPointTransformMap();
    this.buildTSourceTypeMap();

    this.processResults = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var promise = arguments.length > 1 ? arguments[1] : undefined;
      return promise["catch"](function (error) {
        if (_this2._logging && options.query) {
          // eslint-disable-next-line no-console
          console.error(options.query, "\n", error);
        }

        throw error;
      }).then(function (result) {
        var processor = (0,_process_query_results__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(_this2._logging, _this2.updateQueryTimes);
        var processResultsObject = processor(options, _this2._datumEnum, result);
        return processResultsObject;
      });
    }; // return this to allow chaining off of instantiation


    return this;
  }

  _createClass(DbCon, [{
    key: "removeConnection",
    value: function removeConnection(conId) {
      if (conId < 0 || conId >= this.numConnections) {
        var err = {
          msg: "Remove connection id invalid"
        };
        throw err;
      }

      this._client.splice(conId, 1);

      this._sessionId.splice(conId, 1);

      this._numConnections--;
    }
  }, {
    key: "xhrWithCredentials",
    value: function xhrWithCredentials(enabled) {
      CustomXHRConnection.withCredentials = Boolean(enabled);
    }
    /**
     * Initializes the connector for use. This is similar to `connect()`, but stops short of
     * actually connecting to the server.
     *
     * @return {DbCon} Object.
     */

  }, {
    key: "initClients",
    value: function initClients() {
      var allAreArrays = Array.isArray(this._host) && Array.isArray(this._port) && Array.isArray(this._dbName);

      if (!allAreArrays) {
        throw new Error("Host, port, and dbName must be arrays.");
      }

      this._client = [];
      this._sessionId = [];

      if (!this._host[0]) {
        throw new Error("Please enter a host name.");
      } else if (!this._port[0]) {
        throw new Error("Please enter a port.");
      } // now check to see if length of all arrays are the same and > 0


      var hostLength = this._host.length;

      if (hostLength < 1) {
        throw new Error("Must have at least one server to connect to.");
      }

      if (hostLength !== this._port.length) {
        throw new Error("Array connection parameters must be of equal length.");
      }

      if (!this._protocol) {
        this._protocol = this._host.map(function () {
          return  true ? window.location.protocol.replace(":", "") : 0;
        });
      }

      var transportUrls = this.getEndpoints();
      var clients = [];

      for (var h = 0; h < hostLength; h++) {
        var client = buildClient(transportUrls[h], this._useBinaryProtocol);
        clients.push(client);
      }

      this._client = clients;
      this._numConnections = this._client.length;
      return this;
    }
    /**
     * Create a connection to the MapD server, generating a client and session ID.
     * @return {Promise.DbCon} Object.
     *
     * @example <caption>Connect to a MapD server:</caption>
     * var con = new DbCon()
     *   .host('localhost')
     *   .port('8080')
     *   .dbName('myDatabase')
     *   .user('foo')
     *   .password('bar')
     *   .connect()
     *   .then((con) => console.log(con.sessionId()));
     *
     *   // ["om9E9Ujgbhl6wIzWgLENncjWsaXRDYLy"]
     */

  }, {
    key: "connectAsync",
    value: function connectAsync() {
      var _this3 = this;

      if (!Array.isArray(this._user) || !Array.isArray(this._password)) {
        return Promise.reject("Username and password must be arrays.");
      }

      if (!this._dbName[0]) {
        return Promise.reject("Please enter a database.");
      } else if (!this._user[0]) {
        return Promise.reject("Please enter a username.");
      } else if (!this._password[0]) {
        return Promise.reject("Please enter a password.");
      } // now check to see if length of all arrays are the same and > 0


      var hostLength = this._host.length;

      if (hostLength < 1) {
        return Promise.reject("Must have at least one server to connect to.");
      }

      if (hostLength !== this._port.length || hostLength !== this._user.length || hostLength !== this._password.length || hostLength !== this._dbName.length) {
        return Promise.reject("Array connection parameters must be of equal length.");
      }

      var clients = [];
      this.initClients();
      clients = this._client; // Reset the client property, so we can add only the ones that we can connect to below

      this._client = [];
      return Promise.all(clients.map(function (client, h) {
        return client.connect(_this3._user[h], _this3._password[h], _this3._dbName[h]).then(function (sessionId) {
          _this3._client.push(client);

          _this3._sessionId.push(sessionId);

          return null;
        });
      })).then(function () {
        return _this3;
      });
    }
    /**
     * Create a connection to the MapD server, generating a client and session ID.
     * @param {Function} callback An optional callback that takes `(err, success)` as its signature.  Returns con singleton if successful.
     * @return {Promise.DbCon} Object.
     *
     * @example <caption>Connect to a MapD server:</caption>
     * var con = new DbCon()
     *   .host('localhost')
     *   .port('8080')
     *   .dbName('myDatabase')
     *   .user('foo')
     *   .password('bar')
     *   .connect((err, con) => console.log(con.sessionId()));
     *
     *   // ["om9E9Ujgbhl6wIzWgLENncjWsaXRDYLy"]
     */

  }, {
    key: "convertFromThriftTypes",
    value: function convertFromThriftTypes(fields) {
      var fieldsArray = []; // silly to change this from map to array
      // - then later it turns back to map

      for (var key in fields) {
        if (fields.hasOwnProperty(key)) {
          fieldsArray.push({
            name: key,
            type: this._datumEnum[fields[key].col_type.type],
            precision: fields[key].col_type.precision,
            is_array: fields[key].col_type.is_array,
            is_dict: fields[key].col_type.encoding === _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TEncodingType.DICT // eslint-disable-line no-undef

          });
        }
      }

      return fieldsArray;
    }
    /**
     * Disconnect from the server and then clear the client and session values.
     * @return {Promise.DbCon} Object.
     *
     * @example <caption>Disconnect from the server:</caption>
     *
     * con.disconnect()
     */

  }, {
    key: "invertDatumTypes",

    /**
     * Create an array-like object from {@link TDatumType} by
     * changing the order of the string key and numerical value.
     *
     * @returns {Undefined} This function does not return anything.
     */
    value: function invertDatumTypes() {
      var datumType = _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TDatumType; // eslint-disable-line no-undef

      for (var key in datumType) {
        if (datumType.hasOwnProperty(key)) {
          this._datumEnum[datumType[key]] = key;
        }
      }
    }
    /**
     * Get a list of field objects for a specified table.
     * @param {String} tableName Name of table containing field names.
     * @return {Promise.Array<Object>} The formatted list of field objects.
     *
     * @example <caption>Get the list of fields from a specific table:</caption>
     *
     * con.getFields('flights', (err, res) => console.log(res))
     * // [{
     *   name: 'fieldName',
     *   type: 'BIGINT',
     *   is_array: false,
     *   is_dict: false
     * }, ...]
     */

  }, {
    key: "importTableAsyncWrapper",
    value: function importTableAsyncWrapper(isShapeFile) {
      return isShapeFile ? this.importTableGeoAsync.bind(this) : this.importTableAsync.bind(this);
    }
  }, {
    key: "importTable",
    value: function importTable(tableName, fileName, copyParams, rowDescObj, isShapeFile, callback) {
      if (isShapeFile) {
        var func = this.callbackify("importTableGeoAsync", 4);
        return func(tableName, fileName, copyParams, rowDescObj, callback);
      } else {
        var _func = this.callbackify("importTableAsync", 3);

        return _func(tableName, fileName, copyParams, callback);
      }
    }
    /**
     * Use for backend rendering. This method fetches a PNG image that is a
     * render of the Vega JSON object. The Image will be a string if using
     * browser-connector.js, or a Buffer otherwise.
     *
     * @param {Number} widgetid The widget ID of the calling widget.
     * @param {String} vega The Vega JSON.
     * @param {Object} options The options for the render query.
     * @param {Number} options.compressionLevel The PNG compression level.
     *                  Range: 1 (low compression, faster) to 10 (high compression, slower).
     *                  Default: 3.
     * @returns {Promise.Image} Base64 image.
     */

  }, {
    key: "sessionId",
    // ** Configuration methods **

    /**
     * Get or set the session ID used by the server to serve the correct data.
     * This is typically set by {@link connect} and should not be set manually.
     * @param {Number} sessionId The session ID of the current connection.
     * @return {Number|DbCon} - The session ID or MapD connector itself.
     *
     * @example <caption>Get the session ID:</caption>
     *
     *  con.sessionId();
     * // sessionID === 3145846410
     *
     * @example <caption>Set the session ID:</caption>
     * var con = new DbCon().connect().sessionId(3415846410);
     * // NOTE: It is generally unsafe to set the session ID manually.
     */
    value: function sessionId(_sessionId) {
      if (!arguments.length) {
        return this._sessionId;
      }

      this._sessionId = arrayify(_sessionId);
      return this;
    }
  }, {
    key: "useBinaryProtocol",
    value: function useBinaryProtocol(use) {
      if (!arguments.length) {
        return this._useBinaryProtocol;
      }

      this._useBinaryProtocol = Boolean(use);
      return this;
    }
    /**
     * Get or set the connection server hostname.
     * This is is typically the first method called after instantiating a new DbCon.
     * @param {String} host The hostname address.
     * @return {String|DbCon} The hostname or MapD connector itself.
     *
     * @example <caption>Set the hostname:</caption>
     * var con = new DbCon().host('localhost');
     *
     * @example <caption>Get the hostname:</caption>
     * var host = con.host();
     * // host === 'localhost'
     */

  }, {
    key: "host",
    value: function host(_host) {
      if (!arguments.length) {
        return this._host;
      }

      this._host = arrayify(_host);
      return this;
    }
    /**
     * Get or set the connection port.
     * @param {String} port - The port to connect on.
     * @return {String|DbCon} - The port or MapD connector itself.
     *
     * @example <caption>Set the port:</caption>
     * var con = new DbCon().port('8080');
     *
     * @example <caption>Get the port:</caption>
     * var port = con.port();
     * // port === '8080'
     */

  }, {
    key: "port",
    value: function port(_port) {
      if (!arguments.length) {
        return this._port;
      }

      this._port = arrayify(_port);
      return this;
    }
    /**
     * Get or set the username with which to authenticate.
     * @param {String} user - The username with which to authenticate.
     * @return {String|DbCon} - The username or MapD connector itself.
     *
     * @example <caption>Set the username:</caption>
     * var con = new DbCon().user('foo');
     *
     * @example <caption>Get the username:</caption>
     * var username = con.user();
     * // user === 'foo'
     */

  }, {
    key: "user",
    value: function user(_user) {
      if (!arguments.length) {
        return this._user;
      }

      this._user = arrayify(_user);
      return this;
    }
    /**
     * Get or set the user password for authentication.
     * @param {String} password The password with which to authenticate.
     * @return {String|DbCon} The password or MapD connector itself.
     *
     * @example <caption>Set the password:</caption>
     * var con = new DbCon().password('bar');
     *
     * @example <caption>Get the username:</caption>
     * var password = con.password();
     * // password === 'bar'
     */

  }, {
    key: "password",
    value: function password(_password) {
      if (!arguments.length) {
        return this._password;
      }

      this._password = arrayify(_password);
      return this;
    }
    /**
     * Get or set the name of the database to connect to.
     * @param {String} dbName - The database to connect to.
     * @return {String|DbCon} - The name of the database or the MapD connector itself.
     *
     * @example <caption>Set the database name:</caption>
     * var con = new DbCon().dbName('myDatabase');
     *
     * @example <caption>Get the database name:</caption>
     * var dbName = con.dbName();
     * // dbName === 'myDatabase'
     */

  }, {
    key: "dbName",
    value: function dbName(_dbName) {
      if (!arguments.length) {
        return this._dbName;
      }

      this._dbName = arrayify(_dbName);
      return this;
    }
    /**
     * Configure whether raw query strings are logged to the console.
     * Used primarily for debugging; `false` by default.
     * @param {Boolean} logging Set to true to enable logging.
     * @return {Boolean|DbCon} The current logging flag or MapD connector itself.
     *
     * @example <caption>Set logging to true:</caption>
     * var con = new DbCon().logging(true);
     *
     * @example <caption>Get the logging flag:</caption>
     * var isLogging = con.logging();
     * // isLogging === true
     */

  }, {
    key: "logging",
    value: function logging(_logging) {
      if (typeof _logging === "undefined") {
        return this._logging;
      } else if (typeof _logging !== "boolean") {
        return "logging can only be set with boolean values";
      }

      this._logging = _logging;
      var isEnabledTxt = _logging ? "enabled" : "disabled";
      return "SQL logging is now ".concat(isEnabledTxt);
    }
    /**
     * The name of the platform.
     * @param {String} platform The platform; "heavydb" by default.
     * @return {String|DbCon} - The platform or MapD connector itself.
     *
     * @example <caption>Set the platform name:</caption>
     * var con = new DbCon().platform('myPlatform');
     *
     * @example <caption>Get the platform name:</caption>
     * var platform = con.platform();
     * // platform === 'myPlatform'
     */

  }, {
    key: "platform",
    value: function platform(_platform) {
      if (!arguments.length) {
        return this._platform;
      }

      this._platform = _platform;
      return this;
    }
    /**
     * Get the number of connections that are currently open.
     * @return {Number} The number of open connections.
     *
     * @example <caption>Get the number of connections:</caption>
     *
     * var numConnections = con.numConnections();
     * // numConnections === 1
     */

  }, {
    key: "numConnections",
    value: function numConnections() {
      return this._numConnections;
    }
    /**
     * The protocol to use for requests.
     * @param {String} protocol <code>http</code> or <code>https</code>.
     * @return {String|DbCon} The protocol or DbCon itself.
     *
     * @example <caption>Set the protocol:</caption>
     * var con = new DbCon().protocol('http');
     *
     * @example <caption>Get the protocol:</caption>
     * var protocol = con.protocol();
     * // protocol === 'http'
     */

  }, {
    key: "protocol",
    value: function protocol(_protocol) {
      if (!arguments.length) {
        return this._protocol;
      }

      this._protocol = arrayify(_protocol);
      return this;
    }
    /**
     * Disables logic that automatically tries to reconnect to the server if there's an error
     *
     * @param {Boolean?} disable - If true, disables auto-reconnect
     * @return {Boolean|DbCon} The status of auto-reconnect, or DbCon itself.
     */

  }, {
    key: "disableAutoReconnect",
    value: function disableAutoReconnect(disable) {
      if (!arguments.length) {
        return this._disableAutoReconnect;
      }

      this._disableAutoReconnect = disable;
      return this;
    }
    /**
     * Generates a list of endpoints from the connection parameters.
     * @return {Array<String>} List of endpoints.
     *
     * @example <caption>Get the endpoints:</caption>
     * var con = new DbCon().protocol('http').host('localhost').port('8000');
     * var endpoints = con.getEndpoints();
     * // endpoints === [ 'http://localhost:8000' ]
     */

  }, {
    key: "getEndpoints",
    value: function getEndpoints() {
      var _this4 = this;

      return this._host.map(function (host, i) {
        return "".concat(_this4._protocol[i], "://").concat(host, ":").concat(_this4._port[i]);
      });
    }
    /**
     * Set the license for Trial or Enterprise
     * @param {String} key The key to install
     * @param {Object} config Protocol, host and port to connect to
     * @return {Promise.<Object>} Claims or Error.
     */

  }, {
    key: "setLicenseKey",
    value: function setLicenseKey(key, _ref19) {
      var protocol = _ref19.protocol,
          host = _ref19.host,
          port = _ref19.port;

      var client = Array.isArray(this._client) && this._client[0];

      var sessionId = this._sessionId && this._sessionId[0];

      if (!client) {
        var url = "".concat(protocol, "://").concat(host, ":").concat(port);
        client = buildClient(url, this._useBinaryProtocol);
        sessionId = "";
      }

      return client.set_license_key(sessionId, key, this._nonce++);
    }
    /**
     * Get the license for Trial or Enterprise
     * @param {Object} config Protocol, host and port to connect to
     * @return {Promise.<Object>} Claims or Error.
     */

  }, {
    key: "getLicenseClaims",
    value: function getLicenseClaims(_ref20) {
      var protocol = _ref20.protocol,
          host = _ref20.host,
          port = _ref20.port;

      var client = Array.isArray(this._client) && this._client[0];

      var sessionId = this._sessionId && this._sessionId[0];

      if (!client) {
        var url = "".concat(protocol, "://").concat(host, ":").concat(port);
        client = buildClient(url, this._useBinaryProtocol);
        sessionId = "";
      }

      return client.get_license_claims(sessionId, this._nonce++);
    }
  }, {
    key: "isTimeoutError",
    value: function isTimeoutError(result) {
      return result instanceof _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDBException && (String(result.error_msg).includes('Session not valid') || //.indexOf("Session not valid.") !== -1 ||
      String(result.error_msg).indexOf("User should re-authenticate.") !== -1);
    }
  }]);

  return DbCon;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DbCon);







/***/ }),

/***/ 2033:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dq": () => /* binding */ convertObjectToThriftCopyParams,
/* harmony export */   "HP": () => /* binding */ mutateThriftRowDesc,
/* harmony export */   "RK": () => /* binding */ timestampToMs,
/* harmony export */   "kS": () => /* binding */ valueToBoolean
/* harmony export */ });
/* harmony import */ var _thrift_heavy_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2607);
/* harmony import */ var _thrift_heavy_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_thrift_heavy_types__WEBPACK_IMPORTED_MODULE_0__);

var convertObjectToThriftCopyParams = function convertObjectToThriftCopyParams(obj) {
  return new _thrift_heavy_types__WEBPACK_IMPORTED_MODULE_0__.TCopyParams(obj);
}; // eslint-disable-line no-undef

var mutateThriftRowDesc = function mutateThriftRowDesc(rowDescArray, thriftRowDescArray) {
  rowDescArray.forEach(function (obj, i) {
    thriftRowDescArray[i].col_name = obj.clean_col_name;
    thriftRowDescArray[i].col_type.encoding = obj.col_type.encoding;
    thriftRowDescArray[i].col_type.precision = obj.col_type.precision;
    thriftRowDescArray[i].col_type.comp_param = obj.col_type.comp_param;
    thriftRowDescArray[i].col_type.scale = obj.col_type.scale;
    thriftRowDescArray[i].col_type.type = obj.col_type.type;
  });
  return thriftRowDescArray;
};
/**
 * Converts a raw integer timestamp value from the DB into milliseconds. The DB timestamp value may
 * represent seconds, ms, us, or ns depending on the precision of the column. This value is
 * truncated or extended as necessary to convert to ms precision. The returned ms value is suitable
 * for passing to the JS Date object constructor.
 * @param {Number} timestamp - The raw integer timestamp in the database.
 * @param {Number} precision - The precision of the timestamp column in the database.
 * @returns {Number} The equivalent timestamp in milliseconds.
 */

function timestampToMs(timestamp, precision) {
  // A precision of 0 = sec, 3 = ms. Thus, this line finds the value to divide the DB val
  // eslint-disable-next-line no-magic-numbers
  var divisor = Math.pow(10, precision - 3);
  var timeInMs = timestamp / divisor;
  return timeInMs;
}
/**
 * Converts a Number/BigInt value to a Boolean
 * @param {BigInt} value - A BigInt value
 * @returns {Boolean} The equivalent boolean value representing the buffer
 */

function valueToBoolean(value) {
  if (value.toNumber) {
    return Boolean(value.toNumber(true));
  }

  return Boolean(value);
}

/***/ }),

/***/ 5141:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => /* binding */ processQueryResults
});

// EXTERNAL MODULE: ./src/helpers.js
var helpers = __webpack_require__(2033);
;// CONCATENATED MODULE: ./src/process-columnar-results.js

/**
 * Process the column-based results from the query in a row-based format.
 * (Returning row-based results directly from the server is inefficient.)
 *
 * @param {TRowSet} data The column-based data returned from a query.
 * @param {Boolean} eliminateNullRows A flag that removes null rows from results.
 * @param {Object} dataEnum A list of types created from when executing {@link #invertDatumTypes}.
 * @returns {Object} The formatted results of the query.
 * @example <caption>Convert data returned in column-based format to row-based:</caption>
 */

function processColumnarResults(data, eliminateNullRows, dataEnum) {
  var formattedResult = {
    fields: [],
    results: []
  };
  var numCols = data.row_desc.length;
  var numRows = typeof data.columns[0] === "undefined" ? 0 : data.columns[0].nulls.length;
  formattedResult.fields = data.row_desc.map(function (field) {
    return {
      name: field.col_name,
      type: dataEnum[field.col_type.type],
      is_array: field.col_type.is_array
    };
  });

  for (var r = 0; r < numRows; r++) {
    if (eliminateNullRows) {
      var rowHasNull = false;

      for (var c = 0; c < numCols; c++) {
        if (data.columns[c].nulls[r]) {
          rowHasNull = true;
          break;
        }
      }

      if (rowHasNull) {
        continue; // eslint-disable-line no-continue
      }
    }

    var row = {};

    for (var _c = 0; _c < numCols; _c++) {
      var fieldName = formattedResult.fields[_c].name;
      var fieldType = formattedResult.fields[_c].type;
      var fieldIsArray = formattedResult.fields[_c].is_array;
      var isNull = data.columns[_c].nulls[r];
      var fieldPrecision = data.row_desc[_c].col_type.precision;

      if (isNull) {
        // row[fieldName] = "NULL";
        row[fieldName] = null;
        continue; // eslint-disable-line no-continue
      }

      if (fieldIsArray) {
        row[fieldName] = [];
        var arrayNumElems = data.columns[_c].data.arr_col[r].nulls.length;

        for (var e = 0; e < arrayNumElems; e++) {
          if (data.columns[_c].data.arr_col[r].nulls[e]) {
            row[fieldName].push("NULL");
            continue; // eslint-disable-line no-continue
          }

          switch (fieldType) {
            case "BOOL":
              row[fieldName].push((0,helpers/* valueToBoolean */.kS)(data.columns[_c].data.arr_col[r].data.int_col[e]));
              break;

            case "SMALLINT":
            case "INT":
            case "BIGINT":
            case "TINYINT":
              row[fieldName].push(data.columns[_c].data.arr_col[r].data.int_col[e]);
              break;

            case "FLOAT":
            case "DOUBLE":
            case "DECIMAL":
              row[fieldName].push(data.columns[_c].data.arr_col[r].data.real_col[e]);
              break;

            case "STR":
              row[fieldName].push(data.columns[_c].data.arr_col[r].data.str_col[e]);
              break;

            case "TIME":
            case "TIMESTAMP":
            case "DATE":
              var timeInMs = (0,helpers/* timestampToMs */.RK)(data.columns[_c].data.int_col[r], fieldPrecision);
              row[fieldName].push(timeInMs);
              break;

            default:
              throw new Error("Unrecognized array field type: ".concat(fieldType));
          }
        }
      } else {
        // Not an array
        switch (fieldType) {
          case "BOOL":
            row[fieldName] = (0,helpers/* valueToBoolean */.kS)(data.columns[_c].data.int_col[r]);
            break;

          case "SMALLINT":
          case "INT":
          case "BIGINT":
          case "TINYINT":
            row[fieldName] = data.columns[_c].data.int_col[r];
            break;

          case "FLOAT":
          case "DOUBLE":
          case "DECIMAL":
            row[fieldName] = data.columns[_c].data.real_col[r];
            break;

          case "STR":
            row[fieldName] = data.columns[_c].data.str_col[r];
            break;

          case "TIME":
          case "TIMESTAMP":
          case "DATE":
            var _timeInMs = (0,helpers/* timestampToMs */.RK)(data.columns[_c].data.int_col[r], fieldPrecision);

            row[fieldName] = new Date(_timeInMs);
            break;

          case "POINT":
          case "LINESTRING":
          case "POLYGON":
          case "MULTIPOLYGON":
            row[fieldName] = data.columns[_c].data.str_col[r];
            break;

          default:
            throw new Error("Unrecognized field type: ".concat(fieldType));
        }
      }
    }

    formattedResult.results.push(row);
  }

  return formattedResult;
}
;// CONCATENATED MODULE: ./src/process-row-results.js

/**
 * Query for row-based results from the server. In general, is inefficient and should be
 * avoided. Instead, use {@link processColumnarResults} and then convert the results to
 * row-based format.
 * @param {TRowSet} data - The row-based data returned from a query.
 * @param {Boolean} eliminateNullRows Flag that removes null rows from results.
 * @param {Object} datumEnum A list of types created from when executing {@link #invertDatumTypes}.
 * @returns {Object} The formatted results of the query.
 * @example<caption> Return row-based results directly from the server:
 */

function processRowResults(data, eliminateNullRows, datumEnum) {
  var numCols = data.row_desc.length;
  var formattedResult = {
    fields: [],
    results: []
  };
  formattedResult.fields = data.row_desc.map(function (field) {
    return {
      name: field.col_name,
      type: datumEnum[field.col_type.type],
      is_array: field.col_type.is_array
    };
  });
  formattedResult.results = [];
  var numRows = 0;

  if (typeof data.rows !== "undefined" && data.rows !== null) {
    numRows = data.rows.length; // so won't throw if data.rows is missing
  }

  for (var r = 0; r < numRows; r++) {
    if (eliminateNullRows) {
      var rowHasNull = false;

      for (var c = 0; c < numCols; c++) {
        if (data.rows[r].columns[c].is_null) {
          rowHasNull = true;
          break;
        }
      }

      if (rowHasNull) {
        continue; // eslint-disable-line no-continue
      }
    }

    var row = {};

    for (var _c = 0; _c < numCols; _c++) {
      var fieldName = formattedResult.fields[_c].name;
      var fieldType = formattedResult.fields[_c].type;
      var fieldIsArray = formattedResult.fields[_c].is_array;
      var fieldPrecision = data.row_desc[_c].col_type.precision;

      if (fieldIsArray) {
        if (data.rows[r].cols[_c].is_null) {
          row[fieldName] = "NULL";
          continue; // eslint-disable-line no-continue
        }

        row[fieldName] = [];
        var arrayNumElems = data.rows[r].cols[_c].val.arr_val.length;

        for (var e = 0; e < arrayNumElems; e++) {
          var elemDatum = data.rows[r].cols[_c].val.arr_val[e];

          if (elemDatum.is_null) {
            row[fieldName].push("NULL");
            continue; // eslint-disable-line no-continue
          }

          switch (fieldType) {
            case "BOOL":
              row[fieldName].push((0,helpers/* valueToBoolean */.kS)(elemDatum.val.int_val));
              break;

            case "SMALLINT":
            case "INT":
            case "BIGINT":
            case "TINYINT":
              row[fieldName].push(elemDatum.val.int_val);
              break;

            case "FLOAT":
            case "DOUBLE":
            case "DECIMAL":
              row[fieldName].push(elemDatum.val.real_val);
              break;

            case "STR":
              row[fieldName].push(elemDatum.val.str_val);
              break;

            case "TIME":
            case "TIMESTAMP":
            case "DATE":
              var timeInMs = (0,helpers/* timestampToMs */.RK)(elemDatum.val.int_val, fieldPrecision);
              row[fieldName].push(timeInMs);
              break;

            default:
              throw new Error("Unrecognized array field type: ".concat(fieldType));
          }
        }
      } else {
        var scalarDatum = data.rows[r].cols[_c];

        if (scalarDatum.is_null) {
          row[fieldName] = "NULL";
          continue; // eslint-disable-line no-continue
        }

        switch (fieldType) {
          case "BOOL":
            row[fieldName] = (0,helpers/* valueToBoolean */.kS)(scalarDatum.val.int_val);
            break;

          case "SMALLINT":
          case "INT":
          case "BIGINT":
          case "TINYINT":
            row[fieldName] = scalarDatum.val.int_val;
            break;

          case "FLOAT":
          case "DOUBLE":
          case "DECIMAL":
            row[fieldName] = scalarDatum.val.real_val;
            break;

          case "STR":
            row[fieldName] = scalarDatum.val.str_val;
            break;

          case "TIME":
          case "TIMESTAMP":
          case "DATE":
            var _timeInMs = (0,helpers/* timestampToMs */.RK)(scalarDatum.val.int_val, fieldPrecision);

            row[fieldName] = new Date(_timeInMs);
            break;

          case "POINT":
          case "LINESTRING":
          case "POLYGON":
          case "MULTIPOLYGON":
            row[fieldName] = scalarDatum.val.str_val;
            break;

          default:
            throw new Error("Unrecognized field type: ".concat(fieldType));
        }
      }
    }

    formattedResult.results.push(row);
  }

  return formattedResult;
}
;// CONCATENATED MODULE: ./src/process-query-results.js


/**
 * Determines how to process raw results when they return from the server.
 *
 * @param {Boolean} logging If enabled, shows on the console how long the query took to run.
 * @param {Function} updateQueryTimes A function that updates internal query times on the connector.
 * @param {Object} options A list of options for processing the results.
 * @param {Boolean} options.isImage Set to true when querying for backend-rendered images.
 * @param {Boolean} options.eliminateNullRows Removes null rows.
 * @param {String} options.query The SQL query string used only for logging.
 * @param {Number} options.queryId The ID of the query.
 * @param {Number} options.conId The unique connector identification.
 * @param {String} options.estimatedQueryTime The estimate of the query time.
 * @param {Object} result - The query result used to decide whether to process
 *                          as column or row results.
 * @return {Object} result if image, otherwise formatted results.
 */

function processQueryResults(logging, updateQueryTimes) {
  return function (options, _datumEnum, result) {
    var isImage = false;
    var eliminateNullRows = false;
    var query = null;
    var queryId = null;
    var conId = null;
    var estimatedQueryTime = null;

    if (typeof options !== "undefined") {
      isImage = options.isImage ? options.isImage : false;
      eliminateNullRows = options.eliminateNullRows ? options.eliminateNullRows : false;
      query = options.query ? options.query : null;
      queryId = options.queryId ? options.queryId : null;
      conId = typeof options.conId === "undefined" ? null : options.conId;
      estimatedQueryTime = typeof options.estimatedQueryTime === "undefined" ? null : options.estimatedQueryTime;
    }

    if (result.execution_time_ms && conId !== null && estimatedQueryTime !== null) {
      updateQueryTimes(conId, queryId, estimatedQueryTime, result.execution_time_ms);
    } // should use node_env


    if (logging && result.execution_time_ms) {
      // eslint-disable-next-line no-console
      console.log(query, "on Server", conId, "- Execution Time:", result.execution_time_ms, "ms, Total Time:", result.total_time_ms, "ms, Real Time:", options.startTime ? Date.now() - options.startTime : undefined, "ms");
    }

    if (isImage) {
      return result;
    } else {
      var formattedResult = null;

      if (!result.row_set) {
        throw new Error("No result to process");
      }

      if (result.row_set.is_columnar) {
        formattedResult = processColumnarResults(result.row_set, eliminateNullRows, _datumEnum);
      } else {
        formattedResult = processRowResults(result.row_set, eliminateNullRows, _datumEnum);
      }

      formattedResult.timing = {
        execution_time_ms: result.execution_time_ms,
        total_time_ms: result.total_time_ms
      };
      return options.returnTiming ? formattedResult : formattedResult.results;
    }
  };
}

/***/ }),

/***/ 9742:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ 3818:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global window self */

var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

/* eslint-disable no-restricted-globals */
var isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';
/* eslint-enable no-restricted-globals */

var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

/**
 * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0
 * @see https://github.com/jsdom/jsdom/issues/1537
 */
/* eslint-disable no-undef */
var isJsDom = function isJsDom() {
  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');
};

exports.isBrowser = isBrowser;
exports.isWebWorker = isWebWorker;
exports.isNode = isNode;
exports.isJsDom = isJsDom;

/***/ }),

/***/ 8764:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(9742)
const ieee754 = __webpack_require__(645)
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ 8769:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* globals
	Atomics,
	SharedArrayBuffer,
*/

var undefined;

var $TypeError = TypeError;

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () { throw new $TypeError(); };
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(1405)();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var generator; // = function * () {};
var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};
var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};
var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%ArrayPrototype%': Array.prototype,
	'%ArrayProto_entries%': Array.prototype.entries,
	'%ArrayProto_forEach%': Array.prototype.forEach,
	'%ArrayProto_keys%': Array.prototype.keys,
	'%ArrayProto_values%': Array.prototype.values,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': asyncFunction,
	'%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
	'%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
	'%AsyncGeneratorFunction%': asyncGenFunction,
	'%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
	'%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%Boolean%': Boolean,
	'%BooleanPrototype%': Boolean.prototype,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
	'%Date%': Date,
	'%DatePrototype%': Date.prototype,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%ErrorPrototype%': Error.prototype,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%EvalErrorPrototype%': EvalError.prototype,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
	'%Function%': Function,
	'%FunctionPrototype%': Function.prototype,
	'%Generator%': generator ? getProto(generator()) : undefined,
	'%GeneratorFunction%': generatorFunction,
	'%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
	'%Math%': Math,
	'%Number%': Number,
	'%NumberPrototype%': Number.prototype,
	'%Object%': Object,
	'%ObjectPrototype%': Object.prototype,
	'%ObjProto_toString%': Object.prototype.toString,
	'%ObjProto_valueOf%': Object.prototype.valueOf,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
	'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
	'%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
	'%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
	'%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%RangeErrorPrototype%': RangeError.prototype,
	'%ReferenceError%': ReferenceError,
	'%ReferenceErrorPrototype%': ReferenceError.prototype,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%RegExpPrototype%': RegExp.prototype,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%StringPrototype%': String.prototype,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
	'%SyntaxError%': SyntaxError,
	'%SyntaxErrorPrototype%': SyntaxError.prototype,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
	'%TypeError%': $TypeError,
	'%TypeErrorPrototype%': $TypeError.prototype,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
	'%URIError%': URIError,
	'%URIErrorPrototype%': URIError.prototype,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
	'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};

var bind = __webpack_require__(8612);
var $replace = bind.call(Function.call, String.prototype.replace);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	if (!(name in INTRINSICS)) {
		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
	}

	// istanbul ignore if // hopefully this is impossible to test :-)
	if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
		throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	}

	return INTRINSICS[name];
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);

	var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
	for (var i = 1; i < parts.length; i += 1) {
		if (value != null) {
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, parts[i]);
				if (!allowMissing && !(parts[i] in value)) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				value = desc && 'get' in desc && !('originalValue' in desc.get) ? desc.get : value[parts[i]];
			} else {
				value = value[parts[i]];
			}
		}
	}
	return value;
};


/***/ }),

/***/ 4147:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(8612);

var GetIntrinsic = __webpack_require__(8769);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind() {
	return $reflectApply(bind, $call, arguments);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ 8914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(8769);

var callBind = __webpack_require__(4147);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ 4079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(8769);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 6729:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 7187:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),

/***/ 9804:
/***/ ((module) => {


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};



/***/ }),

/***/ 7648:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 8612:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(7648);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 1405:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = __webpack_require__.g.Symbol;
var hasSymbolSham = __webpack_require__(5419);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 5419:
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 645:
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 5717:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 2584:
/***/ ((module) => {

"use strict";


var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr.call(value) !== '[object Array]' &&
		toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ 8662:
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var generatorFunc = getGeneratorFunc();
var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ 5692:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(9804);
var availableTypedArrays = __webpack_require__(6314);
var callBound = __webpack_require__(8914);

var $toString = callBound('Object.prototype.toString');
var hasSymbols = __webpack_require__(1405)();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(4079);
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new __webpack_require__.g[typedArray]();
		if (!(Symbol.toStringTag in arr)) {
			throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
		}
		var proto = getPrototypeOf(arr);
		var descriptor = gOPD(proto, Symbol.toStringTag);
		if (!descriptor) {
			var superProto = getPrototypeOf(proto);
			descriptor = gOPD(superProto, Symbol.toStringTag);
		}
		toStrTags[typedArray] = descriptor.get;
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};


/***/ }),

/***/ 6792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js

var ws = null

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket
} else if (typeof __webpack_require__.g !== 'undefined') {
  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket
} else if (typeof self !== 'undefined') {
  ws = self.WebSocket || self.MozWebSocket
}

module.exports = ws


/***/ }),

/***/ 135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
//     Int64.js
//
//     Copyright (c) 2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

/**
 * Support for handling 64-bit int numbers in Javascript (node.js)
 *
 * JS Numbers are IEEE-754 binary double-precision floats, which limits the
 * range of values that can be represented with integer precision to:
 *
 * 2^^53 <= N <= 2^53
 *
 * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These
 * objects operate directly on the buffer which means that if they are created
 * using an existing buffer then setting the value will modify the Buffer, and
 * vice-versa.
 *
 * Internal Representation
 *
 * The internal buffer format is Big Endian.  I.e. the most-significant byte is
 * at buffer[0], the least-significant at buffer[7].  For the purposes of
 * converting to/from JS native numbers, the value is assumed to be a signed
 * integer stored in 2's complement form.
 *
 * For details about IEEE-754 see:
 * http://en.wikipedia.org/wiki/Double_precision_floating-point_format
 */

// Useful masks and values for bit twiddling
var MASK31 =  0x7fffffff, VAL31 = 0x80000000;
var MASK32 =  0xffffffff, VAL32 = 0x100000000;

// Map for converting hex octets to strings
var _HEX = [];
for (var i = 0; i < 256; i++) {
  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);
}

//
// Int64
//

/**
 * Constructor accepts any of the following argument types:
 *
 * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset
 * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset
 * new Int64(string)             - Hex string (throws if n is outside int64 range)
 * new Int64(number)             - Number (throws if n is outside int64 range)
 * new Int64(hi, lo)             - Raw bits as two 32-bit values
 */
var Int64 = module.exports = function(a1, a2) {
  if (a1 instanceof Buffer) {
    this.buffer = a1;
    this.offset = a2 || 0;
  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {
    // Under Browserify, Buffers can extend Uint8Arrays rather than an
    // instance of Buffer. We could assume the passed in Uint8Array is actually
    // a buffer but that won't handle the case where a raw Uint8Array is passed
    // in. We construct a new Buffer just in case.
    this.buffer = new Buffer(a1);
    this.offset = a2 || 0;
  } else {
    this.buffer = this.buffer || new Buffer(8);
    this.offset = 0;
    this.setValue.apply(this, arguments);
  }
};


// Max integer value that JS can accurately represent
Int64.MAX_INT = Math.pow(2, 53);

// Min integer value that JS can accurately represent
Int64.MIN_INT = -Math.pow(2, 53);

Int64.prototype = {

  constructor: Int64,

  /**
   * Do in-place 2's compliment.  See
   * http://en.wikipedia.org/wiki/Two's_complement
   */
  _2scomp: function() {
    var b = this.buffer, o = this.offset, carry = 1;
    for (var i = o + 7; i >= o; i--) {
      var v = (b[i] ^ 0xff) + carry;
      b[i] = v & 0xff;
      carry = v >> 8;
    }
  },

  /**
   * Set the value. Takes any of the following arguments:
   *
   * setValue(string) - A hexidecimal string
   * setValue(number) - Number (throws if n is outside int64 range)
   * setValue(hi, lo) - Raw bits as two 32-bit values
   */
  setValue: function(hi, lo) {
    var negate = false;
    if (arguments.length == 1) {
      if (typeof(hi) == 'number') {
        // Simplify bitfield retrieval by using abs() value.  We restore sign
        // later
        negate = hi < 0;
        hi = Math.abs(hi);
        lo = hi % VAL32;
        hi = hi / VAL32;
        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');
        hi = hi | 0;
      } else if (typeof(hi) == 'string') {
        hi = (hi + '').replace(/^0x/, '');
        lo = hi.substr(-8);
        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';
        hi = parseInt(hi, 16);
        lo = parseInt(lo, 16);
      } else {
        throw new Error(hi + ' must be a Number or String');
      }
    }

    // Technically we should throw if hi or lo is outside int32 range here, but
    // it's not worth the effort. Anything past the 32'nd bit is ignored.

    // Copy bytes to buffer
    var b = this.buffer, o = this.offset;
    for (var i = 7; i >= 0; i--) {
      b[o+i] = lo & 0xff;
      lo = i == 4 ? hi : lo >>> 8;
    }

    // Restore sign of passed argument
    if (negate) this._2scomp();
  },

  /**
   * Convert to a native JS number.
   *
   * WARNING: Do not expect this value to be accurate to integer precision for
   * large (positive or negative) numbers!
   *
   * @param allowImprecise If true, no check is performed to verify the
   * returned value is accurate to integer precision.  If false, imprecise
   * numbers (very large positive or negative numbers) will be forced to +/-
   * Infinity.
   */
  toNumber: function(allowImprecise) {
    var b = this.buffer, o = this.offset;

    // Running sum of octets, doing a 2's complement
    var negate = b[o] & 0x80, x = 0, carry = 1;
    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {
      var v = b[o+i];

      // 2's complement for negative numbers
      if (negate) {
        v = (v ^ 0xff) + carry;
        carry = v >> 8;
        v = v & 0xff;
      }

      x += v * m;
    }

    // Return Infinity if we've lost integer precision
    if (!allowImprecise && x >= Int64.MAX_INT) {
      return negate ? -Infinity : Infinity;
    }

    return negate ? -x : x;
  },

  /**
   * Convert to a JS Number. Returns +/-Infinity for values that can't be
   * represented to integer precision.
   */
  valueOf: function() {
    return this.toNumber(false);
  },

  /**
   * Return string value
   *
   * @param radix Just like Number#toString()'s radix
   */
  toString: function(radix) {
    return this.valueOf().toString(radix || 10);
  },

  /**
   * Return a string showing the buffer octets, with MSB on the left.
   *
   * @param sep separator string. default is '' (empty string)
   */
  toOctetString: function(sep) {
    var out = new Array(8);
    var b = this.buffer, o = this.offset;
    for (var i = 0; i < 8; i++) {
      out[i] = _HEX[b[o+i]];
    }
    return out.join(sep || '');
  },

  /**
   * Returns the int64's 8 bytes in a buffer.
   *
   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if
   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.
   */
  toBuffer: function(rawBuffer) {
    if (rawBuffer && this.offset === 0) return this.buffer;

    var out = new Buffer(8);
    this.buffer.copy(out, 0, this.offset, this.offset + 8);
    return out;
  },

  /**
   * Copy 8 bytes of int64 into target buffer at target offset.
   *
   * @param {Buffer} targetBuffer       Buffer to copy into.
   * @param {number} [targetOffset=0]   Offset into target buffer.
   */
  copy: function(targetBuffer, targetOffset) {
    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
  },

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other in sort order.
   *
   * @param {Int64} other  Other Int64 to compare.
   */
  compare: function(other) {

    // If sign bits differ ...
    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {
      return other.buffer[other.offset] - this.buffer[this.offset];
    }

    // otherwise, compare bytes lexicographically
    for (var i = 0; i < 8; i++) {
      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {
        return this.buffer[this.offset+i] - other.buffer[other.offset+i];
      }
    }
    return 0;
  },

  /**
   * Returns a boolean indicating if this integer is equal to other.
   *
   * @param {Int64} other  Other Int64 to compare.
   */
  equals: function(other) {
    return this.compare(other) === 0;
  },

  /**
   * Pretty output in console.log
   */
  inspect: function() {
    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';
  }
};


/***/ }),

/***/ 8486:
/***/ ((module) => {

// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (true) {
        module.exports = definition();

    // RequireJS
    } else { var previousQ, global; }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.toString()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
    obj[prop] = descriptor.value;
    return obj;
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
                object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error, "stack", {value: stack, configurable: true});
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * The counter is used to determine the stopping point for building
 * long stack traces. In makeStackTraceLong we walk backwards through
 * the linked list of promises, only stacks which were created before
 * the rejection are concatenated.
 */
var longStackCounter = 1;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && ({"BROWSER":true}) && ({"BROWSER":true}).Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            promise.stackCounter = longStackCounter++;
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;

        if (Q.longStackSupport && hasStacks) {
            // Only hold a reference to the new promise if long stacks
            // are enabled to reduce memory usage
            promise.source = newPromise;
        }

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Q can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected(err) {
            pendingCount--;
            if (pendingCount === 0) {
                var rejection = err || new Error("" + err);

                rejection.message = ("Q can't get fulfillment value from any promise, all " +
                    "promises were rejected. Last error message: " + rejection.message);

                deferred.reject(rejection);
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
    }
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    if (callback === undefined) {
        throw new Error("Q can't wrap an undefined function");
    }
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});


/***/ }),

/***/ 7533:
/***/ ((__unused_webpack_module, exports) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var POW_8 = Math.pow(2, 8);
var POW_16 = Math.pow(2, 16);
var POW_24 = Math.pow(2, 24);
var POW_32 = Math.pow(2, 32);
var POW_40 = Math.pow(2, 40);
var POW_48 = Math.pow(2, 48);
var POW_52 = Math.pow(2, 52);
var POW_1022 = Math.pow(2, 1022);

exports.readByte = function(b){
	return b > 127 ? b-256 : b;
};

exports.readI16 = function(buff, off) {
  off = off || 0;
  var v = buff[off + 1];
  v += buff[off] << 8;
  if (buff[off] & 128) {
    v -= POW_16;
  }
  return v;
};

exports.readI32 = function(buff, off) {
  off = off || 0;
  var v = buff[off + 3];
  v += buff[off + 2] << 8;
  v += buff[off + 1] << 16;
  v += buff[off] * POW_24;
  if (buff[off] & 0x80) {
    v -= POW_32;
  }
  return v;
};

exports.writeI16 = function(buff, v) {
  buff[1] = v & 0xff;
  v >>= 8;
  buff[0] = v & 0xff;
  return buff;
};

exports.writeI32 = function(buff, v) {
  buff[3] = v & 0xff;
  v >>= 8;
  buff[2] = v & 0xff;
  v >>= 8;
  buff[1] = v & 0xff;
  v >>= 8;
  buff[0] = v & 0xff;
  return buff;
};

exports.readDouble = function(buff, off) {
  off = off || 0;
  var signed = buff[off] & 0x80;
  var e = (buff[off+1] & 0xF0) >> 4;
  e += (buff[off] & 0x7F) << 4;

  var m = buff[off+7];
  m += buff[off+6] << 8;
  m += buff[off+5] << 16;
  m += buff[off+4] * POW_24;
  m += buff[off+3] * POW_32;
  m += buff[off+2] * POW_40;
  m += (buff[off+1] & 0x0F) * POW_48;

  switch (e) {
    case 0:
      e = -1022;
      break;
    case 2047:
      return m ? NaN : (signed ? -Infinity : Infinity);
    default:
      m += POW_52;
      e -= 1023;
  }

  if (signed) {
    m *= -1;
  }

  return m * Math.pow(2, e - 52);
};

/*
 * Based on code from the jspack module:
 * http://code.google.com/p/jspack/
 */
exports.writeDouble = function(buff, v) {
  var m, e, c;

  buff[0] = (v < 0 ? 0x80 : 0x00);

  v = Math.abs(v);
  if (v !== v) {
    // NaN, use QNaN IEEE format
    m = 2251799813685248;
    e = 2047;
  } else if (v === Infinity) {
    m = 0;
    e = 2047;
  } else {
    e = Math.floor(Math.log(v) / Math.LN2);
    c = Math.pow(2, -e);
    if (v * c < 1) {
      e--;
      c *= 2;
    }

    if (e + 1023 >= 2047)
    {
      // Overflow
      m = 0;
      e = 2047;
    }
    else if (e + 1023 >= 1)
    {
      // Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow
      m = (v*c-1) * POW_52;
      e += 1023;
    }
    else
    {
      // Denormalized - also catches the '0' case, somewhat by chance
      m = (v * POW_1022) * POW_52;
      e = 0;
    }
  }

  buff[1] = (e << 4) & 0xf0;
  buff[0] |= (e >> 4) & 0x7f;

  buff[7] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[6] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[5] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[4] = m & 0xff;
  m >>= 8;
  buff[3] = m & 0xff;
  m >>= 8;
  buff[2] = m & 0xff;
  m >>= 8;
  buff[1] |= m & 0x0f;

  return buff;
};


/***/ }),

/***/ 4711:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var log = __webpack_require__(1291);
var binary = __webpack_require__(7533);
var Int64 = __webpack_require__(135);
var Thrift = __webpack_require__(5406);
var Type = Thrift.Type;

module.exports = TBinaryProtocol;

// JavaScript supports only numeric doubles, therefore even hex values are always signed.
// The largest integer value which can be represented in JavaScript is +/-2^53.
// Bitwise operations convert numbers to 32 bit integers but perform sign extension
// upon assigning values back to variables.
var VERSION_MASK = -65536,   // 0xffff0000
    VERSION_1 = -2147418112, // 0x80010000
    TYPE_MASK = 0x000000ff;

TBinaryProtocol.VERSION_MASK = VERSION_MASK;
TBinaryProtocol.VERSION_1 = VERSION_1;
TBinaryProtocol.TYPE_MASK = TYPE_MASK

function TBinaryProtocol(trans, strictRead, strictWrite) {
  this.trans = trans;
  this.strictRead = (strictRead !== undefined ? strictRead : false);
  this.strictWrite = (strictWrite !== undefined ? strictWrite : true);
  this._seqid = null;
};

TBinaryProtocol.prototype.flush = function() {
  return this.trans.flush();
};

TBinaryProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
    if (this.strictWrite) {
      this.writeI32(VERSION_1 | type);
      this.writeString(name);
      this.writeI32(seqid);
    } else {
      this.writeString(name);
      this.writeByte(type);
      this.writeI32(seqid);
    }
    // Record client seqid to find callback again
    if (this._seqid !== null) {
      log.warning('SeqId already set', { 'name': name });
    } else {
      this._seqid = seqid;
      this.trans.setCurrSeqId(seqid);
    }
};

TBinaryProtocol.prototype.writeMessageEnd = function() {
    if (this._seqid !== null) {
        this._seqid = null;
    } else {
        log.warning('No seqid to unset');
    }
};

TBinaryProtocol.prototype.writeStructBegin = function(name) {
};

TBinaryProtocol.prototype.writeStructEnd = function() {
};

TBinaryProtocol.prototype.writeFieldBegin = function(name, type, id) {
  this.writeByte(type);
  this.writeI16(id);
};

TBinaryProtocol.prototype.writeFieldEnd = function() {
};

TBinaryProtocol.prototype.writeFieldStop = function() {
  this.writeByte(Type.STOP);
};

TBinaryProtocol.prototype.writeMapBegin = function(ktype, vtype, size) {
  this.writeByte(ktype);
  this.writeByte(vtype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeMapEnd = function() {
};

TBinaryProtocol.prototype.writeListBegin = function(etype, size) {
  this.writeByte(etype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeListEnd = function() {
};

TBinaryProtocol.prototype.writeSetBegin = function(etype, size) {
  this.writeByte(etype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeSetEnd = function() {
};

TBinaryProtocol.prototype.writeBool = function(bool) {
  if (bool) {
    this.writeByte(1);
  } else {
    this.writeByte(0);
  }
};

TBinaryProtocol.prototype.writeByte = function(b) {
  this.trans.write(new Buffer([b]));
};

TBinaryProtocol.prototype.writeI16 = function(i16) {
  this.trans.write(binary.writeI16(new Buffer(2), i16));
};

TBinaryProtocol.prototype.writeI32 = function(i32) {
  this.trans.write(binary.writeI32(new Buffer(4), i32));
};

TBinaryProtocol.prototype.writeI64 = function(i64) {
  if (i64.buffer) {
    this.trans.write(i64.buffer);
  } else {
    this.trans.write(new Int64(i64).buffer);
  }
};

TBinaryProtocol.prototype.writeDouble = function(dub) {
  this.trans.write(binary.writeDouble(new Buffer(8), dub));
};

TBinaryProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
  if (typeof(arg) === 'string') {
    this.writeI32(Buffer.byteLength(arg, encoding));
    this.trans.write(new Buffer(arg, encoding));
  } else if ((arg instanceof Buffer) ||
             (Object.prototype.toString.call(arg) == '[object Uint8Array]')) {
    // Buffers in Node.js under Browserify may extend UInt8Array instead of
    // defining a new object. We detect them here so we can write them
    // correctly
    this.writeI32(arg.length);
    this.trans.write(arg);
  } else {
    throw new Error(name + ' called without a string/Buffer argument: ' + arg);
  }
};

TBinaryProtocol.prototype.writeString = function(arg) {
  this.writeStringOrBinary('writeString', 'utf8', arg);
};

TBinaryProtocol.prototype.writeBinary = function(arg) {
  this.writeStringOrBinary('writeBinary', 'binary', arg);
};

TBinaryProtocol.prototype.readMessageBegin = function() {
  var sz = this.readI32();
  var type, name, seqid;

  if (sz < 0) {
    var version = sz & VERSION_MASK;
    if (version != VERSION_1) {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad version in readMessageBegin: " + sz);
    }
    type = sz & TYPE_MASK;
    name = this.readString();
    seqid = this.readI32();
  } else {
    if (this.strictRead) {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "No protocol version header");
    }
    name = this.trans.read(sz);
    type = this.readByte();
    seqid = this.readI32();
  }
  return {fname: name, mtype: type, rseqid: seqid};
};

TBinaryProtocol.prototype.readMessageEnd = function() {
};

TBinaryProtocol.prototype.readStructBegin = function() {
  return {fname: ''};
};

TBinaryProtocol.prototype.readStructEnd = function() {
};

TBinaryProtocol.prototype.readFieldBegin = function() {
  var type = this.readByte();
  if (type == Type.STOP) {
    return {fname: null, ftype: type, fid: 0};
  }
  var id = this.readI16();
  return {fname: null, ftype: type, fid: id};
};

TBinaryProtocol.prototype.readFieldEnd = function() {
};

TBinaryProtocol.prototype.readMapBegin = function() {
  var ktype = this.readByte();
  var vtype = this.readByte();
  var size = this.readI32();
  return {ktype: ktype, vtype: vtype, size: size};
};

TBinaryProtocol.prototype.readMapEnd = function() {
};

TBinaryProtocol.prototype.readListBegin = function() {
  var etype = this.readByte();
  var size = this.readI32();
  return {etype: etype, size: size};
};

TBinaryProtocol.prototype.readListEnd = function() {
};

TBinaryProtocol.prototype.readSetBegin = function() {
  var etype = this.readByte();
  var size = this.readI32();
  return {etype: etype, size: size};
};

TBinaryProtocol.prototype.readSetEnd = function() {
};

TBinaryProtocol.prototype.readBool = function() {
  var b = this.readByte();
  if (b === 0) {
    return false;
  }
  return true;
};

TBinaryProtocol.prototype.readByte = function() {
  return this.trans.readByte();
};

TBinaryProtocol.prototype.readI16 = function() {
  return this.trans.readI16();
};

TBinaryProtocol.prototype.readI32 = function() {
  return this.trans.readI32();
};

TBinaryProtocol.prototype.readI64 = function() {
  var buff = this.trans.read(8);
  return new Int64(buff);
};

TBinaryProtocol.prototype.readDouble = function() {
  return this.trans.readDouble();
};

TBinaryProtocol.prototype.readBinary = function() {
  var len = this.readI32();
  if (len === 0) {
    return new Buffer(0);
  }

  if (len < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative binary size");
  }
  return this.trans.read(len);
};

TBinaryProtocol.prototype.readString = function() {
  var len = this.readI32();
  if (len === 0) {
    return "";
  }

  if (len < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative string size");
  }
  return this.trans.readString(len);
};

TBinaryProtocol.prototype.getTransport = function() {
  return this.trans;
};

TBinaryProtocol.prototype.skip = function(type) {
  switch (type) {
    case Type.BOOL:
      this.readBool();
      break;
    case Type.BYTE:
      this.readByte();
      break;
    case Type.I16:
      this.readI16();
      break;
    case Type.I32:
      this.readI32();
      break;
    case Type.I64:
      this.readI64();
      break;
    case Type.DOUBLE:
      this.readDouble();
      break;
    case Type.STRING:
      this.readString();
      break;
    case Type.STRUCT:
      this.readStructBegin();
      while (true) {
        var r = this.readFieldBegin();
        if (r.ftype === Type.STOP) {
          break;
        }
        this.skip(r.ftype);
        this.readFieldEnd();
      }
      this.readStructEnd();
      break;
    case Type.MAP:
      var mapBegin = this.readMapBegin();
      for (var i = 0; i < mapBegin.size; ++i) {
        this.skip(mapBegin.ktype);
        this.skip(mapBegin.vtype);
      }
      this.readMapEnd();
      break;
    case Type.SET:
      var setBegin = this.readSetBegin();
      for (var i2 = 0; i2 < setBegin.size; ++i2) {
        this.skip(setBegin.etype);
      }
      this.readSetEnd();
      break;
    case Type.LIST:
      var listBegin = this.readListBegin();
      for (var i3 = 0; i3 < listBegin.size; ++i3) {
        this.skip(listBegin.etype);
      }
      this.readListEnd();
      break;
    default:
      throw new  Error("Invalid type: " + type);
  }
};


/***/ }),

/***/ 9262:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
exports.Thrift = __webpack_require__(5406);

var wsConnection = __webpack_require__(5455);
exports.WSConnection = wsConnection.WSConnection;
exports.createWSConnection = wsConnection.createWSConnection;
exports.createWSClient = wsConnection.createWSClient;

var xhrConnection = __webpack_require__(4050);
exports.XHRConnection = xhrConnection.XHRConnection;
exports.createXHRConnection = xhrConnection.createXHRConnection;
exports.createXHRClient = xhrConnection.createXHRClient;


exports.Int64 = __webpack_require__(135);
exports.Q = __webpack_require__(8486);

var mpxProtocol = __webpack_require__(4184);
exports.Multiplexer = mpxProtocol.Multiplexer;

/*
 * Export transport and protocol so they can be used outside of a
 * cassandra/server context
 */
exports.TBufferedTransport = __webpack_require__(8869);
exports.TFramedTransport = __webpack_require__(7584);
exports.TWebSocketTransport = __webpack_require__(5764);

exports.Protocol = __webpack_require__(5086);
exports.TJSONProtocol = __webpack_require__(5086);
exports.TBinaryProtocol = __webpack_require__(4711);
exports.TCompactProtocol = __webpack_require__(9277);


/***/ }),

/***/ 8869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var binary = __webpack_require__(7533);
var InputBufferUnderrunError = __webpack_require__(3590);
var THeaderTransport = __webpack_require__(5190);

module.exports = TBufferedTransport;

function TBufferedTransport(buffer, callback) {
  this.defaultReadBufferSize = 1024;
  this.writeBufferSize = 512; // Soft Limit
  this.inBuf = new Buffer(this.defaultReadBufferSize);
  this.readCursor = 0;
  this.writeCursor = 0; // for input buffer
  this.outBuffers = [];
  this.outCount = 0;
  this.onFlush = callback;
};

TBufferedTransport.prototype = new THeaderTransport();

TBufferedTransport.prototype.reset = function() {
  this.inBuf = new Buffer(this.defaultReadBufferSize);
  this.readCursor = 0;
  this.writeCursor = 0;
  this.outBuffers = [];
  this.outCount = 0;
}

TBufferedTransport.receiver = function(callback, seqid) {
  var reader = new TBufferedTransport();

  return function(data) {
    if (reader.writeCursor + data.length > reader.inBuf.length) {
      var buf = new Buffer(reader.writeCursor + data.length);
      reader.inBuf.copy(buf, 0, 0, reader.writeCursor);
      reader.inBuf = buf;
    }
    data.copy(reader.inBuf, reader.writeCursor, 0);
    reader.writeCursor += data.length;

    callback(reader, seqid);
  };
};


TBufferedTransport.prototype.commitPosition = function(){
  var unreadSize = this.writeCursor - this.readCursor;
  var bufSize = (unreadSize * 2 > this.defaultReadBufferSize) ?
    unreadSize * 2 : this.defaultReadBufferSize;
  var buf = new Buffer(bufSize);
  if (unreadSize > 0) {
    this.inBuf.copy(buf, 0, this.readCursor, this.writeCursor);
  }
  this.readCursor = 0;
  this.writeCursor = unreadSize;
  this.inBuf = buf;
};

TBufferedTransport.prototype.rollbackPosition = function(){
  this.readCursor = 0;
}

  // TODO: Implement open/close support
TBufferedTransport.prototype.isOpen = function() {
  return true;
};

TBufferedTransport.prototype.open = function() {
};

TBufferedTransport.prototype.close = function() {
};

  // Set the seqid of the message in the client
  // So that callbacks can be found
TBufferedTransport.prototype.setCurrSeqId = function(seqid) {
  this._seqid = seqid;
};

TBufferedTransport.prototype.ensureAvailable = function(len) {
  if (this.readCursor + len > this.writeCursor) {
    throw new InputBufferUnderrunError();
  }
};

TBufferedTransport.prototype.read = function(len) {
  this.ensureAvailable(len);
  var buf = new Buffer(len);
  this.inBuf.copy(buf, 0, this.readCursor, this.readCursor + len);
  this.readCursor += len;
  return buf;
};

TBufferedTransport.prototype.readByte = function() {
  this.ensureAvailable(1);
  return binary.readByte(this.inBuf[this.readCursor++]);
};

TBufferedTransport.prototype.readI16 = function() {
  this.ensureAvailable(2);
  var i16 = binary.readI16(this.inBuf, this.readCursor);
  this.readCursor += 2;
  return i16;
};

TBufferedTransport.prototype.readI32 = function() {
  this.ensureAvailable(4);
  var i32 = binary.readI32(this.inBuf, this.readCursor);
  this.readCursor += 4;
  return i32;
};

TBufferedTransport.prototype.readDouble = function() {
  this.ensureAvailable(8);
  var d = binary.readDouble(this.inBuf, this.readCursor);
  this.readCursor += 8;
  return d;
};

TBufferedTransport.prototype.readString = function(len) {
  this.ensureAvailable(len);
  var str = this.inBuf.toString('utf8', this.readCursor, this.readCursor + len);
  this.readCursor += len;
  return str;
};

TBufferedTransport.prototype.borrow = function() {
  var obj = {buf: this.inBuf, readIndex: this.readCursor, writeIndex: this.writeCursor};
  return obj;
};

TBufferedTransport.prototype.consume = function(bytesConsumed) {
  this.readCursor += bytesConsumed;
};

TBufferedTransport.prototype.write = function(buf) {
  if (typeof(buf) === "string") {
    buf = new Buffer(buf, 'utf8');
  }
  this.outBuffers.push(buf);
  this.outCount += buf.length;
};

TBufferedTransport.prototype.flush = function() {
  // If the seqid of the callback is available pass it to the onFlush
  // Then remove the current seqid
  var seqid = this._seqid;
  this._seqid = null;

  if (this.outCount < 1) {
    return;
  }

  var msg = new Buffer(this.outCount),
      pos = 0;
  this.outBuffers.forEach(function(buf) {
    buf.copy(msg, pos, 0);
    pos += buf.length;
  });

  if (this.onFlush) {
    // Passing seqid through this call to get it to the connection
    this.onFlush(msg, seqid);
  }

  this.outBuffers = [];
  this.outCount = 0;
}


/***/ }),

/***/ 9277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var log = __webpack_require__(1291);
var Int64 = __webpack_require__(135);
var Thrift = __webpack_require__(5406);
var Type = Thrift.Type;

module.exports = TCompactProtocol;

var POW_8 = Math.pow(2, 8);
var POW_24 = Math.pow(2, 24);
var POW_32 = Math.pow(2, 32);
var POW_40 = Math.pow(2, 40);
var POW_48 = Math.pow(2, 48);
var POW_52 = Math.pow(2, 52);
var POW_1022 = Math.pow(2, 1022);

/**
 * Constructor Function for the Compact Protocol.
 * @constructor
 * @param {object} [trans] - The underlying transport to read/write.
 * @classdesc The Apache Thrift Protocol layer performs serialization
 *     of base types, the compact protocol serializes data in binary
 *     form with minimal space used for scalar values.
 */
function TCompactProtocol(trans) {
  this.trans = trans;
  this.lastField_ = [];
  this.lastFieldId_ = 0;
  this.string_limit_ = 0;
  this.string_buf_ = null;
  this.string_buf_size_ = 0;
  this.container_limit_ = 0;
  this.booleanField_ = {
    name: null,
    hasBoolValue: false
  };
  this.boolValue_ = {
    hasBoolValue: false,
    boolValue: false
  };
};


//
// Compact Protocol Constants
//

/**
  * Compact Protocol ID number.
  * @readonly
  * @const {number} PROTOCOL_ID
  */
TCompactProtocol.PROTOCOL_ID = -126;  //1000 0010

/**
  * Compact Protocol version number.
  * @readonly
  * @const {number} VERSION_N
  */
TCompactProtocol.VERSION_N = 1;

/**
  * Compact Protocol version mask for combining protocol version and message type in one byte.
  * @readonly
  * @const {number} VERSION_MASK
  */
TCompactProtocol.VERSION_MASK = 0x1f; //0001 1111

/**
  * Compact Protocol message type mask for combining protocol version and message type in one byte.
  * @readonly
  * @const {number} TYPE_MASK
  */
TCompactProtocol.TYPE_MASK = -32;     //1110 0000

/**
  * Compact Protocol message type bits for ensuring message type bit size.
  * @readonly
  * @const {number} TYPE_BITS
  */
TCompactProtocol.TYPE_BITS = 7; //0000 0111

/**
  * Compact Protocol message type shift amount for combining protocol version and message type in one byte.
  * @readonly
  * @const {number} TYPE_SHIFT_AMOUNT
  */
TCompactProtocol.TYPE_SHIFT_AMOUNT = 5;

/**
 * Compact Protocol type IDs used to keep type data within one nibble.
 * @readonly
 * @property {number}  CT_STOP          - End of a set of fields.
 * @property {number}  CT_BOOLEAN_TRUE  - Flag for Boolean field with true value (packed field and value).
 * @property {number}  CT_BOOLEAN_FALSE - Flag for Boolean field with false value (packed field and value).
 * @property {number}  CT_BYTE          - Signed 8 bit integer.
 * @property {number}  CT_I16           - Signed 16 bit integer.
 * @property {number}  CT_I32           - Signed 32 bit integer.
 * @property {number}  CT_I64           - Signed 64 bit integer (2^53 max in JavaScript).
 * @property {number}  CT_DOUBLE        - 64 bit IEEE 854 floating point.
 * @property {number}  CT_BINARY        - Array of bytes (used for strings also).
 * @property {number}  CT_LIST          - A collection type (unordered).
 * @property {number}  CT_SET           - A collection type (unordered and without repeated values).
 * @property {number}  CT_MAP           - A collection type (map/associative-array/dictionary).
 * @property {number}  CT_STRUCT        - A multifield type.
 */
TCompactProtocol.Types = {
  CT_STOP:           0x00,
  CT_BOOLEAN_TRUE:   0x01,
  CT_BOOLEAN_FALSE:  0x02,
  CT_BYTE:           0x03,
  CT_I16:            0x04,
  CT_I32:            0x05,
  CT_I64:            0x06,
  CT_DOUBLE:         0x07,
  CT_BINARY:         0x08,
  CT_LIST:           0x09,
  CT_SET:            0x0A,
  CT_MAP:            0x0B,
  CT_STRUCT:         0x0C
};

/**
 * Array mapping Compact type IDs to standard Thrift type IDs.
 * @readonly
 */
TCompactProtocol.TTypeToCType = [
  TCompactProtocol.Types.CT_STOP,         // T_STOP
  0,                                      // unused
  TCompactProtocol.Types.CT_BOOLEAN_TRUE, // T_BOOL
  TCompactProtocol.Types.CT_BYTE,         // T_BYTE
  TCompactProtocol.Types.CT_DOUBLE,       // T_DOUBLE
  0,                                      // unused
  TCompactProtocol.Types.CT_I16,          // T_I16
  0,                                      // unused
  TCompactProtocol.Types.CT_I32,          // T_I32
  0,                                      // unused
  TCompactProtocol.Types.CT_I64,          // T_I64
  TCompactProtocol.Types.CT_BINARY,       // T_STRING
  TCompactProtocol.Types.CT_STRUCT,       // T_STRUCT
  TCompactProtocol.Types.CT_MAP,          // T_MAP
  TCompactProtocol.Types.CT_SET,          // T_SET
  TCompactProtocol.Types.CT_LIST,         // T_LIST
];


//
// Compact Protocol Utilities
//

/**
 * Returns the underlying transport layer.
 * @return {object} The underlying transport layer.
 */TCompactProtocol.prototype.getTransport = function() {
  return this.trans;
};

/**
 * Lookup a Compact Protocol Type value for a given Thrift Type value.
 * N.B. Used only internally.
 * @param {number} ttype - Thrift type value
 * @returns {number} Compact protocol type value
 */
TCompactProtocol.prototype.getCompactType = function(ttype) {
  return TCompactProtocol.TTypeToCType[ttype];
};

/**
 * Lookup a Thrift Type value for a given Compact Protocol Type value.
 * N.B. Used only internally.
 * @param {number} type - Compact Protocol type value
 * @returns {number} Thrift Type value
 */
TCompactProtocol.prototype.getTType = function(type) {
  switch (type) {
    case Type.STOP:
      return Type.STOP;
    case TCompactProtocol.Types.CT_BOOLEAN_FALSE:
    case TCompactProtocol.Types.CT_BOOLEAN_TRUE:
      return Type.BOOL;
    case TCompactProtocol.Types.CT_BYTE:
      return Type.BYTE;
    case TCompactProtocol.Types.CT_I16:
      return Type.I16;
    case TCompactProtocol.Types.CT_I32:
      return Type.I32;
    case TCompactProtocol.Types.CT_I64:
      return Type.I64;
    case TCompactProtocol.Types.CT_DOUBLE:
      return Type.DOUBLE;
    case TCompactProtocol.Types.CT_BINARY:
      return Type.STRING;
    case TCompactProtocol.Types.CT_LIST:
      return Type.LIST;
    case TCompactProtocol.Types.CT_SET:
      return Type.SET;
    case TCompactProtocol.Types.CT_MAP:
      return Type.MAP;
    case TCompactProtocol.Types.CT_STRUCT:
      return Type.STRUCT;
    default:
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Unknown type: " + type);
  }
  return Type.STOP;
};


//
// Compact Protocol write operations
//

/**
 * Send any buffered bytes to the end point.
 */
TCompactProtocol.prototype.flush = function() {
  return this.trans.flush();
};

/**
 * Writes an RPC message header
 * @param {string} name - The method name for the message.
 * @param {number} type - The type of message (CALL, REPLY, EXCEPTION, ONEWAY).
 * @param {number} seqid - The call sequence number (if any).
 */
TCompactProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
  this.writeByte(TCompactProtocol.PROTOCOL_ID);
  this.writeByte((TCompactProtocol.VERSION_N & TCompactProtocol.VERSION_MASK) |
                     ((type << TCompactProtocol.TYPE_SHIFT_AMOUNT) & TCompactProtocol.TYPE_MASK));
  this.writeVarint32(seqid);
  this.writeString(name);

  // Record client seqid to find callback again
  if (this._seqid) {
    log.warning('SeqId already set', { 'name': name });
  } else {
    this._seqid = seqid;
    this.trans.setCurrSeqId(seqid);
  }
};

TCompactProtocol.prototype.writeMessageEnd = function() {
};

TCompactProtocol.prototype.writeStructBegin = function(name) {
  this.lastField_.push(this.lastFieldId_);
  this.lastFieldId_ = 0;
};

TCompactProtocol.prototype.writeStructEnd = function() {
  this.lastFieldId_ = this.lastField_.pop();
};

/**
 * Writes a struct field header
 * @param {string} name - The field name (not written with the compact protocol).
 * @param {number} type - The field data type (a normal Thrift field Type).
 * @param {number} id - The IDL field Id.
 */
TCompactProtocol.prototype.writeFieldBegin = function(name, type, id) {
  if (type != Type.BOOL) {
    return this.writeFieldBeginInternal(name, type, id, -1);
  }

  this.booleanField_.name = name;
  this.booleanField_.fieldType = type;
  this.booleanField_.fieldId = id;
};

TCompactProtocol.prototype.writeFieldEnd = function() {
};

TCompactProtocol.prototype.writeFieldStop = function() {
  this.writeByte(TCompactProtocol.Types.CT_STOP);
};

/**
 * Writes a map collection header
 * @param {number} keyType - The Thrift type of the map keys.
 * @param {number} valType - The Thrift type of the map values.
 * @param {number} size - The number of k/v pairs in the map.
 */
TCompactProtocol.prototype.writeMapBegin = function(keyType, valType, size) {
  if (size === 0) {
    this.writeByte(0);
  } else {
    this.writeVarint32(size);
    this.writeByte(this.getCompactType(keyType) << 4 | this.getCompactType(valType));
  }
};

TCompactProtocol.prototype.writeMapEnd = function() {
};

/**
 * Writes a list collection header
 * @param {number} elemType - The Thrift type of the list elements.
 * @param {number} size - The number of elements in the list.
 */
TCompactProtocol.prototype.writeListBegin = function(elemType, size) {
  this.writeCollectionBegin(elemType, size);
};

TCompactProtocol.prototype.writeListEnd = function() {
};

/**
 * Writes a set collection header
 * @param {number} elemType - The Thrift type of the set elements.
 * @param {number} size - The number of elements in the set.
 */
TCompactProtocol.prototype.writeSetBegin = function(elemType, size) {
  this.writeCollectionBegin(elemType, size);
};

TCompactProtocol.prototype.writeSetEnd = function() {
};

TCompactProtocol.prototype.writeBool = function(value) {
  if (this.booleanField_.name !== null) {
    // we haven't written the field header yet
    this.writeFieldBeginInternal(this.booleanField_.name,
                                 this.booleanField_.fieldType,
                                 this.booleanField_.fieldId,
                                 (value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE
                                          : TCompactProtocol.Types.CT_BOOLEAN_FALSE));
    this.booleanField_.name = null;
  } else {
    // we're not part of a field, so just write the value
    this.writeByte((value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE
                            : TCompactProtocol.Types.CT_BOOLEAN_FALSE));
  }
};

TCompactProtocol.prototype.writeByte = function(b) {
  this.trans.write(new Buffer([b]));
};

TCompactProtocol.prototype.writeI16 = function(i16) {
  this.writeVarint32(this.i32ToZigzag(i16));
};

TCompactProtocol.prototype.writeI32 = function(i32) {
  this.writeVarint32(this.i32ToZigzag(i32));
};

TCompactProtocol.prototype.writeI64 = function(i64) {
  this.writeVarint64(this.i64ToZigzag(i64));
};

// Little-endian, unlike TBinaryProtocol
TCompactProtocol.prototype.writeDouble = function(v) {
  var buff = new Buffer(8);
  var m, e, c;

  buff[7] = (v < 0 ? 0x80 : 0x00);

  v = Math.abs(v);
  if (v !== v) {
    // NaN, use QNaN IEEE format
    m = 2251799813685248;
    e = 2047;
  } else if (v === Infinity) {
    m = 0;
    e = 2047;
  } else {
    e = Math.floor(Math.log(v) / Math.LN2);
    c = Math.pow(2, -e);
    if (v * c < 1) {
      e--;
      c *= 2;
    }

    if (e + 1023 >= 2047)
    {
      // Overflow
      m = 0;
      e = 2047;
    }
    else if (e + 1023 >= 1)
    {
      // Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow
      m = (v*c-1) * POW_52;
      e += 1023;
    }
    else
    {
      // Denormalized - also catches the '0' case, somewhat by chance
      m = (v * POW_1022) * POW_52;
      e = 0;
    }
  }

  buff[6] = (e << 4) & 0xf0;
  buff[7] |= (e >> 4) & 0x7f;

  buff[0] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[1] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[2] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[3] = m & 0xff;
  m >>= 8;
  buff[4] = m & 0xff;
  m >>= 8;
  buff[5] = m & 0xff;
  m >>= 8;
  buff[6] |= m & 0x0f;

  this.trans.write(buff);
};

TCompactProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
  if (typeof arg === 'string') {
    this.writeVarint32(Buffer.byteLength(arg, encoding)) ;
    this.trans.write(new Buffer(arg, encoding));
  } else if (arg instanceof Buffer ||
             Object.prototype.toString.call(arg) == '[object Uint8Array]') {
    // Buffers in Node.js under Browserify may extend UInt8Array instead of
    // defining a new object. We detect them here so we can write them
    // correctly
    this.writeVarint32(arg.length);
    this.trans.write(arg);
  } else {
    throw new Error(name + ' called without a string/Buffer argument: ' + arg);
  }
};

TCompactProtocol.prototype.writeString = function(arg) {
  this.writeStringOrBinary('writeString', 'utf8', arg);
};

TCompactProtocol.prototype.writeBinary = function(arg) {
  this.writeStringOrBinary('writeBinary', 'binary', arg);
};


//
// Compact Protocol internal write methods
//

TCompactProtocol.prototype.writeFieldBeginInternal = function(name,
                                                              fieldType,
                                                              fieldId,
                                                              typeOverride) {
  //If there's a type override, use that.
  var typeToWrite = (typeOverride == -1 ? this.getCompactType(fieldType) : typeOverride);
  //Check if we can delta encode the field id
  if (fieldId > this.lastFieldId_ && fieldId - this.lastFieldId_ <= 15) {
    //Include the type delta with the field ID
    this.writeByte((fieldId - this.lastFieldId_) << 4 | typeToWrite);
  } else {
    //Write separate type and ID values
    this.writeByte(typeToWrite);
    this.writeI16(fieldId);
  }
  this.lastFieldId_ = fieldId;
};

TCompactProtocol.prototype.writeCollectionBegin = function(elemType, size) {
  if (size <= 14) {
    //Combine size and type in one byte if possible
    this.writeByte(size << 4 | this.getCompactType(elemType));
  } else {
    this.writeByte(0xf0 | this.getCompactType(elemType));
    this.writeVarint32(size);
  }
};

/**
 * Write an i32 as a varint. Results in 1-5 bytes on the wire.
 */
TCompactProtocol.prototype.writeVarint32 = function(n) {
  var buf = new Buffer(5);
  var wsize = 0;
  while (true) {
    if ((n & ~0x7F) === 0) {
      buf[wsize++] = n;
      break;
    } else {
      buf[wsize++] = ((n & 0x7F) | 0x80);
      n = n >>> 7;
    }
  }
  var wbuf = new Buffer(wsize);
  buf.copy(wbuf,0,0,wsize);
  this.trans.write(wbuf);
};

/**
 * Write an i64 as a varint. Results in 1-10 bytes on the wire.
 * N.B. node-int64 is always big endian
 */
TCompactProtocol.prototype.writeVarint64 = function(n) {
  if (typeof n === "number"){
    n = new Int64(n);
  }
  if (! (n instanceof Int64)) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Expected Int64 or Number, found: " + n);
  }

  var buf = new Buffer(10);
  var wsize = 0;
  var hi = n.buffer.readUInt32BE(0, true);
  var lo = n.buffer.readUInt32BE(4, true);
  var mask = 0;
  while (true) {
    if (((lo & ~0x7F) === 0) && (hi === 0)) {
      buf[wsize++] = lo;
      break;
    } else {
      buf[wsize++] = ((lo & 0x7F) | 0x80);
      mask = hi << 25;
      lo = lo >>> 7;
      hi = hi >>> 7;
      lo = lo | mask;
    }
  }
  var wbuf = new Buffer(wsize);
  buf.copy(wbuf,0,0,wsize);
  this.trans.write(wbuf);
};

/**
 * Convert l into a zigzag long. This allows negative numbers to be
 * represented compactly as a varint.
 */
TCompactProtocol.prototype.i64ToZigzag = function(l) {
  if (typeof l === 'string') {
    l = new Int64(parseInt(l, 10));
  } else if (typeof l === 'number') {
    l = new Int64(l);
  }
  if (! (l instanceof Int64)) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Expected Int64 or Number, found: " + l);
  }
  var hi = l.buffer.readUInt32BE(0, true);
  var lo = l.buffer.readUInt32BE(4, true);
  var sign = hi >>> 31;
  hi = ((hi << 1) | (lo >>> 31)) ^ ((!!sign) ? 0xFFFFFFFF : 0);
  lo = (lo << 1) ^ ((!!sign) ? 0xFFFFFFFF : 0);
  return new Int64(hi, lo);
};

/**
 * Convert n into a zigzag int. This allows negative numbers to be
 * represented compactly as a varint.
 */
TCompactProtocol.prototype.i32ToZigzag = function(n) {
  return (n << 1) ^ ((n & 0x80000000) ? 0xFFFFFFFF : 0);
};


//
// Compact Protocol read operations
//

TCompactProtocol.prototype.readMessageBegin = function() {
  //Read protocol ID
  var protocolId = this.trans.readByte();
  if (protocolId != TCompactProtocol.PROTOCOL_ID) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad protocol identifier " + protocolId);
  }

  //Read Version and Type
  var versionAndType = this.trans.readByte();
  var version = (versionAndType & TCompactProtocol.VERSION_MASK);
  if (version != TCompactProtocol.VERSION_N) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad protocol version " + version);
  }
  var type = ((versionAndType >> TCompactProtocol.TYPE_SHIFT_AMOUNT) & TCompactProtocol.TYPE_BITS);

  //Read SeqId
  var seqid = this.readVarint32();

  //Read name
  var name = this.readString();

  return {fname: name, mtype: type, rseqid: seqid};
};

TCompactProtocol.prototype.readMessageEnd = function() {
};

TCompactProtocol.prototype.readStructBegin = function() {
  this.lastField_.push(this.lastFieldId_);
  this.lastFieldId_ = 0;
  return {fname: ''};
};

TCompactProtocol.prototype.readStructEnd = function() {
  this.lastFieldId_ = this.lastField_.pop();
};

TCompactProtocol.prototype.readFieldBegin = function() {
  var fieldId = 0;
  var b = this.trans.readByte(b);
  var type = (b & 0x0f);

  if (type == TCompactProtocol.Types.CT_STOP) {
    return {fname: null, ftype: Thrift.Type.STOP, fid: 0};
  }

  //Mask off the 4 MSB of the type header to check for field id delta.
  var modifier = ((b & 0x000000f0) >>> 4);
  if (modifier === 0) {
    //If not a delta read the field id.
    fieldId = this.readI16();
  } else {
    //Recover the field id from the delta
    fieldId = (this.lastFieldId_ + modifier);
  }
  var fieldType = this.getTType(type);

  //Boolean are encoded with the type
  if (type == TCompactProtocol.Types.CT_BOOLEAN_TRUE ||
      type == TCompactProtocol.Types.CT_BOOLEAN_FALSE) {
    this.boolValue_.hasBoolValue = true;
    this.boolValue_.boolValue =
      (type == TCompactProtocol.Types.CT_BOOLEAN_TRUE ? true : false);
  }

  //Save the new field for the next delta computation.
  this.lastFieldId_ = fieldId;
  return {fname: null, ftype: fieldType, fid: fieldId};
};

TCompactProtocol.prototype.readFieldEnd = function() {
};

TCompactProtocol.prototype.readMapBegin = function() {
  var msize = this.readVarint32();
  if (msize < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative map size");
  }

  var kvType = 0;
  if (msize !== 0) {
    kvType = this.trans.readByte();
  }

  var keyType = this.getTType((kvType & 0xf0) >>> 4);
  var valType = this.getTType(kvType & 0xf);
  return {ktype: keyType, vtype: valType, size: msize};
};

TCompactProtocol.prototype.readMapEnd = function() {
};

TCompactProtocol.prototype.readListBegin = function() {
  var size_and_type = this.trans.readByte();

  var lsize = (size_and_type >>> 4) & 0x0000000f;
  if (lsize == 15) {
    lsize = this.readVarint32();
  }

  if (lsize < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative list size");
  }

  var elemType = this.getTType(size_and_type & 0x0000000f);

  return {etype: elemType, size: lsize};
};

TCompactProtocol.prototype.readListEnd = function() {
};

TCompactProtocol.prototype.readSetBegin = function() {
  return this.readListBegin();
};

TCompactProtocol.prototype.readSetEnd = function() {
};

TCompactProtocol.prototype.readBool = function() {
  var value = false;
  var rsize = 0;
  if (this.boolValue_.hasBoolValue === true) {
    value = this.boolValue_.boolValue;
    this.boolValue_.hasBoolValue = false;
  } else {
    var res = this.trans.readByte();
    rsize = res.rsize;
    value = (res.value == TCompactProtocol.Types.CT_BOOLEAN_TRUE);
  }
  return value;
};

TCompactProtocol.prototype.readByte = function() {
  return this.trans.readByte();
};

TCompactProtocol.prototype.readI16 = function() {
  return this.readI32();
};

TCompactProtocol.prototype.readI32 = function() {
  return this.zigzagToI32(this.readVarint32());
};

TCompactProtocol.prototype.readI64 = function() {
  return this.zigzagToI64(this.readVarint64());
};

// Little-endian, unlike TBinaryProtocol
TCompactProtocol.prototype.readDouble = function() {
  var buff = this.trans.read(8);
  var off = 0;

  var signed = buff[off + 7] & 0x80;
  var e = (buff[off+6] & 0xF0) >> 4;
  e += (buff[off+7] & 0x7F) << 4;

  var m = buff[off];
  m += buff[off+1] << 8;
  m += buff[off+2] << 16;
  m += buff[off+3] * POW_24;
  m += buff[off+4] * POW_32;
  m += buff[off+5] * POW_40;
  m += (buff[off+6] & 0x0F) * POW_48;

  switch (e) {
    case 0:
      e = -1022;
      break;
    case 2047:
      return m ? NaN : (signed ? -Infinity : Infinity);
    default:
      m += POW_52;
      e -= 1023;
  }

  if (signed) {
    m *= -1;
  }

  return m * Math.pow(2, e - 52);
};

TCompactProtocol.prototype.readBinary = function() {
  var size = this.readVarint32();
  if (size === 0) {
    return new Buffer(0);
  }

  if (size < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative binary size");
  }
  return this.trans.read(size);
};

TCompactProtocol.prototype.readString = function() {
  var size = this.readVarint32();
  // Catch empty string case
  if (size === 0) {
    return "";
  }

  // Catch error cases
  if (size < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative string size");
  }
  return this.trans.readString(size);
};


//
// Compact Protocol internal read operations
//

/**
 * Read an i32 from the wire as a varint. The MSB of each byte is set
 * if there is another byte to follow. This can read up to 5 bytes.
 */
TCompactProtocol.prototype.readVarint32 = function() {
  return this.readVarint64().toNumber();
};

/**
 * Read an i64 from the wire as a proper varint. The MSB of each byte is set
 * if there is another byte to follow. This can read up to 10 bytes.
 */
TCompactProtocol.prototype.readVarint64 = function() {
  var rsize = 0;
  var lo = 0;
  var hi = 0;
  var shift = 0;
  while (true) {
    var b = this.trans.readByte();
    rsize ++;
    if (shift <= 25) {
      lo = lo | ((b & 0x7f) << shift);
    } else if (25 < shift && shift < 32) {
      lo = lo | ((b & 0x7f) << shift);
      hi = hi | ((b & 0x7f) >>> (32-shift));
    } else {
      hi = hi | ((b & 0x7f) << (shift-32));
    }
    shift += 7;
    if (!(b & 0x80)) {
      break;
    }
    if (rsize >= 10) {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Variable-length int over 10 bytes.");
    }
  }
  return new Int64(hi, lo);
};

/**
 * Convert from zigzag int to int.
 */
TCompactProtocol.prototype.zigzagToI32 = function(n) {
  return (n >>> 1) ^ (-1 * (n & 1));
};

/**
 * Convert from zigzag long to long.
 */
TCompactProtocol.prototype.zigzagToI64 = function(n) {
  var hi = n.buffer.readUInt32BE(0, true);
  var lo = n.buffer.readUInt32BE(4, true);

  var neg = new Int64(hi & 0, lo & 1);
  neg._2scomp();
  var hi_neg = neg.buffer.readUInt32BE(0, true);
  var lo_neg = neg.buffer.readUInt32BE(4, true);

  var hi_lo = (hi << 31);
  hi = (hi >>> 1) ^ (hi_neg);
  lo = ((lo >>> 1) | hi_lo) ^ (lo_neg);
  return new Int64(hi, lo);
};

TCompactProtocol.prototype.skip = function(type) {
  switch (type) {
    case Type.BOOL:
      this.readBool();
      break;
    case Type.BYTE:
      this.readByte();
      break;
    case Type.I16:
      this.readI16();
      break;
    case Type.I32:
      this.readI32();
      break;
    case Type.I64:
      this.readI64();
      break;
    case Type.DOUBLE:
      this.readDouble();
      break;
    case Type.STRING:
      this.readString();
      break;
    case Type.STRUCT:
      this.readStructBegin();
      while (true) {
        var r = this.readFieldBegin();
        if (r.ftype === Type.STOP) {
          break;
        }
        this.skip(r.ftype);
        this.readFieldEnd();
      }
      this.readStructEnd();
      break;
    case Type.MAP:
      var mapBegin = this.readMapBegin();
      for (var i = 0; i < mapBegin.size; ++i) {
        this.skip(mapBegin.ktype);
        this.skip(mapBegin.vtype);
      }
      this.readMapEnd();
      break;
    case Type.SET:
      var setBegin = this.readSetBegin();
      for (var i2 = 0; i2 < setBegin.size; ++i2) {
        this.skip(setBegin.etype);
      }
      this.readSetEnd();
      break;
    case Type.LIST:
      var listBegin = this.readListBegin();
      for (var i3 = 0; i3 < listBegin.size; ++i3) {
        this.skip(listBegin.etype);
      }
      this.readListEnd();
      break;
    default:
      throw new  Error("Invalid type: " + type);
  }
};


/***/ }),

/***/ 6243:
/***/ ((module) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

module.exports = createClient;

/**
 * Creates a new client object for the specified Thrift service.
 * @param {object} ServiceClient - The module containing the generated service client
 * @param {Connection} Connection - The connection to use.
 * @returns {object} The client object.
 */
function createClient(ServiceClient, connection) {
  // TODO validate required options and throw otherwise
  if (ServiceClient.Client) {
    ServiceClient = ServiceClient.Client;
  }
  // TODO detangle these initialization calls
  // creating "client" requires
  //   - new service client instance
  //
  // New service client instance requires
  //   - new transport instance
  //   - protocol class reference
  //
  // New transport instance requires
  //   - Buffer to use (or none)
  //   - Callback to call on flush

  // Wrap the write method
  var writeCb = function(buf, seqid) {
    connection.write(buf, seqid);
  };
  var transport = new connection.transport(undefined, writeCb);
  var client = new ServiceClient(transport, connection.protocol);
  transport.client = client;
  connection.client = client;
  return client;
};


/***/ }),

/***/ 7584:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var binary = __webpack_require__(7533);
var InputBufferUnderrunError = __webpack_require__(3590);
var THeaderTransport = __webpack_require__(5190);

module.exports = TFramedTransport;

function TFramedTransport(buffer, callback) {
  this.inBuf = buffer || new Buffer(0);
  this.outBuffers = [];
  this.outCount = 0;
  this.readPos = 0;
  this.onFlush = callback;
};

TFramedTransport.prototype = new THeaderTransport();

TFramedTransport.receiver = function(callback, seqid) {
  var residual = null;

  return function(data) {
    // Prepend any residual data from our previous read
    if (residual) {
      data = Buffer.concat([residual, data]);
      residual = null;
    }

    // framed transport
    while (data.length) {
      if (data.length < 4) {
        // Not enough bytes to continue, save and resume on next packet
        residual = data;
        return;
      }
      var frameSize = binary.readI32(data, 0);
      if (data.length < 4 + frameSize) {
        // Not enough bytes to continue, save and resume on next packet
        residual = data;
        return;
      }

      var frame = data.slice(4, 4 + frameSize);
      residual = data.slice(4 + frameSize);

      callback(new TFramedTransport(frame), seqid);

      data = residual;
      residual = null;
    }
  };
};

TFramedTransport.prototype.commitPosition = function(){},
TFramedTransport.prototype.rollbackPosition = function(){},

  // TODO: Implement open/close support
TFramedTransport.prototype.isOpen = function() {
  return true;
};
TFramedTransport.prototype.open = function() {};
TFramedTransport.prototype.close =  function() {};

  // Set the seqid of the message in the client
  // So that callbacks can be found
TFramedTransport.prototype.setCurrSeqId = function(seqid) {
  this._seqid = seqid;
};

TFramedTransport.prototype.ensureAvailable = function(len) {
  if (this.readPos + len > this.inBuf.length) {
    throw new InputBufferUnderrunError();
  }
};

TFramedTransport.prototype.read = function(len) { // this function will be used for each frames.
  this.ensureAvailable(len);
  var end = this.readPos + len;

  if (this.inBuf.length < end) {
    throw new Error('read(' + len + ') failed - not enough data');
  }

  var buf = this.inBuf.slice(this.readPos, end);
  this.readPos = end;
  return buf;
};

TFramedTransport.prototype.readByte = function() {
  this.ensureAvailable(1);
  return binary.readByte(this.inBuf[this.readPos++]);
};

TFramedTransport.prototype.readI16 = function() {
  this.ensureAvailable(2);
  var i16 = binary.readI16(this.inBuf, this.readPos);
  this.readPos += 2;
  return i16;
};

TFramedTransport.prototype.readI32 = function() {
  this.ensureAvailable(4);
  var i32 = binary.readI32(this.inBuf, this.readPos);
  this.readPos += 4;
  return i32;
};

TFramedTransport.prototype.readDouble = function() {
  this.ensureAvailable(8);
  var d = binary.readDouble(this.inBuf, this.readPos);
  this.readPos += 8;
  return d;
};

TFramedTransport.prototype.readString = function(len) {
  this.ensureAvailable(len);
  var str = this.inBuf.toString('utf8', this.readPos, this.readPos + len);
  this.readPos += len;
  return str;
};

TFramedTransport.prototype.borrow = function() {
  return {
    buf: this.inBuf,
    readIndex: this.readPos,
    writeIndex: this.inBuf.length
  };
};

TFramedTransport.prototype.consume = function(bytesConsumed) {
  this.readPos += bytesConsumed;
};

TFramedTransport.prototype.write = function(buf, encoding) {
  if (typeof(buf) === "string") {
    buf = new Buffer(buf, encoding || 'utf8');
  }
  this.outBuffers.push(buf);
  this.outCount += buf.length;
};

TFramedTransport.prototype.flush = function() {
  // If the seqid of the callback is available pass it to the onFlush
  // Then remove the current seqid
  var seqid = this._seqid;
  this._seqid = null;

  var out = new Buffer(this.outCount),
      pos = 0;
  this.outBuffers.forEach(function(buf) {
    buf.copy(out, pos, 0);
    pos += buf.length;
  });

  if (this.onFlush) {
    // TODO: optimize this better, allocate one buffer instead of both:
    var msg = new Buffer(out.length + 4);
    binary.writeI32(msg, out.length);
    out.copy(msg, 4, 0, out.length);
    if (this.onFlush) {
      // Passing seqid through this call to get it to the connection
      this.onFlush(msg, seqid);
    }
  }

  this.outBuffers = [];
  this.outCount = 0;
};


/***/ }),

/***/ 5190:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var util = __webpack_require__(9539);
var TCompactProtocol = __webpack_require__(9277);
var TBinaryProtocol = __webpack_require__(4711);
var InputBufferUnderrunError = __webpack_require__(3590);

function THeaderTransportError(message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = this.constructor.name;
  this.message = message;
}

util.inherits(THeaderTransportError, Error);

module.exports = THeaderTransport;

// from HeaderFormat.md
var COMPACT_PROTOCOL_OFFSET = 0;
var COMPACT_PROTOCOL_VERSION_OFFSET = 1;
var FRAME_SIZE_OFFSET = 0;
var HEADER_MAGIC_OFFSET = 32 / 8;
var FLAGS_OFFSET = 48 / 8;
var SEQID_OFFSET = 64 / 8;
var HEADER_SIZE_OFFSET = 96 / 8;
var HEADER_START_OFFSET = 112 / 8;

var HEADER_MAGIC = 0x0FFF;

var TINFO_HEADER_KEY_VALUE_TYPE = 0x01;
var MAX_FRAME_SIZE = 0x3FFFFFFF;

 // A helper class for reading/writing varints. Uses
 // TCompactProtocol under the hood
function VarintHelper(readBuffer) {
  var TBufferedTransport = __webpack_require__(8869);
  this.outputBuffer = null;
  var _this = this;
  this.transport = new TBufferedTransport(null, function(output) {
    _this.outputBuffer = output;
  });

  this.transport.inBuf = readBuffer || Buffer.alloc(0);
  this.transport.writeCursor = this.transport.inBuf.length;
  this.protocol = new TCompactProtocol(this.transport);
};

VarintHelper.prototype.readVarint32 = function() {
  return this.protocol.readVarint32();
};

VarintHelper.prototype.writeVarint32 = function(i) {
  this.protocol.writeVarint32(i);
};

VarintHelper.prototype.readString = function() {
  return this.protocol.readString();
};

VarintHelper.prototype.writeString = function(str) {
  this.protocol.writeString(str);
}

VarintHelper.prototype.getOutCount = function() {
  return this.transport.outCount;
};

VarintHelper.prototype.write = function(str) {
  this.transport.write(str);
};

VarintHelper.prototype.toBuffer = function() {
  this.transport.flush();
  return this.outputBuffer;
};

// from lib/cpp/src/thrift/protocol/TProtocolTypes.h
THeaderTransport.SubprotocolId = {
  BINARY: 0,
  JSON: 1,
  COMPACT: 2,
};

/**
  An abstract transport used as a prototype for other transports
  to enable reading/writing theaders. This should NOT be used as a standalone transport
  The methods in this transport are called by THeaderProtocol, which will call readHeaders/writeHeaders
  in the read/writeMessageBegin methods and parse/write headers to/from a request
  prior to reading/writing.

  The reason this is not a standalone transport type is because different transport types
  have their own individual static receiver methods that are called prior to instantiation.
  There doesn't seem to be a way for THeaderTransport to know which receiver method to use
  without reworking the server API.

  For reading headers from a request, the parsed headers can be retrieved via
  getReadHeader. Similarly, you can set headers to be written on the client via
  setWriteHeader.
 */
function THeaderTransport() {
  this.maxFrameSize = MAX_FRAME_SIZE;
  this.protocolId = THeaderTransport.SubprotocolId.BINARY;
  this.rheaders = {};
  this.wheaders = {};
  this.inBuf = Buffer.alloc(0);
  this.outCount = 0;
  this.flags = null;
  this.seqid = 0;
  this.shouldWriteHeaders = true;
};

var validateHeaders = function(key, value) {
  if (typeof key !== 'string' || typeof value !== 'string') {
    throw new THeaderTransportError('Header key and values must be strings');
  }
};

var validateProtocolId = function(protocolId) {
  var protocols = Object.keys(THeaderTransport.SubprotocolId);
  for (var i = 0; i < protocols.length; i++) {
    if (protocolId === THeaderTransport.SubprotocolId[protocols[i]]) return true;
  }

  throw new Error(protocolId + ' is not a valid protocol id');
};

THeaderTransport.prototype.setSeqId = function(seqid) {
  this.seqid = seqid;
};

THeaderTransport.prototype.getSeqId = function(seqid) {
  return this.seqid;
};

THeaderTransport.prototype.setFlags = function(flags) {
  this.flags = flags;
};

THeaderTransport.prototype.getReadHeaders = function() {
  return this.rheaders;
};

THeaderTransport.prototype.setReadHeader = function(key, value) {
  validateHeaders(key, value);
  this.rheaders[key] = value;
};

THeaderTransport.prototype.clearReadHeaders = function() {
  this.rheaders = {};
};

THeaderTransport.prototype.getWriteHeaders = function() {
  return this.wheaders;
};

THeaderTransport.prototype.setWriteHeader = function(key, value) {
  validateHeaders(key, value);
  this.wheaders[key] = value;
};

THeaderTransport.prototype.clearWriteHeaders = function() {
  this.wheaders = {};
};

THeaderTransport.prototype.setMaxFrameSize = function(frameSize) {
  this.maxFrameSize = frameSize;
};

THeaderTransport.prototype.setProtocolId = function(protocolId) {
  validateProtocolId(protocolId);
  this.protocolId = protocolId;
};

THeaderTransport.prototype.getProtocolId = function() {
  return this.protocolId;
};

var isUnframedBinary = function(readBuffer) {
  var version = readBuffer.readInt32BE();
  return (version & TBinaryProtocol.VERSION_MASK) === TBinaryProtocol.VERSION_1;
}

var isUnframedCompact = function(readBuffer) {
  var protocolId = readBuffer.readInt8(COMPACT_PROTOCOL_OFFSET);
  var version = readBuffer.readInt8(COMPACT_PROTOCOL_VERSION_OFFSET);
  return protocolId === TCompactProtocol.PROTOCOL_ID &&
    (version & TCompactProtocol.VERSION_MASK) === TCompactProtocol.VERSION_N;
}

THeaderTransport.prototype.readHeaders = function() {
  var readBuffer = this.inBuf;

  var isUnframed = false;
  if (isUnframedBinary(readBuffer)) {
    this.setProtocolId(THeaderTransport.SubprotocolId.BINARY);
    isUnframed = true;
  }

  if (isUnframedCompact(readBuffer)) {
    this.setProtocolId(THeaderTransport.SubprotocolId.COMPACT);
    isUnframed = true;
  }

  if (isUnframed) {
    this.shouldWriteHeaders = false;
    return;
  }

  var frameSize = readBuffer.readInt32BE(FRAME_SIZE_OFFSET);
  if (frameSize > this.maxFrameSize) {
    throw new THeaderTransportError('Frame exceeds maximum frame size');
  }

  var headerMagic = readBuffer.readInt16BE(HEADER_MAGIC_OFFSET);
  this.shouldWriteHeaders = headerMagic === HEADER_MAGIC;
  if (!this.shouldWriteHeaders) {
    return;
  }

  this.setFlags(readBuffer.readInt16BE(FLAGS_OFFSET));
  this.setSeqId(readBuffer.readInt32BE(SEQID_OFFSET));
  var headerSize = readBuffer.readInt16BE(HEADER_SIZE_OFFSET) * 4;
  var endOfHeaders = HEADER_START_OFFSET + headerSize;
  if (endOfHeaders > readBuffer.length) {
    throw new THeaderTransportError('Header size is greater than frame size');
  }

  var headerBuffer = Buffer.alloc(headerSize);
  readBuffer.copy(headerBuffer, 0, HEADER_START_OFFSET, endOfHeaders);

  var varintHelper = new VarintHelper(headerBuffer);
  this.setProtocolId(varintHelper.readVarint32());
  var transformCount = varintHelper.readVarint32();
  if (transformCount > 0) {
    throw new THeaderTransportError('Transforms are not yet supported');
  }

  while (true) {
    try {
      var headerType = varintHelper.readVarint32();
      if (headerType !== TINFO_HEADER_KEY_VALUE_TYPE) {
        break;
      }

      var numberOfHeaders = varintHelper.readVarint32();
      for (var i = 0; i < numberOfHeaders; i++) {
        var key = varintHelper.readString();
        var value = varintHelper.readString();
        this.setReadHeader(key, value);
      }
    } catch (e) {
      if (e instanceof InputBufferUnderrunError) {
        break;
      }
      throw e;
    }
  }

  // moves the read cursor past the headers
  this.read(endOfHeaders);
  return this.getReadHeaders();
};

THeaderTransport.prototype.writeHeaders = function() {
  // only write headers on the server if the client contained headers
  if (!this.shouldWriteHeaders) {
    return;
  }
  var headers = this.getWriteHeaders();

  var varintWriter = new VarintHelper();
  varintWriter.writeVarint32(this.protocolId);
  varintWriter.writeVarint32(0); // transforms not supported

  // writing info header key values
  var headerKeys = Object.keys(headers);
  if (headerKeys.length > 0) {
    varintWriter.writeVarint32(TINFO_HEADER_KEY_VALUE_TYPE);
    varintWriter.writeVarint32(headerKeys.length);
    for (var i = 0; i < headerKeys.length; i++) {
      var key = headerKeys[i];
      var value = headers[key];

      varintWriter.writeString(key);
      varintWriter.writeString(value);
    }
  }
 var headerSizeWithoutPadding = varintWriter.getOutCount();
  var paddingNeeded = (4 - (headerSizeWithoutPadding % 4)) % 4;

  var headerSize = Buffer.alloc(2);
  headerSize.writeInt16BE(Math.floor((headerSizeWithoutPadding + paddingNeeded) / 4));

  var paddingBuffer = Buffer.alloc(paddingNeeded);
  paddingBuffer.fill(0x00);
  varintWriter.write(paddingBuffer);
  var headerContentBuffer = varintWriter.toBuffer();
  var frameSize = Buffer.alloc(4);
  frameSize.writeInt32BE(10 + this.outCount + headerContentBuffer.length);
  var headerMagic = Buffer.alloc(2);
  headerMagic.writeInt16BE(HEADER_MAGIC);

  // flags are not yet supported, so write a zero
  var flags = Buffer.alloc(2);
  flags.writeInt16BE(0);

  var seqid = Buffer.alloc(4);
  seqid.writeInt32BE(this.getSeqId());

  var headerBuffer = Buffer.concat([
    frameSize,
    headerMagic,
    flags,
    seqid,
    headerSize,
    headerContentBuffer,
  ]);

  this.outBuffers.unshift(headerBuffer);
  this.outCount += headerBuffer.length;
};


/***/ }),

/***/ 3590:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(9539);

module.exports = InputBufferUnderrunError;

function InputBufferUnderrunError(message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = this.constructor.name;
  this.message = message;
};

util.inherits(InputBufferUnderrunError, Error);


/***/ }),

/***/ 5197:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Int64 = __webpack_require__(135);

var Int64Util = module.exports = {};

var POW2_24 = Math.pow(2, 24);
var POW2_31 = Math.pow(2, 31);
var POW2_32 = Math.pow(2, 32);
var POW10_11 = Math.pow(10, 11);

Int64Util.toDecimalString = function(i64) {
  var b = i64.buffer;
  var o = i64.offset;
  if ((!b[o] && !(b[o + 1] & 0xe0)) ||
      (!~b[o] && !~(b[o + 1] & 0xe0))) {
    // The magnitude is small enough.
    return i64.toString();
  } else {
    var negative = b[o] & 0x80;
    if (negative) {
      // 2's complement
      var incremented = false;
      var buffer = new Buffer(8);
      for (var i = 7; i >= 0; --i) {
        buffer[i] = (~b[o + i] + (incremented ? 0 : 1)) & 0xff;
        incremented |= b[o + i];
      }
      b = buffer;
    }
    var high2 = b[o + 1] + (b[o] << 8);
    // Lesser 11 digits with exceeding values but is under 53 bits capacity.
    var low = b[o + 7] + (b[o + 6] << 8) + (b[o + 5] << 16)
        + b[o + 4] * POW2_24  // Bit shift renders 32th bit as sign, so use multiplication
        + (b[o + 3] + (b[o + 2] << 8)) * POW2_32 + high2 * 74976710656;  // The literal is 2^48 % 10^11
    // 12th digit and greater.
    var high = Math.floor(low / POW10_11) + high2 * 2814;  // The literal is 2^48 / 10^11
    // Make it exactly 11 with leading zeros.
    low = ('00000000000' + String(low % POW10_11)).slice(-11);
    return (negative ? '-' : '') + String(high) + low;
  }
};

Int64Util.fromDecimalString = function(text) {
  var negative = text.charAt(0) === '-';
  if (text.length < (negative ? 17 : 16)) {
    // The magnitude is smaller than 2^53.
    return new Int64(+text);
  } else if (text.length > (negative ? 20 : 19)) {
    throw new RangeError('Too many digits for Int64: ' + text);
  } else {
    // Most significant (up to 5) digits
    var high5 = +text.slice(negative ? 1 : 0, -15);
    var low = +text.slice(-15) + high5 * 2764472320;  // The literal is 10^15 % 2^32
    var high = Math.floor(low / POW2_32) + high5 * 232830;  // The literal is 10^15 / 2^&32
    low = low % POW2_32;
    if (high >= POW2_31 &&
        !(negative && high == POW2_31 && low == 0)  // Allow minimum Int64
       ) {
      throw new RangeError('The magnitude is too large for Int64.');
    }
    if (negative) {
      // 2's complement
      high = ~high;
      if (low === 0) {
        high = (high + 1) & 0xffffffff;
      } else {
        low = ~low + 1;
      }
      high = 0x80000000 | high;
    }
    return new Int64(high, low);
  }
};


/***/ }),

/***/ 6502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Imported from Douglas Crockford's reference implementation with minimum modification
 * to handle Int64.
 *
 * https://github.com/douglascrockford/JSON-js/blob/c98948ae1944a28e2e8ebc3717894e580aeaaa05/json_parse.js
 *
 * Original license header:
 *
 * json_parse.js
 * 2015-05-02
 * Public Domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */


/*jslint for */

/*property
    at, b, call, charAt, f, fromCharCode, hasOwnProperty, message, n, name,
    prototype, push, r, t, text
*/

var Int64 = __webpack_require__(135);
var Int64Util = __webpack_require__(5197);

var json_parse = module.exports = (function () {
    "use strict";

// This is a function that can parse a JSON text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,     // The index of the current character
        ch,     // The current character
        escapee = {
            '"': '"',
            '\\': '\\',
            '/': '/',
            b: '\b',
            f: '\f',
            n: '\n',
            r: '\r',
            t: '\t'
        },
        text,

        error = function (m) {

// Call error when something is wrong.

            throw new SyntaxError(m);
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected '" + c + "' instead of '" + ch + "'");
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at += 1;
            return ch;
        },

        number = function () {

// Parse a number value.

            var number,
                string = '';

            if (ch === '-') {
                string = '-';
                next('-');
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
            if (ch === '.') {
                string += '.';
                while (next() && ch >= '0' && ch <= '9') {
                    string += ch;
                }
            }
            if (ch === 'e' || ch === 'E') {
                string += ch;
                next();
                if (ch === '-' || ch === '+') {
                    string += ch;
                    next();
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
            }
            number = +string;
            if (!isFinite(number)) {
                error("Bad number");
            } else if (number >= Int64.MAX_INT || number <= Int64.MIN_INT) {
                // Return raw string for further process in TJSONProtocol
                return string;
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                uffff;

// When parsing for string values, we must look for " and \ characters.

            if (ch === '"') {
                while (next()) {
                    if (ch === '"') {
                        next();
                        return string;
                    }
                    if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        white = function () {

// Skip whitespace.

            while (ch && ch <= ' ') {
                next();
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            }
            error("Unexpected '" + ch + "'");
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                if (ch === ']') {
                    next(']');
                    return array;   // empty array
                }
                while (ch) {
                    array.push(value());
                    white();
                    if (ch === ']') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                if (ch === '}') {
                    next('}');
                    return object;   // empty object
                }
                while (ch) {
                    key = string();
                    white();
                    next(':');
                    if (Object.hasOwnProperty.call(object, key)) {
                        error('Duplicate key "' + key + '"');
                    }
                    object[key] = value();
                    white();
                    if (ch === '}') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
            return string();
        case '-':
            return number();
        default:
            return ch >= '0' && ch <= '9'
                ? number()
                : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source) {
        var result;

        text = source;
        at = 0;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

        return result;
    };
}());


/***/ }),

/***/ 5086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Int64 = __webpack_require__(135);
var Thrift = __webpack_require__(5406);
var Type = Thrift.Type;
var util = __webpack_require__(9539);

var Int64Util = __webpack_require__(5197);
var json_parse = __webpack_require__(6502);

var InputBufferUnderrunError = __webpack_require__(3590);

module.exports = TJSONProtocol;

/**
 * Initializes a Thrift JSON protocol instance.
 * @constructor
 * @param {Thrift.Transport} trans - The transport to serialize to/from.
 * @classdesc Apache Thrift Protocols perform serialization which enables cross
 * language RPC. The Protocol type is the JavaScript browser implementation
 * of the Apache Thrift TJSONProtocol.
 * @example
 *     var protocol  = new Thrift.Protocol(transport);
 */
function TJSONProtocol(trans) {
  this.tstack = [];
  this.tpos = [];
  this.trans = trans;
};

/**
 * Thrift IDL type Id to string mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
TJSONProtocol.Type = {};
TJSONProtocol.Type[Type.BOOL] = '"tf"';
TJSONProtocol.Type[Type.BYTE] = '"i8"';
TJSONProtocol.Type[Type.I16] = '"i16"';
TJSONProtocol.Type[Type.I32] = '"i32"';
TJSONProtocol.Type[Type.I64] = '"i64"';
TJSONProtocol.Type[Type.DOUBLE] = '"dbl"';
TJSONProtocol.Type[Type.STRUCT] = '"rec"';
TJSONProtocol.Type[Type.STRING] = '"str"';
TJSONProtocol.Type[Type.MAP] = '"map"';
TJSONProtocol.Type[Type.LIST] = '"lst"';
TJSONProtocol.Type[Type.SET] = '"set"';

/**
 * Thrift IDL type string to Id mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
TJSONProtocol.RType = {};
TJSONProtocol.RType.tf = Type.BOOL;
TJSONProtocol.RType.i8 = Type.BYTE;
TJSONProtocol.RType.i16 = Type.I16;
TJSONProtocol.RType.i32 = Type.I32;
TJSONProtocol.RType.i64 = Type.I64;
TJSONProtocol.RType.dbl = Type.DOUBLE;
TJSONProtocol.RType.rec = Type.STRUCT;
TJSONProtocol.RType.str = Type.STRING;
TJSONProtocol.RType.map = Type.MAP;
TJSONProtocol.RType.lst = Type.LIST;
TJSONProtocol.RType.set = Type.SET;

/**
 * The TJSONProtocol version number.
 * @readonly
 * @const {number} Version
 * @memberof Thrift.Protocol
 */
TJSONProtocol.Version = 1;

TJSONProtocol.prototype.flush = function() {
  this.writeToTransportIfStackIsFlushable();
  return this.trans.flush();
};

TJSONProtocol.prototype.writeToTransportIfStackIsFlushable = function() {
  if (this.tstack.length === 1) {
    this.trans.write(this.tstack.pop());
  }
};

/**
 * Serializes the beginning of a Thrift RPC message.
 * @param {string} name - The service method to call.
 * @param {Thrift.MessageType} messageType - The type of method call.
 * @param {number} seqid - The sequence number of this call (always 0 in Apache Thrift).
 */
TJSONProtocol.prototype.writeMessageBegin = function(name, messageType, seqid) {
  this.tstack.push([TJSONProtocol.Version, '"' + name + '"', messageType, seqid]);
};

/**
 * Serializes the end of a Thrift RPC message.
 */
TJSONProtocol.prototype.writeMessageEnd = function() {
  var obj = this.tstack.pop();

  this.wobj = this.tstack.pop();
  this.wobj.push(obj);

  this.wbuf = '[' + this.wobj.join(',') + ']';

  // we assume there is nothing more to come so we write
  this.trans.write(this.wbuf);
};

/**
 * Serializes the beginning of a struct.
 * @param {string} name - The name of the struct.
 */
TJSONProtocol.prototype.writeStructBegin = function(name) {
  this.tpos.push(this.tstack.length);
  this.tstack.push({});
};

/**
 * Serializes the end of a struct.
 */
TJSONProtocol.prototype.writeStructEnd = function() {
  var p = this.tpos.pop();
  var struct = this.tstack[p];
  var str = '{';
  var first = true;
  for (var key in struct) {
    if (first) {
      first = false;
    } else {
      str += ',';
    }

    str += key + ':' + struct[key];
  }

  str += '}';
  this.tstack[p] = str;

  this.writeToTransportIfStackIsFlushable();
};

/**
 * Serializes the beginning of a struct field.
 * @param {string} name - The name of the field.
 * @param {Thrift.Protocol.Type} fieldType - The data type of the field.
 * @param {number} fieldId - The field's unique identifier.
 */
TJSONProtocol.prototype.writeFieldBegin = function(name, fieldType, fieldId) {
  this.tpos.push(this.tstack.length);
  this.tstack.push({ 'fieldId': '"' +
    fieldId + '"', 'fieldType': TJSONProtocol.Type[fieldType]
  });
};

/**
 * Serializes the end of a field.
 */
TJSONProtocol.prototype.writeFieldEnd = function() {
  var value = this.tstack.pop();
  var fieldInfo = this.tstack.pop();

  if (':' + value === ":[object Object]") {
    this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
      fieldInfo.fieldType + ':' + JSON.stringify(value) + '}';
  } else {
    this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
      fieldInfo.fieldType + ':' + value + '}';
  }
  this.tpos.pop();

  this.writeToTransportIfStackIsFlushable();
};

/**
 * Serializes the end of the set of fields for a struct.
 */
TJSONProtocol.prototype.writeFieldStop = function() {
};

/**
 * Serializes the beginning of a map collection.
 * @param {Thrift.Type} keyType - The data type of the key.
 * @param {Thrift.Type} valType - The data type of the value.
 * @param {number} [size] - The number of elements in the map (ignored).
 */
TJSONProtocol.prototype.writeMapBegin = function(keyType, valType, size) {
  //size is invalid, we'll set it on end.
  this.tpos.push(this.tstack.length);
  this.tstack.push([TJSONProtocol.Type[keyType], TJSONProtocol.Type[valType], 0]);
};

/**
 * Serializes the end of a map.
 */
TJSONProtocol.prototype.writeMapEnd = function() {
  var p = this.tpos.pop();

  if (p == this.tstack.length) {
    return;
  }

  if ((this.tstack.length - p - 1) % 2 !== 0) {
    this.tstack.push('');
  }

  var size = (this.tstack.length - p - 1) / 2;

  this.tstack[p][this.tstack[p].length - 1] = size;

  var map = '}';
  var first = true;
  while (this.tstack.length > p + 1) {
    var v = this.tstack.pop();
    var k = this.tstack.pop();
    if (first) {
      first = false;
    } else {
      map = ',' + map;
    }

    if (! isNaN(k)) { k = '"' + k + '"'; } //json "keys" need to be strings
    map = k + ':' + v + map;
  }
  map = '{' + map;

  this.tstack[p].push(map);
  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';

  this.writeToTransportIfStackIsFlushable();
};

/**
 * Serializes the beginning of a list collection.
 * @param {Thrift.Type} elemType - The data type of the elements.
 * @param {number} size - The number of elements in the list.
 */
TJSONProtocol.prototype.writeListBegin = function(elemType, size) {
  this.tpos.push(this.tstack.length);
  this.tstack.push([TJSONProtocol.Type[elemType], size]);
};

/**
 * Serializes the end of a list.
 */
TJSONProtocol.prototype.writeListEnd = function() {
  var p = this.tpos.pop();

  while (this.tstack.length > p + 1) {
    var tmpVal = this.tstack[p + 1];
    this.tstack.splice(p + 1, 1);
    this.tstack[p].push(tmpVal);
  }

  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';

  this.writeToTransportIfStackIsFlushable();
};

/**
 * Serializes the beginning of a set collection.
 * @param {Thrift.Type} elemType - The data type of the elements.
 * @param {number} size - The number of elements in the list.
 */
TJSONProtocol.prototype.writeSetBegin = function(elemType, size) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([TJSONProtocol.Type[elemType], size]);
};

/**
 * Serializes the end of a set.
 */
TJSONProtocol.prototype.writeSetEnd = function() {
  var p = this.tpos.pop();

  while (this.tstack.length > p + 1) {
    var tmpVal = this.tstack[p + 1];
    this.tstack.splice(p + 1, 1);
    this.tstack[p].push(tmpVal);
  }

  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';

  this.writeToTransportIfStackIsFlushable();
};

/** Serializes a boolean */
TJSONProtocol.prototype.writeBool = function(bool) {
  this.tstack.push(bool ? 1 : 0);
};

/** Serializes a number */
TJSONProtocol.prototype.writeByte = function(byte) {
  this.tstack.push(byte);
};

/** Serializes a number */
TJSONProtocol.prototype.writeI16 = function(i16) {
  this.tstack.push(i16);
};

/** Serializes a number */
TJSONProtocol.prototype.writeI32 = function(i32) {
  this.tstack.push(i32);
};

/** Serializes a number */
TJSONProtocol.prototype.writeI64 = function(i64) {
  if (i64 instanceof Int64) {
    this.tstack.push(Int64Util.toDecimalString(i64));
  } else {
    this.tstack.push(i64);
  }
};

/** Serializes a number */
TJSONProtocol.prototype.writeDouble = function(dub) {
  this.tstack.push(dub);
};

/** Serializes a string */
TJSONProtocol.prototype.writeString = function(arg) {
  // We do not encode uri components for wire transfer:
  if (arg === null) {
      this.tstack.push(null);
  } else {
      if (typeof arg === 'string') {
        var str = arg;
      } else if (arg instanceof Buffer) {
        var str = arg.toString('utf8');
      } else {
        throw new Error('writeString called without a string/Buffer argument: ' + arg);
      }

      // concat may be slower than building a byte buffer
      var escapedString = '';
      for (var i = 0; i < str.length; i++) {
          var ch = str.charAt(i);      // a single double quote: "
          if (ch === '\"') {
              escapedString += '\\\"'; // write out as: \"
          } else if (ch === '\\') {    // a single backslash: \
              escapedString += '\\\\'; // write out as: \\
          /* Currently escaped forward slashes break TJSONProtocol.
           * As it stands, we can simply pass forward slashes into
           * our strings across the wire without being escaped.
           * I think this is the protocol's bug, not thrift.js
           * } else if(ch === '/') {   // a single forward slash: /
           *  escapedString += '\\/';  // write out as \/
           * }
           */
          } else if (ch === '\b') {    // a single backspace: invisible
              escapedString += '\\b';  // write out as: \b"
          } else if (ch === '\f') {    // a single formfeed: invisible
              escapedString += '\\f';  // write out as: \f"
          } else if (ch === '\n') {    // a single newline: invisible
              escapedString += '\\n';  // write out as: \n"
          } else if (ch === '\r') {    // a single return: invisible
              escapedString += '\\r';  // write out as: \r"
          } else if (ch === '\t') {    // a single tab: invisible
              escapedString += '\\t';  // write out as: \t"
          } else {
              escapedString += ch;     // Else it need not be escaped
          }
      }
      this.tstack.push('"' + escapedString + '"');
  }
};

/** Serializes a string */
TJSONProtocol.prototype.writeBinary = function(arg) {
  if (typeof arg === 'string') {
    var buf = new Buffer(arg, 'binary');
  } else if (arg instanceof Buffer ||
             Object.prototype.toString.call(arg) == '[object Uint8Array]')  {
    var buf = arg;
  } else {
    throw new Error('writeBinary called without a string/Buffer argument: ' + arg);
  }
  this.tstack.push('"' + buf.toString('base64') + '"');
};

/**
 * @class
 * @name AnonReadMessageBeginReturn
 * @property {string} fname - The name of the service method.
 * @property {Thrift.MessageType} mtype - The type of message call.
 * @property {number} rseqid - The sequence number of the message (0 in Thrift RPC).
 */
/**
 * Deserializes the beginning of a message.
 * @returns {AnonReadMessageBeginReturn}
 */
TJSONProtocol.prototype.readMessageBegin = function() {
  this.rstack = [];
  this.rpos = [];

  //Borrow the inbound transport buffer and ensure data is present/consistent
  var transBuf = this.trans.borrow();
  if (transBuf.readIndex >= transBuf.writeIndex) {
    throw new InputBufferUnderrunError();
  }
  var cursor = transBuf.readIndex;

  if (transBuf.buf[cursor] !== 0x5B) { //[
    throw new Error("Malformed JSON input, no opening bracket");
  }

  //Parse a single message (there may be several in the buffer)
  //  TODO: Handle characters using multiple code units
  cursor++;
  var openBracketCount = 1;
  var inString = false;
  for (; cursor < transBuf.writeIndex; cursor++) {
    var chr = transBuf.buf[cursor];
    //we use hexa charcode here because data[i] returns an int and not a char
    if (inString) {
      if (chr === 0x22) { //"
        inString = false;
      } else if (chr === 0x5C) { //\
        //escaped character, skip
        cursor += 1;
      }
    } else {
      if (chr === 0x5B) { //[
        openBracketCount += 1;
      } else if (chr === 0x5D) { //]
        openBracketCount -= 1;
        if (openBracketCount === 0) {
          //end of json message detected
          break;
        }
      } else if (chr === 0x22) { //"
        inString = true;
      }
    }
  }

  if (openBracketCount !== 0) {
    // Missing closing bracket. Can be buffer underrun.
    throw new InputBufferUnderrunError();
  }

  //Reconstitute the JSON object and conume the necessary bytes
  this.robj = json_parse(transBuf.buf.slice(transBuf.readIndex, cursor+1).toString());
  this.trans.consume(cursor + 1 - transBuf.readIndex);

  //Verify the protocol version
  var version = this.robj.shift();
  if (version != TJSONProtocol.Version) {
    throw new Error('Wrong thrift protocol version: ' + version);
  }

  //Objectify the thrift message {name/type/sequence-number} for return
  // and then save the JSON object in rstack
  var r = {};
  r.fname = this.robj.shift();
  r.mtype = this.robj.shift();
  r.rseqid = this.robj.shift();
  this.rstack.push(this.robj.shift());
  return r;
};

/** Deserializes the end of a message. */
TJSONProtocol.prototype.readMessageEnd = function() {
};

/**
 * Deserializes the beginning of a struct.
 * @param {string} [name] - The name of the struct (ignored)
 * @returns {object} - An object with an empty string fname property
 */
TJSONProtocol.prototype.readStructBegin = function() {
  var r = {};
  r.fname = '';

  //incase this is an array of structs
  if (this.rstack[this.rstack.length - 1] instanceof Array) {
    this.rstack.push(this.rstack[this.rstack.length - 1].shift());
  }

  return r;
};

/** Deserializes the end of a struct. */
TJSONProtocol.prototype.readStructEnd = function() {
  this.rstack.pop();
};

/**
 * @class
 * @name AnonReadFieldBeginReturn
 * @property {string} fname - The name of the field (always '').
 * @property {Thrift.Type} ftype - The data type of the field.
 * @property {number} fid - The unique identifier of the field.
 */
/**
 * Deserializes the beginning of a field.
 * @returns {AnonReadFieldBeginReturn}
 */
TJSONProtocol.prototype.readFieldBegin = function() {
  var r = {};

  var fid = -1;
  var ftype = Type.STOP;

  //get a fieldId
  for (var f in (this.rstack[this.rstack.length - 1])) {
    if (f === null) {
      continue;
    }

    fid = parseInt(f, 10);
    this.rpos.push(this.rstack.length);

    var field = this.rstack[this.rstack.length - 1][fid];

    //remove so we don't see it again
    delete this.rstack[this.rstack.length - 1][fid];

    this.rstack.push(field);

    break;
  }

  if (fid != -1) {
    //should only be 1 of these but this is the only
    //way to match a key
    for (var i in (this.rstack[this.rstack.length - 1])) {
      if (TJSONProtocol.RType[i] === null) {
        continue;
      }

      ftype = TJSONProtocol.RType[i];
      this.rstack[this.rstack.length - 1] = this.rstack[this.rstack.length - 1][i];
    }
  }

  r.fname = '';
  r.ftype = ftype;
  r.fid = fid;

  return r;
};

/** Deserializes the end of a field. */
TJSONProtocol.prototype.readFieldEnd = function() {
  var pos = this.rpos.pop();

  //get back to the right place in the stack
  while (this.rstack.length > pos) {
    this.rstack.pop();
  }
};

/**
 * @class
 * @name AnonReadMapBeginReturn
 * @property {Thrift.Type} ktype - The data type of the key.
 * @property {Thrift.Type} vtype - The data type of the value.
 * @property {number} size - The number of elements in the map.
 */
/**
 * Deserializes the beginning of a map.
 * @returns {AnonReadMapBeginReturn}
 */
TJSONProtocol.prototype.readMapBegin = function() {
  var map = this.rstack.pop();
  var first = map.shift();
  if (first instanceof Array) {
    this.rstack.push(map);
    map = first;
    first = map.shift();
  }

  var r = {};
  r.ktype = TJSONProtocol.RType[first];
  r.vtype = TJSONProtocol.RType[map.shift()];
  r.size = map.shift();


  this.rpos.push(this.rstack.length);
  this.rstack.push(map.shift());

  return r;
};

/** Deserializes the end of a map. */
TJSONProtocol.prototype.readMapEnd = function() {
  this.readFieldEnd();
};

/**
 * @class
 * @name AnonReadColBeginReturn
 * @property {Thrift.Type} etype - The data type of the element.
 * @property {number} size - The number of elements in the collection.
 */
/**
 * Deserializes the beginning of a list.
 * @returns {AnonReadColBeginReturn}
 */
TJSONProtocol.prototype.readListBegin = function() {
  var list = this.rstack[this.rstack.length - 1];

  var r = {};
  r.etype = TJSONProtocol.RType[list.shift()];
  r.size = list.shift();

  this.rpos.push(this.rstack.length);
  this.rstack.push(list.shift());

  return r;
};

/** Deserializes the end of a list. */
TJSONProtocol.prototype.readListEnd = function() {
  var pos = this.rpos.pop() - 2;
  var st = this.rstack;
  st.pop();
  if (st instanceof Array && st.length > pos && st[pos].length > 0) {
    st.push(st[pos].shift());
  }
};

/**
 * Deserializes the beginning of a set.
 * @returns {AnonReadColBeginReturn}
 */
TJSONProtocol.prototype.readSetBegin = function() {
  return this.readListBegin();
};

/** Deserializes the end of a set. */
TJSONProtocol.prototype.readSetEnd = function() {
  return this.readListEnd();
};

TJSONProtocol.prototype.readBool = function() {
  return this.readValue() == '1';
};

TJSONProtocol.prototype.readByte = function() {
  return this.readI32();
};

TJSONProtocol.prototype.readI16 = function() {
  return this.readI32();
};

TJSONProtocol.prototype.readI32 = function(f) {
  return +this.readValue();
}

/** Returns the next value found in the protocol buffer */
TJSONProtocol.prototype.readValue = function(f) {
  if (f === undefined) {
    f = this.rstack[this.rstack.length - 1];
  }

  var r = {};

  if (f instanceof Array) {
    if (f.length === 0) {
      r.value = undefined;
    } else {
      r.value = f.shift();
    }
  } else if (!(f instanceof Int64) && f instanceof Object) {
    for (var i in f) {
      if (i === null) {
        continue;
      }
      this.rstack.push(f[i]);
      delete f[i];

      r.value = i;
      break;
    }
  } else {
    r.value = f;
    this.rstack.pop();
  }

  return r.value;
};

TJSONProtocol.prototype.readI64 = function() {
  var n = this.readValue()
  if (typeof n === 'string') {
    // Assuming no one is sending in 1.11111e+33 format
    return Int64Util.fromDecimalString(n);
  } else {
    return new Int64(n);
  }
};

TJSONProtocol.prototype.readDouble = function() {
  return this.readI32();
};

TJSONProtocol.prototype.readBinary = function() {
  return new Buffer(this.readValue(), 'base64');
};

TJSONProtocol.prototype.readString = function() {
  return this.readValue();
};

/**
 * Returns the underlying transport.
 * @readonly
 * @returns {Thrift.Transport} The underlying transport.
 */
TJSONProtocol.prototype.getTransport = function() {
  return this.trans;
};

/**
 * Method to arbitrarily skip over data
 */
TJSONProtocol.prototype.skip = function(type) {
    switch (type) {
    case Type.BOOL:
      this.readBool();
      break;
    case Type.BYTE:
      this.readByte();
      break;
    case Type.I16:
      this.readI16();
      break;
    case Type.I32:
      this.readI32();
      break;
    case Type.I64:
      this.readI64();
      break;
    case Type.DOUBLE:
      this.readDouble();
      break;
    case Type.STRING:
      this.readString();
      break;
    case Type.STRUCT:
      this.readStructBegin();
      while (true) {
        var r = this.readFieldBegin();
        if (r.ftype === Type.STOP) {
          break;
        }
        this.skip(r.ftype);
        this.readFieldEnd();
      }
      this.readStructEnd();
      break;
    case Type.MAP:
      var mapBegin = this.readMapBegin();
      for (var i = 0; i < mapBegin.size; ++i) {
        this.skip(mapBegin.ktype);
        this.skip(mapBegin.vtype);
      }
      this.readMapEnd();
      break;
    case Type.SET:
      var setBegin = this.readSetBegin();
      for (var i2 = 0; i2 < setBegin.size; ++i2) {
        this.skip(setBegin.etype);
      }
      this.readSetEnd();
      break;
    case Type.LIST:
      var listBegin = this.readListBegin();
      for (var i3 = 0; i3 < listBegin.size; ++i3) {
        this.skip(listBegin.etype);
      }
      this.readListEnd();
      break;
    default:
      throw new  Error("Invalid type: " + type);
  }
};


/***/ }),

/***/ 1291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var util = __webpack_require__(9539);

var disabled = function () {};
var logFunc = console.log;
var logLevel = 'error'; // default level

function factory(level) {
  return function () {
    // better use spread syntax, but due to compatibility,
    // use legacy method here.
    var args = ['thrift: [' + level + '] '].concat(Array.from(arguments));
    return logFunc(util.format.apply(null, args));
  };
}

var trace = disabled;
var debug = disabled;
var error = disabled;
var warning = disabled;
var info = disabled;

exports.setLogFunc = function (func) {
  logFunc = func;
};

var setLogLevel = exports.setLogLevel = function (level) {
  trace = debug = error = warning = info = disabled;
  logLevel = level;
  switch (logLevel) {
  case 'trace':
    trace = factory('TRACE');
  case 'debug':
    debug = factory('DEBUG');
  case 'error':
    error = factory('ERROR');
  case 'warning':
    warning = factory('WARN');
  case 'info':
    info = factory('INFO');
  }
};

// set default
setLogLevel(logLevel);

exports.getLogLevel = function () {
  return logLevel;
};

exports.trace = function () {
  return trace.apply(null, arguments);
};

exports.debug = function () {
  return debug.apply(null, arguments);
};

exports.error = function () {
  return error.apply(null, arguments);
};

exports.warning = function () {
  return warning.apply(null, arguments);
};

exports.info = function () {
  return info.apply(null, arguments);
};


/***/ }),

/***/ 4184:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(9539);
var Thrift = __webpack_require__(5406);

exports.Multiplexer = Multiplexer;

function Wrapper(serviceName, protocol, connection) {

  function MultiplexProtocol(trans, strictRead, strictWrite) {
    protocol.call(this, trans, strictRead, strictWrite);
  };

  util.inherits(MultiplexProtocol, protocol);

  MultiplexProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
    if (type == Thrift.MessageType.CALL || type == Thrift.MessageType.ONEWAY) {
      connection.seqId2Service[seqid] = serviceName;
      MultiplexProtocol.super_.prototype.writeMessageBegin.call(this,
                                                                serviceName + ":" + name,
                                                                type,
                                                                seqid);
    } else {
      MultiplexProtocol.super_.prototype.writeMessageBegin.call(this, name, type, seqid);
    }
  };

  return MultiplexProtocol;
};

function Multiplexer() {
  this.seqid = 0;
};

Multiplexer.prototype.createClient = function(serviceName, ServiceClient, connection) {
  if (ServiceClient.Client) {
    ServiceClient = ServiceClient.Client;
  }
  var writeCb = function(buf, seqid) {
    connection.write(buf,seqid);
  };
  var transport = new connection.transport(undefined, writeCb);
  var protocolWrapper = new Wrapper(serviceName, connection.protocol, connection);
  var client = new ServiceClient(transport, protocolWrapper);
  var self = this;
  client.new_seqid = function() {
    self.seqid += 1;
    return self.seqid;
  };

  if (typeof connection.client !== 'object') {
    connection.client = {};
  }
  connection.client[serviceName] = client;

  return client;
};


/***/ }),

/***/ 5406:
/***/ ((module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(9539);

var Type = exports.Type = {
  STOP: 0,
  VOID: 1,
  BOOL: 2,
  BYTE: 3,
  I08: 3,
  DOUBLE: 4,
  I16: 6,
  I32: 8,
  I64: 10,
  STRING: 11,
  UTF7: 11,
  STRUCT: 12,
  MAP: 13,
  SET: 14,
  LIST: 15,
  UTF8: 16,
  UTF16: 17
};

exports.MessageType = {
  CALL: 1,
  REPLY: 2,
  EXCEPTION: 3,
  ONEWAY: 4
};

exports.TException = TException;

function TException(message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = this.constructor.name;
  this.message = message;
};
util.inherits(TException, Error);

var TApplicationExceptionType = exports.TApplicationExceptionType = {
  UNKNOWN: 0,
  UNKNOWN_METHOD: 1,
  INVALID_MESSAGE_TYPE: 2,
  WRONG_METHOD_NAME: 3,
  BAD_SEQUENCE_ID: 4,
  MISSING_RESULT: 5,
  INTERNAL_ERROR: 6,
  PROTOCOL_ERROR: 7,
  INVALID_TRANSFORM: 8,
  INVALID_PROTOCOL: 9,
  UNSUPPORTED_CLIENT_TYPE: 10
};

exports.TApplicationException = TApplicationException;

function TApplicationException(type, message) {
  TException.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.type = type || TApplicationExceptionType.UNKNOWN;
  this.name = this.constructor.name;
  this.message = message;
};
util.inherits(TApplicationException, TException);

TApplicationException.prototype.read = function(input) {
  var ftype;
  var ret = input.readStructBegin('TApplicationException');

  while(1){
      ret = input.readFieldBegin();
      if(ret.ftype == Type.STOP)
          break;

      switch(ret.fid){
          case 1:
              if( ret.ftype == Type.STRING ){
                  ret = input.readString();
                  this.message = ret;
              } else {
                  ret = input.skip(ret.ftype);
              }
              break;
          case 2:
              if( ret.ftype == Type.I32 ){
                  ret = input.readI32();
                  this.type = ret;
              } else {
                  ret   = input.skip(ret.ftype);
              }
              break;
          default:
              ret = input.skip(ret.ftype);
              break;
      }
      input.readFieldEnd();
  }
  input.readStructEnd();
};

TApplicationException.prototype.write = function(output){
  output.writeStructBegin('TApplicationException');

  if (this.message) {
      output.writeFieldBegin('message', Type.STRING, 1);
      output.writeString(this.message);
      output.writeFieldEnd();
  }

  if (this.code) {
      output.writeFieldBegin('type', Type.I32, 2);
      output.writeI32(this.code);
      output.writeFieldEnd();
  }

  output.writeFieldStop();
  output.writeStructEnd();
};

var TProtocolExceptionType = exports.TProtocolExceptionType = {
  UNKNOWN: 0,
  INVALID_DATA: 1,
  NEGATIVE_SIZE: 2,
  SIZE_LIMIT: 3,
  BAD_VERSION: 4,
  NOT_IMPLEMENTED: 5,
  DEPTH_LIMIT: 6
};


exports.TProtocolException = TProtocolException;

function TProtocolException(type, message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = this.constructor.name;
  this.type = type;
  this.message = message;
};
util.inherits(TProtocolException, Error);

exports.objectLength = function(obj) {
  return Object.keys(obj).length;
};

exports.inherits = function(constructor, superConstructor) {
  util.inherits(constructor, superConstructor);
};

var copyList, copyMap;

copyList = function(lst, types) {

  if (!lst) {return lst; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var len = lst.length, result = [], i, val;
  for (i = 0; i < len; i++) {
    val = lst[i];
    if (type === null) {
      result.push(val);
    }
    else if (type === copyMap || type === copyList) {
      result.push(type(val, types.slice(1)));
    }
    else {
      result.push(new Type(val));
    }
  }
  return result;
};

copyMap = function(obj, types){

  if (!obj) {return obj; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var result = {}, val;
  for(var prop in obj) {
    if(obj.hasOwnProperty(prop)) {
      val = obj[prop];
      if (type === null) {
        result[prop] = val;
      }
      else if (type === copyMap || type === copyList) {
        result[prop] = type(val, types.slice(1));
      }
      else {
        result[prop] = new Type(val);
      }
    }
  }
  return result;
};

module.exports.copyMap = copyMap;
module.exports.copyList = copyList;


/***/ }),

/***/ 5455:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(9539);
var WebSocket = __webpack_require__(6792);
var EventEmitter = __webpack_require__(7187).EventEmitter;
var thrift = __webpack_require__(5406);

var TBufferedTransport = __webpack_require__(8869);
var TJSONProtocol = __webpack_require__(5086);
var InputBufferUnderrunError = __webpack_require__(3590);

var createClient = __webpack_require__(6243);
var jsEnv = __webpack_require__(3818);
exports.WSConnection = WSConnection;

/**
 * @class
 * @name WSConnectOptions
 * @property {string} transport - The Thrift layered transport to use (TBufferedTransport, etc).
 * @property {string} protocol - The Thrift serialization protocol to use (TJSONProtocol, etc.).
 * @property {string} path - The URL path to connect to (e.g. "/", "/mySvc", "/thrift/quoteSvc", etc.).
 * @property {object} headers - A standard Node.js header hash, an object hash containing key/value
 *        pairs where the key is the header name string and the value is the header value string.
 * @property {boolean} secure - True causes the connection to use wss, otherwise ws is used.
 * @property {object} wsOptions - Options passed on to WebSocket.
 * @example
 *     //Use a secured websocket connection
 *     //  uses the buffered transport layer, uses the JSON protocol and directs RPC traffic
 *     //  to wss://thrift.example.com:9090/hello
 *     var thrift = require('thrift');
 *     var options = {
 *        transport: thrift.TBufferedTransport,
 *        protocol: thrift.TJSONProtocol,
 *        path: "/hello",
 *        secure: true
 *     };
 *     var con = thrift.createWSConnection("thrift.example.com", 9090, options);
 *     con.open()
 *     var client = thrift.createWSClient(myService, connection);
 *     client.myServiceFunction();
 *     con.close()
 */

/**
 * Initializes a Thrift WSConnection instance (use createWSConnection() rather than
 *    instantiating directly).
 * @constructor
 * @param {string} host - The host name or IP to connect to.
 * @param {number} port - The TCP port to connect to.
 * @param {WSConnectOptions} options - The configuration options to use.
 * @throws {error} Exceptions other than ttransport.InputBufferUnderrunError are rethrown
 * @event {error} The "error" event is fired when a Node.js error event occurs during
 *     request or response processing, in which case the node error is passed on. An "error"
 *     event may also be fired when the connection can not map a response back to the
 *     appropriate client (an internal error), generating a TApplicationException.
 * @classdesc WSConnection objects provide Thrift end point transport
 *     semantics implemented using Websockets.
 * @see {@link createWSConnection}
 */
function WSConnection(host, port, options) {
  //Initialize the emitter base object
  EventEmitter.call(this);

  //Set configuration
  this.options = options || {};
  this.host = host;
  this.port = port;
  this.secure = this.options.secure || false;
  this.transport = this.options.transport || TBufferedTransport;
  this.protocol = this.options.protocol || TJSONProtocol;
  this.path = this.options.path;
  this.send_pending = [];

  //The sequence map is used to map seqIDs back to the
  //  calling client in multiplexed scenarios
  this.seqId2Service = {};

  //Prepare WebSocket options
  this.wsOptions = {
    host: this.host,
    port: this.port || 80,
    path: this.options.path || '/',
    headers: this.options.headers || {}
  };
  for (var attrname in this.options.wsOptions) {
    this.wsOptions[attrname] = this.options.wsOptions[attrname];
  }
};
util.inherits(WSConnection, EventEmitter);

WSConnection.prototype.__reset = function() {
  this.socket = null; //The web socket
  this.send_pending = []; //Buffers/Callback pairs waiting to be sent
};

WSConnection.prototype.__onOpen = function() {
  this.emit("open");
  if (this.send_pending.length > 0) {
    //If the user made calls before the connection was fully
    //open, send them now
    this.send_pending.forEach(function(data) {
      this.socket.send(data);
    }, this);
    this.send_pending = [];
  }
};

WSConnection.prototype.__onClose = function(evt) {
  this.emit("close");
  this.__reset();
};

WSConnection.prototype.__decodeCallback = function(transport_with_data) {
  var proto = new this.protocol(transport_with_data);
  try {
    while (true) {
      var header = proto.readMessageBegin();
      var dummy_seqid = header.rseqid * -1;
      var client = this.client;
      //The Multiplexed Protocol stores a hash of seqid to service names
      //  in seqId2Service. If the SeqId is found in the hash we need to
      //  lookup the appropriate client for this call.
      //  The client var is a single client object when not multiplexing,
      //  when using multiplexing it is a service name keyed hash of client
      //  objects.
      //NOTE: The 2 way interdependencies between protocols, transports,
      //  connections and clients in the Node.js implementation are irregular
      //  and make the implementation difficult to extend and maintain. We
      //  should bring this stuff inline with typical thrift I/O stack
      //  operation soon.
      //  --ra
      var service_name = this.seqId2Service[header.rseqid];
      if (service_name) {
        client = this.client[service_name];
        delete this.seqId2Service[header.rseqid];
      }
      /*jshint -W083 */
      client._reqs[dummy_seqid] = function(err, success) {
        transport_with_data.commitPosition();
        var clientCallback = client._reqs[header.rseqid];
        delete client._reqs[header.rseqid];
        if (clientCallback) {
          clientCallback(err, success);
        }
      };
      /*jshint +W083 */
      if (client['recv_' + header.fname]) {
        client['recv_' + header.fname](proto, header.mtype, dummy_seqid);
      } else {
        delete client._reqs[dummy_seqid];
        this.emit("error",
          new thrift.TApplicationException(
            thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
            "Received a response to an unknown RPC function"));
      }
    }
  } catch (e) {
    if (e instanceof InputBufferUnderrunError) {
      transport_with_data.rollbackPosition();
    } else {
      throw e;
    }
  }
};

WSConnection.prototype.__onData = function(data) {
  if (Object.prototype.toString.call(data) === "[object ArrayBuffer]") {
    data = new Uint8Array(data);
  }
  var buf = new Buffer(data);
  this.transport.receiver(this.__decodeCallback.bind(this))(buf);

};

WSConnection.prototype.__onMessage = function(evt) {
  this.__onData(evt.data);
};

WSConnection.prototype.__onError = function(evt) {
  this.emit("error", evt);
  this.socket.close();
};

/**
 * Returns true if the transport is open
 * @readonly
 * @returns {boolean}
 */
WSConnection.prototype.isOpen = function() {
  return this.socket && this.socket.readyState === this.socket.OPEN;
};

/**
 * Opens the transport connection
 */
WSConnection.prototype.open = function() {
  //If OPEN/CONNECTING/CLOSING ignore additional opens
  if (this.socket && this.socket.readyState !== this.socket.CLOSED) {
    return;
  }
  //If there is no socket or the socket is closed:
  if (jsEnv.isBrowser) {
    this.socket = new WebSocket(this.uri());
  } else {
    this.socket = new WebSocket(this.uri(), "", this.wsOptions);
  }
  this.socket.binaryType = 'arraybuffer';
  this.socket.onopen = this.__onOpen.bind(this);
  this.socket.onmessage = this.__onMessage.bind(this);
  this.socket.onerror = this.__onError.bind(this);
  this.socket.onclose = this.__onClose.bind(this);
};

/**
 * Closes the transport connection
 */
WSConnection.prototype.close = function() {
  this.socket.close();
};

/**
 * Return URI for the connection
 * @returns {string} URI
 */
WSConnection.prototype.uri = function() {
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';
  var path = this.path || '/';
  var host = this.host;

  // avoid port if default for schema
  if (this.port && (('wss' === schema && this.port !== 443) ||
    ('ws' === schema && this.port !== 80))) {
    port = ':' + this.port;
  }

  return schema + '://' + host + port + path;
};

/**
 * Writes Thrift message data to the connection
 * @param {Buffer} data - A Node.js Buffer containing the data to write
 * @returns {void} No return value.
 * @event {error} the "error" event is raised upon request failure passing the
 *     Node.js error object to the listener.
 */
WSConnection.prototype.write = function(data) {
  if (this.isOpen()) {
    //Send data and register a callback to invoke the client callback
    this.socket.send(data);
  } else {
    //Queue the send to go out __onOpen
    this.send_pending.push(data);
  }
};

/**
 * Creates a new WSConnection object, used by Thrift clients to connect
 *    to Thrift HTTP based servers.
 * @param {string} host - The host name or IP to connect to.
 * @param {number} port - The TCP port to connect to.
 * @param {WSConnectOptions} options - The configuration options to use.
 * @returns {WSConnection} The connection object.
 * @see {@link WSConnectOptions}
 */
exports.createWSConnection = function(host, port, options) {
  return new WSConnection(host, port, options);
};

exports.createWSClient = createClient;


/***/ }),

/***/ 5764:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var log = __webpack_require__(1291);

module.exports = TWebSocketTransport;

/**
 * Constructor Function for the WebSocket transport.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O
 * between RPC clients and servers. The JavaScript TWebSocketTransport object
 * uses the WebSocket protocol. Target servers must implement WebSocket.
 * (see: node.js example server_http.js).
 * @example
 *   var transport = new Thrift.TWebSocketTransport("http://localhost:8585");
 */
function TWebSocketTransport(url) {
    this.__reset(url);
};


TWebSocketTransport.prototype.__reset = function(url) {
  this.url = url;             //Where to connect
  this.socket = null;         //The web socket
  this.callbacks = [];        //Pending callbacks
  this.send_pending = [];     //Buffers/Callback pairs waiting to be sent
  this.send_buf = '';         //Outbound data, immutable until sent
  this.recv_buf = '';         //Inbound data
  this.rb_wpos = 0;           //Network write position in receive buffer
  this.rb_rpos = 0;           //Client read position in receive buffer
};

/**
 * Sends the current WS request and registers callback. The async
 * parameter is ignored (WS flush is always async) and the callback
 * function parameter is required.
 * @param {object} async - Ignored.
 * @param {object} callback - The client completion callback.
 * @returns {undefined|string} Nothing (undefined)
 */
TWebSocketTransport.prototype.flush = function(async, callback) {
  var self = this;
  if (this.isOpen()) {
    //Send data and register a callback to invoke the client callback
    this.socket.send(this.send_buf);
    this.callbacks.push((function() {
      var clientCallback = callback;
      return function(msg) {
        self.setRecvBuffer(msg);
        clientCallback();
      };
    }()));
  } else {
    //Queue the send to go out __onOpen
    this.send_pending.push({
      buf: this.send_buf,
      cb:  callback
    });
  }
};

TWebSocketTransport.prototype.__onOpen = function() {
   var self = this;
   if (this.send_pending.length > 0) {
      //If the user made calls before the connection was fully
      //open, send them now
      this.send_pending.forEach(function(elem) {
         self.socket.send(elem.buf);
         self.callbacks.push((function() {
           var clientCallback = elem.cb;
           return function(msg) {
              self.setRecvBuffer(msg);
              clientCallback();
           };
         }()));
      });
      this.send_pending = [];
   }
};

TWebSocketTransport.prototype.__onClose = function(evt) {
  this.__reset(this.url);
};

TWebSocketTransport.prototype.__onMessage = function(evt) {
  if (this.callbacks.length) {
    this.callbacks.shift()(evt.data);
  }
};

TWebSocketTransport.prototype.__onError = function(evt) {
  log.error('websocket: ' + evt.toString());
  this.socket.close();
};

/**
 * Sets the buffer to use when receiving server responses.
 * @param {string} buf - The buffer to receive server responses.
 */
TWebSocketTransport.prototype.setRecvBuffer = function(buf) {
  this.recv_buf = buf;
  this.recv_buf_sz = this.recv_buf.length;
  this.wpos = this.recv_buf.length;
  this.rpos = 0;
};

/**
 * Returns true if the transport is open
 * @readonly
 * @returns {boolean}
 */
TWebSocketTransport.prototype.isOpen = function() {
  return this.socket && this.socket.readyState == this.socket.OPEN;
};

/**
 * Opens the transport connection
 */
TWebSocketTransport.prototype.open = function() {
  //If OPEN/CONNECTING/CLOSING ignore additional opens
  if (this.socket && this.socket.readyState != this.socket.CLOSED) {
    return;
  }
  //If there is no socket or the socket is closed:
  this.socket = new WebSocket(this.url);
  this.socket.onopen = this.__onOpen.bind(this);
  this.socket.onmessage = this.__onMessage.bind(this);
  this.socket.onerror = this.__onError.bind(this);
  this.socket.onclose = this.__onClose.bind(this);
};

/**
 * Closes the transport connection
 */
TWebSocketTransport.prototype.close = function() {
  this.socket.close();
};

/**
 * Returns the specified number of characters from the response
 * buffer.
 * @param {number} len - The number of characters to return.
 * @returns {string} Characters sent by the server.
 */
TWebSocketTransport.prototype.read = function(len) {
  var avail = this.wpos - this.rpos;

  if (avail === 0) {
    return '';
  }

  var give = len;

  if (avail < len) {
    give = avail;
  }

  var ret = this.read_buf.substr(this.rpos, give);
  this.rpos += give;

  //clear buf when complete?
  return ret;
};

/**
 * Returns the entire response buffer.
 * @returns {string} Characters sent by the server.
 */
TWebSocketTransport.prototype.readAll = function() {
  return this.recv_buf;
};

/**
 * Sets the send buffer to buf.
 * @param {string} buf - The buffer to send.
 */
TWebSocketTransport.prototype.write = function(buf) {
  this.send_buf = buf;
};

/**
 * Returns the send buffer.
 * @readonly
 * @returns {string} The send buffer.
 */
TWebSocketTransport.prototype.getSendBuffer = function() {
  return this.send_buf;
};


/***/ }),

/***/ 4050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(8764)["Buffer"];
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(9539);
var EventEmitter = __webpack_require__(7187).EventEmitter;
var thrift = __webpack_require__(5406);

var TBufferedTransport = __webpack_require__(8869);
var TJSONProtocol = __webpack_require__(5086);
var InputBufferUnderrunError = __webpack_require__(3590);

var createClient = __webpack_require__(6243);

exports.XHRConnection = XHRConnection;

/**
 * Constructor Function for the XHR Connection.
 * If you do not specify a host and port then XHRConnection will default to the
 * host and port of the page from which this javascript is served.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc TXHRConnection objects provide Thrift end point transport
 *     semantics implemented using XHR.
 * @example
 *     var transport = new Thrift.TXHRConnection('localhost', 9099, {});
 */
function XHRConnection(host, port, options) {
  this.options = options || {};
  this.wpos = 0;
  this.rpos = 0;
  this.useCORS = (options && options.useCORS);
  this.send_buf = '';
  this.recv_buf = '';
  this.transport = options.transport || TBufferedTransport;
  this.protocol = options.protocol || TJSONProtocol;
  this.headers = options.headers || {};

  host = host || window.location.host;
  port = port || window.location.port;
  var prefix = options.https ? 'https://' : 'http://';
  var path = options.path || '/';

  if (port === '') {
    port = undefined;
  }

  if (!port || port === 80 || port === '80') {
    this.url = prefix + host + path;
  } else {
    this.url = prefix + host + ':' + port + path;
  }

  //The sequence map is used to map seqIDs back to the
  //  calling client in multiplexed scenarios
  this.seqId2Service = {};
};

util.inherits(XHRConnection, EventEmitter);

/**
* Gets the browser specific XmlHttpRequest Object.
* @returns {object} the browser XHR interface object
*/
XHRConnection.prototype.getXmlHttpRequestObject = function() {
  try { return new XMLHttpRequest(); } catch (e1) { }
  try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }
  try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }

  throw "Your browser doesn't support XHR.";
};

/**
 * Sends the current XRH request if the transport was created with a URL
 * and the async parameter is false. If the transport was not created with
 * a URL, or the async parameter is True and no callback is provided, or
 * the URL is an empty string, the current send buffer is returned.
 * @param {object} async - If true the current send buffer is returned.
 * @param {object} callback - Optional async completion callback
 * @returns {undefined|string} Nothing or the current send buffer.
 * @throws {string} If XHR fails.
 */
XHRConnection.prototype.flush = function() {
  var self = this;
  if (this.url === undefined || this.url === '') {
    return this.send_buf;
  }

  var xreq = this.getXmlHttpRequestObject();

  if (xreq.overrideMimeType) {
    xreq.overrideMimeType('application/json');
  }

  xreq.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      self.setRecvBuffer(this.responseText);
    }
  };

  xreq.open('POST', this.url, true);

  Object.keys(this.headers).forEach(function(headerKey) {
    xreq.setRequestHeader(headerKey, self.headers[headerKey]);
  });

  xreq.send(this.send_buf);
};

/**
 * Sets the buffer to provide the protocol when deserializing.
 * @param {string} buf - The buffer to supply the protocol.
 */
XHRConnection.prototype.setRecvBuffer = function(buf) {
  this.recv_buf = buf;
  this.recv_buf_sz = this.recv_buf.length;
  this.wpos = this.recv_buf.length;
  this.rpos = 0;

  if (Object.prototype.toString.call(buf) == "[object ArrayBuffer]") {
    var data = new Uint8Array(buf);
  }
  var thing = new Buffer(data || buf);

  this.transport.receiver(this.__decodeCallback.bind(this))(thing);

};

XHRConnection.prototype.__decodeCallback = function(transport_with_data) {
  var proto = new this.protocol(transport_with_data);
  try {
    while (true) {
      var header = proto.readMessageBegin();
      var dummy_seqid = header.rseqid * -1;
      var client = this.client;
      //The Multiplexed Protocol stores a hash of seqid to service names
      //  in seqId2Service. If the SeqId is found in the hash we need to
      //  lookup the appropriate client for this call.
      //  The client var is a single client object when not multiplexing,
      //  when using multiplexing it is a service name keyed hash of client
      //  objects.
      //NOTE: The 2 way interdependencies between protocols, transports,
      //  connections and clients in the Node.js implementation are irregular
      //  and make the implementation difficult to extend and maintain. We
      //  should bring this stuff inline with typical thrift I/O stack
      //  operation soon.
      //  --ra
      var service_name = this.seqId2Service[header.rseqid];
      if (service_name) {
        client = this.client[service_name];
        delete this.seqId2Service[header.rseqid];
      }
      /*jshint -W083 */
      client._reqs[dummy_seqid] = function(err, success) {
        transport_with_data.commitPosition();
        var clientCallback = client._reqs[header.rseqid];
        delete client._reqs[header.rseqid];
        if (clientCallback) {
          clientCallback(err, success);
        }
      };
      /*jshint +W083 */
      if (client['recv_' + header.fname]) {
        client['recv_' + header.fname](proto, header.mtype, dummy_seqid);
      } else {
        delete client._reqs[dummy_seqid];
        this.emit("error",
          new thrift.TApplicationException(
            thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
            "Received a response to an unknown RPC function"));
      }
    }
  } catch (e) {
    if (e instanceof InputBufferUnderrunError) {
      transport_with_data.rollbackPosition();
    } else {
      throw e;
    }
  }
};

/**
 * Returns true if the transport is open, XHR always returns true.
 * @readonly
 * @returns {boolean} Always True.
 */
XHRConnection.prototype.isOpen = function() {
  return true;
};

/**
 * Opens the transport connection, with XHR this is a nop.
 */
XHRConnection.prototype.open = function() {};

/**
 * Closes the transport connection, with XHR this is a nop.
 */
XHRConnection.prototype.close = function() {};

/**
 * Returns the specified number of characters from the response
 * buffer.
 * @param {number} len - The number of characters to return.
 * @returns {string} Characters sent by the server.
 */
XHRConnection.prototype.read = function(len) {
  var avail = this.wpos - this.rpos;

  if (avail === 0) {
    return '';
  }

  var give = len;

  if (avail < len) {
    give = avail;
  }

  var ret = this.read_buf.substr(this.rpos, give);
  this.rpos += give;

  //clear buf when complete?
  return ret;
};

/**
 * Returns the entire response buffer.
 * @returns {string} Characters sent by the server.
 */
XHRConnection.prototype.readAll = function() {
  return this.recv_buf;
};

/**
 * Sets the send buffer to buf.
 * @param {string} buf - The buffer to send.
 */
XHRConnection.prototype.write = function(buf) {
  this.send_buf = buf;
  this.flush();
};

/**
 * Returns the send buffer.
 * @readonly
 * @returns {string} The send buffer.
 */
XHRConnection.prototype.getSendBuffer = function() {
  return this.send_buf;
};

/**
 * Creates a new TXHRTransport object, used by Thrift clients to connect
 *    to Thrift HTTP based servers.
 * @param {string} host - The host name or IP to connect to.
 * @param {number} port - The TCP port to connect to.
 * @param {XHRConnectOptions} options - The configuration options to use.
 * @returns {XHRConnection} The connection object.
 * @see {@link XHRConnectOptions}
 */
exports.createXHRConnection = function(host, port, options) {
  return new XHRConnection(host, port, options);
};

exports.createXHRClient = createClient;


/***/ }),

/***/ 384:
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ 5955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(2584);
var isGeneratorFunction = __webpack_require__(8662);
var whichTypedArray = __webpack_require__(6430);
var isTypedArray = __webpack_require__(5692);

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
isSharedArrayBufferToString.working = (
  typeof SharedArrayBuffer !== 'undefined' &&
  isSharedArrayBufferToString(new SharedArrayBuffer())
);
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBuffer === 'undefined') {
    return false;
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBuffer;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ 9539:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (({"BROWSER":true}).NODE_DEBUG) {
  var debugEnv = ({"BROWSER":true}).NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(5955);

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(384);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(5717);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ 6430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(9804);
var availableTypedArrays = __webpack_require__(6314);
var callBound = __webpack_require__(8914);

var $toString = callBound('Object.prototype.toString');
var hasSymbols = __webpack_require__(1405)();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = __webpack_require__(4079);
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof __webpack_require__.g[typedArray] === 'function') {
			var arr = new __webpack_require__.g[typedArray]();
			if (!(Symbol.toStringTag in arr)) {
				throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
			}
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = __webpack_require__(5692);

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};


/***/ }),

/***/ 4221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(9262);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);

const common_ttypes = __webpack_require__(2818);
const completion_hints_ttypes = __webpack_require__(4494);
const serialized_result_set_ttypes = __webpack_require__(3962);
const extension_functions_ttypes = __webpack_require__(1396);


const ttypes = __webpack_require__(2607);
//HELPER FUNCTIONS AND STRUCTURES

const Heavy_connect_args = class {
  constructor(args) {
    this.user = null;
    this.passwd = null;
    this.dbname = null;
    if (args) {
      if (args.user !== undefined && args.user !== null) {
        this.user = args.user;
      }
      if (args.passwd !== undefined && args.passwd !== null) {
        this.passwd = args.passwd;
      }
      if (args.dbname !== undefined && args.dbname !== null) {
        this.dbname = args.dbname;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.user = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.passwd = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.dbname = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_connect_args');
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRING, 1);
      output.writeString(this.user);
      output.writeFieldEnd();
    }
    if (this.passwd !== null && this.passwd !== undefined) {
      output.writeFieldBegin('passwd', Thrift.Type.STRING, 2);
      output.writeString(this.passwd);
      output.writeFieldEnd();
    }
    if (this.dbname !== null && this.dbname !== undefined) {
      output.writeFieldBegin('dbname', Thrift.Type.STRING, 3);
      output.writeString(this.dbname);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_connect_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_connect_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_krb5_connect_args = class {
  constructor(args) {
    this.inputToken = null;
    this.dbname = null;
    if (args) {
      if (args.inputToken !== undefined && args.inputToken !== null) {
        this.inputToken = args.inputToken;
      }
      if (args.dbname !== undefined && args.dbname !== null) {
        this.dbname = args.dbname;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.inputToken = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dbname = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_krb5_connect_args');
    if (this.inputToken !== null && this.inputToken !== undefined) {
      output.writeFieldBegin('inputToken', Thrift.Type.STRING, 1);
      output.writeString(this.inputToken);
      output.writeFieldEnd();
    }
    if (this.dbname !== null && this.dbname !== undefined) {
      output.writeFieldBegin('dbname', Thrift.Type.STRING, 2);
      output.writeString(this.dbname);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_krb5_connect_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TKrb5Session(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TKrb5Session();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_krb5_connect_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_disconnect_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_disconnect_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_disconnect_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_disconnect_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_switch_database_args = class {
  constructor(args) {
    this.session = null;
    this.dbname = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dbname !== undefined && args.dbname !== null) {
        this.dbname = args.dbname;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dbname = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_switch_database_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dbname !== null && this.dbname !== undefined) {
      output.writeFieldBegin('dbname', Thrift.Type.STRING, 2);
      output.writeString(this.dbname);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_switch_database_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_switch_database_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clone_session_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clone_session_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clone_session_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clone_session_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_server_status_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_server_status_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_server_status_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TServerStatus(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TServerStatus();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_server_status_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_status_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_status_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_status_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TServerStatus]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3201 = input.readListBegin();
          const _size200 = _rtmp3201.size || 0;
          for (let _i202 = 0; _i202 < _size200; ++_i202) {
            let elem203 = null;
            elem203 = new ttypes.TServerStatus();
            elem203.read(input);
            this.success.push(elem203);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_status_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter204 in this.success) {
        if (this.success.hasOwnProperty(iter204)) {
          iter204 = this.success[iter204];
          iter204.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_hardware_info_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_hardware_info_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_hardware_info_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TClusterHardwareInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TClusterHardwareInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_hardware_info_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3206 = input.readListBegin();
          const _size205 = _rtmp3206.size || 0;
          for (let _i207 = 0; _i207 < _size205; ++_i207) {
            let elem208 = null;
            elem208 = input.readString();
            this.success.push(elem208);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter209 in this.success) {
        if (this.success.hasOwnProperty(iter209)) {
          iter209 = this.success[iter209];
          output.writeString(iter209);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_for_database_args = class {
  constructor(args) {
    this.session = null;
    this.database_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.database_name !== undefined && args.database_name !== null) {
        this.database_name = args.database_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.database_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_for_database_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.database_name !== null && this.database_name !== undefined) {
      output.writeFieldBegin('database_name', Thrift.Type.STRING, 2);
      output.writeString(this.database_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_for_database_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3211 = input.readListBegin();
          const _size210 = _rtmp3211.size || 0;
          for (let _i212 = 0; _i212 < _size210; ++_i212) {
            let elem213 = null;
            elem213 = input.readString();
            this.success.push(elem213);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_for_database_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter214 in this.success) {
        if (this.success.hasOwnProperty(iter214)) {
          iter214 = this.success[iter214];
          output.writeString(iter214);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_physical_tables_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_physical_tables_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_physical_tables_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3216 = input.readListBegin();
          const _size215 = _rtmp3216.size || 0;
          for (let _i217 = 0; _i217 < _size215; ++_i217) {
            let elem218 = null;
            elem218 = input.readString();
            this.success.push(elem218);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_physical_tables_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter219 in this.success) {
        if (this.success.hasOwnProperty(iter219)) {
          iter219 = this.success[iter219];
          output.writeString(iter219);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_views_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_views_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_views_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3221 = input.readListBegin();
          const _size220 = _rtmp3221.size || 0;
          for (let _i222 = 0; _i222 < _size220; ++_i222) {
            let elem223 = null;
            elem223 = input.readString();
            this.success.push(elem223);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_views_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter224 in this.success) {
        if (this.success.hasOwnProperty(iter224)) {
          iter224 = this.success[iter224];
          output.writeString(iter224);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_meta_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_meta_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_meta_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TTableMeta]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3226 = input.readListBegin();
          const _size225 = _rtmp3226.size || 0;
          for (let _i227 = 0; _i227 < _size225; ++_i227) {
            let elem228 = null;
            elem228 = new ttypes.TTableMeta();
            elem228.read(input);
            this.success.push(elem228);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_meta_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter229 in this.success) {
        if (this.success.hasOwnProperty(iter229)) {
          iter229 = this.success[iter229];
          iter229.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_details_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_details_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_details_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableDetails(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableDetails();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_details_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_details_for_database_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.database_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.database_name !== undefined && args.database_name !== null) {
        this.database_name = args.database_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.database_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_details_for_database_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.database_name !== null && this.database_name !== undefined) {
      output.writeFieldBegin('database_name', Thrift.Type.STRING, 3);
      output.writeString(this.database_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_details_for_database_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableDetails(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableDetails();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_details_for_database_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_internal_table_details_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.include_system_columns = true;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.include_system_columns !== undefined && args.include_system_columns !== null) {
        this.include_system_columns = args.include_system_columns;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.include_system_columns = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_internal_table_details_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.include_system_columns !== null && this.include_system_columns !== undefined) {
      output.writeFieldBegin('include_system_columns', Thrift.Type.BOOL, 3);
      output.writeBool(this.include_system_columns);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_internal_table_details_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableDetails(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableDetails();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_internal_table_details_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_internal_table_details_for_database_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.database_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.database_name !== undefined && args.database_name !== null) {
        this.database_name = args.database_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.database_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_internal_table_details_for_database_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.database_name !== null && this.database_name !== undefined) {
      output.writeFieldBegin('database_name', Thrift.Type.STRING, 3);
      output.writeString(this.database_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_internal_table_details_for_database_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableDetails(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableDetails();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_internal_table_details_for_database_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_users_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_users_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_users_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3231 = input.readListBegin();
          const _size230 = _rtmp3231.size || 0;
          for (let _i232 = 0; _i232 < _size230; ++_i232) {
            let elem233 = null;
            elem233 = input.readString();
            this.success.push(elem233);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_users_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter234 in this.success) {
        if (this.success.hasOwnProperty(iter234)) {
          iter234 = this.success[iter234];
          output.writeString(iter234);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_databases_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_databases_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_databases_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDBInfo]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3236 = input.readListBegin();
          const _size235 = _rtmp3236.size || 0;
          for (let _i237 = 0; _i237 < _size235; ++_i237) {
            let elem238 = null;
            elem238 = new ttypes.TDBInfo();
            elem238.read(input);
            this.success.push(elem238);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_databases_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter239 in this.success) {
        if (this.success.hasOwnProperty(iter239)) {
          iter239 = this.success[iter239];
          iter239.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_version_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_version_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_version_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_version_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_heap_profile_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_heap_profile_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_heap_profile_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_heap_profile_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_stop_heap_profile_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_stop_heap_profile_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_stop_heap_profile_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_stop_heap_profile_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_heap_profile_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_heap_profile_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_heap_profile_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_heap_profile_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_memory_args = class {
  constructor(args) {
    this.session = null;
    this.memory_level = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.memory_level !== undefined && args.memory_level !== null) {
        this.memory_level = args.memory_level;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.memory_level = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_memory_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.memory_level !== null && this.memory_level !== undefined) {
      output.writeFieldBegin('memory_level', Thrift.Type.STRING, 2);
      output.writeString(this.memory_level);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_memory_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TNodeMemoryInfo]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3241 = input.readListBegin();
          const _size240 = _rtmp3241.size || 0;
          for (let _i242 = 0; _i242 < _size240; ++_i242) {
            let elem243 = null;
            elem243 = new ttypes.TNodeMemoryInfo();
            elem243.read(input);
            this.success.push(elem243);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_memory_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter244 in this.success) {
        if (this.success.hasOwnProperty(iter244)) {
          iter244 = this.success[iter244];
          iter244.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clear_cpu_memory_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clear_cpu_memory_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clear_cpu_memory_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clear_cpu_memory_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clear_gpu_memory_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clear_gpu_memory_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clear_gpu_memory_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clear_gpu_memory_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_cur_session_args = class {
  constructor(args) {
    this.parent_session = null;
    this.leaf_session = null;
    this.start_time_str = null;
    this.label = null;
    this.for_running_query_kernel = null;
    if (args) {
      if (args.parent_session !== undefined && args.parent_session !== null) {
        this.parent_session = args.parent_session;
      }
      if (args.leaf_session !== undefined && args.leaf_session !== null) {
        this.leaf_session = args.leaf_session;
      }
      if (args.start_time_str !== undefined && args.start_time_str !== null) {
        this.start_time_str = args.start_time_str;
      }
      if (args.label !== undefined && args.label !== null) {
        this.label = args.label;
      }
      if (args.for_running_query_kernel !== undefined && args.for_running_query_kernel !== null) {
        this.for_running_query_kernel = args.for_running_query_kernel;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.parent_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.leaf_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.start_time_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.label = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.for_running_query_kernel = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_cur_session_args');
    if (this.parent_session !== null && this.parent_session !== undefined) {
      output.writeFieldBegin('parent_session', Thrift.Type.STRING, 1);
      output.writeString(this.parent_session);
      output.writeFieldEnd();
    }
    if (this.leaf_session !== null && this.leaf_session !== undefined) {
      output.writeFieldBegin('leaf_session', Thrift.Type.STRING, 2);
      output.writeString(this.leaf_session);
      output.writeFieldEnd();
    }
    if (this.start_time_str !== null && this.start_time_str !== undefined) {
      output.writeFieldBegin('start_time_str', Thrift.Type.STRING, 3);
      output.writeString(this.start_time_str);
      output.writeFieldEnd();
    }
    if (this.label !== null && this.label !== undefined) {
      output.writeFieldBegin('label', Thrift.Type.STRING, 4);
      output.writeString(this.label);
      output.writeFieldEnd();
    }
    if (this.for_running_query_kernel !== null && this.for_running_query_kernel !== undefined) {
      output.writeFieldBegin('for_running_query_kernel', Thrift.Type.BOOL, 5);
      output.writeBool(this.for_running_query_kernel);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_cur_session_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_cur_session_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_invalidate_cur_session_args = class {
  constructor(args) {
    this.parent_session = null;
    this.leaf_session = null;
    this.start_time_str = null;
    this.label = null;
    this.for_running_query_kernel = null;
    if (args) {
      if (args.parent_session !== undefined && args.parent_session !== null) {
        this.parent_session = args.parent_session;
      }
      if (args.leaf_session !== undefined && args.leaf_session !== null) {
        this.leaf_session = args.leaf_session;
      }
      if (args.start_time_str !== undefined && args.start_time_str !== null) {
        this.start_time_str = args.start_time_str;
      }
      if (args.label !== undefined && args.label !== null) {
        this.label = args.label;
      }
      if (args.for_running_query_kernel !== undefined && args.for_running_query_kernel !== null) {
        this.for_running_query_kernel = args.for_running_query_kernel;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.parent_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.leaf_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.start_time_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.label = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.for_running_query_kernel = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_invalidate_cur_session_args');
    if (this.parent_session !== null && this.parent_session !== undefined) {
      output.writeFieldBegin('parent_session', Thrift.Type.STRING, 1);
      output.writeString(this.parent_session);
      output.writeFieldEnd();
    }
    if (this.leaf_session !== null && this.leaf_session !== undefined) {
      output.writeFieldBegin('leaf_session', Thrift.Type.STRING, 2);
      output.writeString(this.leaf_session);
      output.writeFieldEnd();
    }
    if (this.start_time_str !== null && this.start_time_str !== undefined) {
      output.writeFieldBegin('start_time_str', Thrift.Type.STRING, 3);
      output.writeString(this.start_time_str);
      output.writeFieldEnd();
    }
    if (this.label !== null && this.label !== undefined) {
      output.writeFieldBegin('label', Thrift.Type.STRING, 4);
      output.writeString(this.label);
      output.writeFieldEnd();
    }
    if (this.for_running_query_kernel !== null && this.for_running_query_kernel !== undefined) {
      output.writeFieldBegin('for_running_query_kernel', Thrift.Type.BOOL, 5);
      output.writeBool(this.for_running_query_kernel);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_invalidate_cur_session_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_invalidate_cur_session_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epoch_args = class {
  constructor(args) {
    this.session = null;
    this.db_id = null;
    this.table_id = null;
    this.new_epoch = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.new_epoch !== undefined && args.new_epoch !== null) {
        this.new_epoch = args.new_epoch;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.new_epoch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epoch_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 3);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.new_epoch !== null && this.new_epoch !== undefined) {
      output.writeFieldBegin('new_epoch', Thrift.Type.I32, 4);
      output.writeI32(this.new_epoch);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epoch_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epoch_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epoch_by_name_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.new_epoch = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.new_epoch !== undefined && args.new_epoch !== null) {
        this.new_epoch = args.new_epoch;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.new_epoch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epoch_by_name_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.new_epoch !== null && this.new_epoch !== undefined) {
      output.writeFieldBegin('new_epoch', Thrift.Type.I32, 3);
      output.writeI32(this.new_epoch);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epoch_by_name_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epoch_by_name_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epoch_args = class {
  constructor(args) {
    this.session = null;
    this.db_id = null;
    this.table_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epoch_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 3);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epoch_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epoch_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epoch_by_name_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epoch_by_name_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epoch_by_name_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epoch_by_name_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epochs_args = class {
  constructor(args) {
    this.session = null;
    this.db_id = null;
    this.table_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epochs_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 3);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epochs_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TTableEpochInfo]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3246 = input.readListBegin();
          const _size245 = _rtmp3246.size || 0;
          for (let _i247 = 0; _i247 < _size245; ++_i247) {
            let elem248 = null;
            elem248 = new ttypes.TTableEpochInfo();
            elem248.read(input);
            this.success.push(elem248);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epochs_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter249 in this.success) {
        if (this.success.hasOwnProperty(iter249)) {
          iter249 = this.success[iter249];
          iter249.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epochs_args = class {
  constructor(args) {
    this.session = null;
    this.db_id = null;
    this.table_epochs = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_epochs !== undefined && args.table_epochs !== null) {
        this.table_epochs = Thrift.copyList(args.table_epochs, [ttypes.TTableEpochInfo]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.table_epochs = [];
          const _rtmp3251 = input.readListBegin();
          const _size250 = _rtmp3251.size || 0;
          for (let _i252 = 0; _i252 < _size250; ++_i252) {
            let elem253 = null;
            elem253 = new ttypes.TTableEpochInfo();
            elem253.read(input);
            this.table_epochs.push(elem253);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epochs_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_epochs !== null && this.table_epochs !== undefined) {
      output.writeFieldBegin('table_epochs', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.table_epochs.length);
      for (let iter254 in this.table_epochs) {
        if (this.table_epochs.hasOwnProperty(iter254)) {
          iter254 = this.table_epochs[iter254];
          iter254.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epochs_result = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epochs_result');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_session_info_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_session_info_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_session_info_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TSessionInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TSessionInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_session_info_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_queries_info_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_queries_info_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_queries_info_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TQueryInfo]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3256 = input.readListBegin();
          const _size255 = _rtmp3256.size || 0;
          for (let _i257 = 0; _i257 < _size255; ++_i257) {
            let elem258 = null;
            elem258 = new ttypes.TQueryInfo();
            elem258.read(input);
            this.success.push(elem258);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_queries_info_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter259 in this.success) {
        if (this.success.hasOwnProperty(iter259)) {
          iter259 = this.success[iter259];
          iter259.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_leaf_info_args = class {
  constructor(args) {
    this.session = null;
    this.leaf_info = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.leaf_info !== undefined && args.leaf_info !== null) {
        this.leaf_info = new ttypes.TLeafInfo(args.leaf_info);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.leaf_info = new ttypes.TLeafInfo();
          this.leaf_info.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_leaf_info_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.leaf_info !== null && this.leaf_info !== undefined) {
      output.writeFieldBegin('leaf_info', Thrift.Type.STRUCT, 2);
      this.leaf_info.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_leaf_info_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_leaf_info_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    this.column_format = null;
    this.nonce = null;
    this.first_n = -1;
    this.at_most_n = -1;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
      if (args.column_format !== undefined && args.column_format !== null) {
        this.column_format = args.column_format;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
      if (args.first_n !== undefined && args.first_n !== null) {
        this.first_n = args.first_n;
      }
      if (args.at_most_n !== undefined && args.at_most_n !== null) {
        this.at_most_n = args.at_most_n;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.column_format = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.first_n = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.at_most_n = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    if (this.column_format !== null && this.column_format !== undefined) {
      output.writeFieldBegin('column_format', Thrift.Type.BOOL, 3);
      output.writeBool(this.column_format);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 4);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    if (this.first_n !== null && this.first_n !== undefined) {
      output.writeFieldBegin('first_n', Thrift.Type.I32, 5);
      output.writeI32(this.first_n);
      output.writeFieldEnd();
    }
    if (this.at_most_n !== null && this.at_most_n !== undefined) {
      output.writeFieldBegin('at_most_n', Thrift.Type.I32, 6);
      output.writeI32(this.at_most_n);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TQueryResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TQueryResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_df_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    this.device_type = null;
    this.device_id = 0;
    this.first_n = -1;
    this.transport_method = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
      if (args.device_type !== undefined && args.device_type !== null) {
        this.device_type = args.device_type;
      }
      if (args.device_id !== undefined && args.device_id !== null) {
        this.device_id = args.device_id;
      }
      if (args.first_n !== undefined && args.first_n !== null) {
        this.first_n = args.first_n;
      }
      if (args.transport_method !== undefined && args.transport_method !== null) {
        this.transport_method = args.transport_method;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.device_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.device_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.first_n = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.transport_method = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_df_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    if (this.device_type !== null && this.device_type !== undefined) {
      output.writeFieldBegin('device_type', Thrift.Type.I32, 3);
      output.writeI32(this.device_type);
      output.writeFieldEnd();
    }
    if (this.device_id !== null && this.device_id !== undefined) {
      output.writeFieldBegin('device_id', Thrift.Type.I32, 4);
      output.writeI32(this.device_id);
      output.writeFieldEnd();
    }
    if (this.first_n !== null && this.first_n !== undefined) {
      output.writeFieldBegin('first_n', Thrift.Type.I32, 5);
      output.writeI32(this.first_n);
      output.writeFieldEnd();
    }
    if (this.transport_method !== null && this.transport_method !== undefined) {
      output.writeFieldBegin('transport_method', Thrift.Type.I32, 6);
      output.writeI32(this.transport_method);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_df_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TDataFrame(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TDataFrame();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_df_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_gdf_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    this.device_id = 0;
    this.first_n = -1;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
      if (args.device_id !== undefined && args.device_id !== null) {
        this.device_id = args.device_id;
      }
      if (args.first_n !== undefined && args.first_n !== null) {
        this.first_n = args.first_n;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.device_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.first_n = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_gdf_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    if (this.device_id !== null && this.device_id !== undefined) {
      output.writeFieldBegin('device_id', Thrift.Type.I32, 3);
      output.writeI32(this.device_id);
      output.writeFieldEnd();
    }
    if (this.first_n !== null && this.first_n !== undefined) {
      output.writeFieldBegin('first_n', Thrift.Type.I32, 4);
      output.writeI32(this.first_n);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_gdf_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TDataFrame(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TDataFrame();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_gdf_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_deallocate_df_args = class {
  constructor(args) {
    this.session = null;
    this.df = null;
    this.device_type = null;
    this.device_id = 0;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.df !== undefined && args.df !== null) {
        this.df = new ttypes.TDataFrame(args.df);
      }
      if (args.device_type !== undefined && args.device_type !== null) {
        this.device_type = args.device_type;
      }
      if (args.device_id !== undefined && args.device_id !== null) {
        this.device_id = args.device_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.df = new ttypes.TDataFrame();
          this.df.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.device_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.device_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_deallocate_df_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.df !== null && this.df !== undefined) {
      output.writeFieldBegin('df', Thrift.Type.STRUCT, 2);
      this.df.write(output);
      output.writeFieldEnd();
    }
    if (this.device_type !== null && this.device_type !== undefined) {
      output.writeFieldBegin('device_type', Thrift.Type.I32, 3);
      output.writeI32(this.device_type);
      output.writeFieldEnd();
    }
    if (this.device_id !== null && this.device_id !== undefined) {
      output.writeFieldBegin('device_id', Thrift.Type.I32, 4);
      output.writeI32(this.device_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_deallocate_df_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_deallocate_df_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_interrupt_args = class {
  constructor(args) {
    this.query_session = null;
    this.interrupt_session = null;
    if (args) {
      if (args.query_session !== undefined && args.query_session !== null) {
        this.query_session = args.query_session;
      }
      if (args.interrupt_session !== undefined && args.interrupt_session !== null) {
        this.interrupt_session = args.interrupt_session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.query_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.interrupt_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_interrupt_args');
    if (this.query_session !== null && this.query_session !== undefined) {
      output.writeFieldBegin('query_session', Thrift.Type.STRING, 1);
      output.writeString(this.query_session);
      output.writeFieldEnd();
    }
    if (this.interrupt_session !== null && this.interrupt_session !== undefined) {
      output.writeFieldBegin('interrupt_session', Thrift.Type.STRING, 2);
      output.writeString(this.interrupt_session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_interrupt_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_interrupt_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_validate_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_validate_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_validate_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TColumnType]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3261 = input.readListBegin();
          const _size260 = _rtmp3261.size || 0;
          for (let _i262 = 0; _i262 < _size260; ++_i262) {
            let elem263 = null;
            elem263 = new ttypes.TColumnType();
            elem263.read(input);
            this.success.push(elem263);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_validate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter264 in this.success) {
        if (this.success.hasOwnProperty(iter264)) {
          iter264 = this.success[iter264];
          iter264.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_completion_hints_args = class {
  constructor(args) {
    this.session = null;
    this.sql = null;
    this.cursor = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.sql !== undefined && args.sql !== null) {
        this.sql = args.sql;
      }
      if (args.cursor !== undefined && args.cursor !== null) {
        this.cursor = args.cursor;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sql = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.cursor = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_completion_hints_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.sql !== null && this.sql !== undefined) {
      output.writeFieldBegin('sql', Thrift.Type.STRING, 2);
      output.writeString(this.sql);
      output.writeFieldEnd();
    }
    if (this.cursor !== null && this.cursor !== undefined) {
      output.writeFieldBegin('cursor', Thrift.Type.I32, 3);
      output.writeI32(this.cursor);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_completion_hints_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [completion_hints_ttypes.TCompletionHint]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3266 = input.readListBegin();
          const _size265 = _rtmp3266.size || 0;
          for (let _i267 = 0; _i267 < _size265; ++_i267) {
            let elem268 = null;
            elem268 = new completion_hints_ttypes.TCompletionHint();
            elem268.read(input);
            this.success.push(elem268);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_completion_hints_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter269 in this.success) {
        if (this.success.hasOwnProperty(iter269)) {
          iter269 = this.success[iter269];
          iter269.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_execution_mode_args = class {
  constructor(args) {
    this.session = null;
    this.mode = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.mode !== undefined && args.mode !== null) {
        this.mode = args.mode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.mode = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_execution_mode_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.mode !== null && this.mode !== undefined) {
      output.writeFieldBegin('mode', Thrift.Type.I32, 2);
      output.writeI32(this.mode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_execution_mode_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_execution_mode_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_render_vega_args = class {
  constructor(args) {
    this.session = null;
    this.widget_id = null;
    this.vega_json = null;
    this.compression_level = null;
    this.nonce = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.widget_id !== undefined && args.widget_id !== null) {
        this.widget_id = args.widget_id;
      }
      if (args.vega_json !== undefined && args.vega_json !== null) {
        this.vega_json = args.vega_json;
      }
      if (args.compression_level !== undefined && args.compression_level !== null) {
        this.compression_level = args.compression_level;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.widget_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.vega_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.compression_level = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_render_vega_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.widget_id !== null && this.widget_id !== undefined) {
      output.writeFieldBegin('widget_id', Thrift.Type.I64, 2);
      output.writeI64(this.widget_id);
      output.writeFieldEnd();
    }
    if (this.vega_json !== null && this.vega_json !== undefined) {
      output.writeFieldBegin('vega_json', Thrift.Type.STRING, 3);
      output.writeString(this.vega_json);
      output.writeFieldEnd();
    }
    if (this.compression_level !== null && this.compression_level !== undefined) {
      output.writeFieldBegin('compression_level', Thrift.Type.I32, 4);
      output.writeI32(this.compression_level);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 5);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_render_vega_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TRenderResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TRenderResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_render_vega_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_result_row_for_pixel_args = class {
  constructor(args) {
    this.session = null;
    this.widget_id = null;
    this.pixel = null;
    this.table_col_names = null;
    this.column_format = null;
    this.pixelRadius = null;
    this.nonce = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.widget_id !== undefined && args.widget_id !== null) {
        this.widget_id = args.widget_id;
      }
      if (args.pixel !== undefined && args.pixel !== null) {
        this.pixel = new ttypes.TPixel(args.pixel);
      }
      if (args.table_col_names !== undefined && args.table_col_names !== null) {
        this.table_col_names = Thrift.copyMap(args.table_col_names, [Thrift.copyList, null]);
      }
      if (args.column_format !== undefined && args.column_format !== null) {
        this.column_format = args.column_format;
      }
      if (args.pixelRadius !== undefined && args.pixelRadius !== null) {
        this.pixelRadius = args.pixelRadius;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.widget_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.pixel = new ttypes.TPixel();
          this.pixel.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.MAP) {
          this.table_col_names = {};
          const _rtmp3271 = input.readMapBegin();
          const _size270 = _rtmp3271.size || 0;
          for (let _i272 = 0; _i272 < _size270; ++_i272) {
            let key273 = null;
            let val274 = null;
            key273 = input.readString();
            val274 = [];
            const _rtmp3276 = input.readListBegin();
            const _size275 = _rtmp3276.size || 0;
            for (let _i277 = 0; _i277 < _size275; ++_i277) {
              let elem278 = null;
              elem278 = input.readString();
              val274.push(elem278);
            }
            input.readListEnd();
            this.table_col_names[key273] = val274;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.column_format = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.pixelRadius = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_result_row_for_pixel_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.widget_id !== null && this.widget_id !== undefined) {
      output.writeFieldBegin('widget_id', Thrift.Type.I64, 2);
      output.writeI64(this.widget_id);
      output.writeFieldEnd();
    }
    if (this.pixel !== null && this.pixel !== undefined) {
      output.writeFieldBegin('pixel', Thrift.Type.STRUCT, 3);
      this.pixel.write(output);
      output.writeFieldEnd();
    }
    if (this.table_col_names !== null && this.table_col_names !== undefined) {
      output.writeFieldBegin('table_col_names', Thrift.Type.MAP, 4);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.table_col_names));
      for (let kiter279 in this.table_col_names) {
        if (this.table_col_names.hasOwnProperty(kiter279)) {
          let viter280 = this.table_col_names[kiter279];
          output.writeString(kiter279);
          output.writeListBegin(Thrift.Type.STRING, viter280.length);
          for (let iter281 in viter280) {
            if (viter280.hasOwnProperty(iter281)) {
              iter281 = viter280[iter281];
              output.writeString(iter281);
            }
          }
          output.writeListEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.column_format !== null && this.column_format !== undefined) {
      output.writeFieldBegin('column_format', Thrift.Type.BOOL, 5);
      output.writeBool(this.column_format);
      output.writeFieldEnd();
    }
    if (this.pixelRadius !== null && this.pixelRadius !== undefined) {
      output.writeFieldBegin('pixelRadius', Thrift.Type.I32, 6);
      output.writeI32(this.pixelRadius);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 7);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_result_row_for_pixel_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TPixelTableRowResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TPixelTableRowResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_result_row_for_pixel_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_custom_expression_args = class {
  constructor(args) {
    this.session = null;
    this.custom_expression = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.custom_expression !== undefined && args.custom_expression !== null) {
        this.custom_expression = new ttypes.TCustomExpression(args.custom_expression);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.custom_expression = new ttypes.TCustomExpression();
          this.custom_expression.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_custom_expression_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.custom_expression !== null && this.custom_expression !== undefined) {
      output.writeFieldBegin('custom_expression', Thrift.Type.STRUCT, 2);
      this.custom_expression.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_custom_expression_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_custom_expression_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_custom_expressions_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_custom_expressions_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_custom_expressions_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TCustomExpression]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3283 = input.readListBegin();
          const _size282 = _rtmp3283.size || 0;
          for (let _i284 = 0; _i284 < _size282; ++_i284) {
            let elem285 = null;
            elem285 = new ttypes.TCustomExpression();
            elem285.read(input);
            this.success.push(elem285);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_custom_expressions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter286 in this.success) {
        if (this.success.hasOwnProperty(iter286)) {
          iter286 = this.success[iter286];
          iter286.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_update_custom_expression_args = class {
  constructor(args) {
    this.session = null;
    this.id = null;
    this.expression_json = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.expression_json !== undefined && args.expression_json !== null) {
        this.expression_json = args.expression_json;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.expression_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_update_custom_expression_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.I32, 2);
      output.writeI32(this.id);
      output.writeFieldEnd();
    }
    if (this.expression_json !== null && this.expression_json !== undefined) {
      output.writeFieldBegin('expression_json', Thrift.Type.STRING, 3);
      output.writeString(this.expression_json);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_update_custom_expression_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_update_custom_expression_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_custom_expressions_args = class {
  constructor(args) {
    this.session = null;
    this.custom_expression_ids = null;
    this.do_soft_delete = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.custom_expression_ids !== undefined && args.custom_expression_ids !== null) {
        this.custom_expression_ids = Thrift.copyList(args.custom_expression_ids, [null]);
      }
      if (args.do_soft_delete !== undefined && args.do_soft_delete !== null) {
        this.do_soft_delete = args.do_soft_delete;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.custom_expression_ids = [];
          const _rtmp3288 = input.readListBegin();
          const _size287 = _rtmp3288.size || 0;
          for (let _i289 = 0; _i289 < _size287; ++_i289) {
            let elem290 = null;
            elem290 = input.readI32();
            this.custom_expression_ids.push(elem290);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.do_soft_delete = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_custom_expressions_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.custom_expression_ids !== null && this.custom_expression_ids !== undefined) {
      output.writeFieldBegin('custom_expression_ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.custom_expression_ids.length);
      for (let iter291 in this.custom_expression_ids) {
        if (this.custom_expression_ids.hasOwnProperty(iter291)) {
          iter291 = this.custom_expression_ids[iter291];
          output.writeI32(iter291);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.do_soft_delete !== null && this.do_soft_delete !== undefined) {
      output.writeFieldBegin('do_soft_delete', Thrift.Type.BOOL, 3);
      output.writeBool(this.do_soft_delete);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_custom_expressions_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_custom_expressions_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboard_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TDashboard(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TDashboard();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboard_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboards_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboards_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboards_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDashboard]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3293 = input.readListBegin();
          const _size292 = _rtmp3293.size || 0;
          for (let _i294 = 0; _i294 < _size292; ++_i294) {
            let elem295 = null;
            elem295 = new ttypes.TDashboard();
            elem295.read(input);
            this.success.push(elem295);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboards_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter296 in this.success) {
        if (this.success.hasOwnProperty(iter296)) {
          iter296 = this.success[iter296];
          iter296.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_name = null;
    this.dashboard_state = null;
    this.image_hash = null;
    this.dashboard_metadata = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_name !== undefined && args.dashboard_name !== null) {
        this.dashboard_name = args.dashboard_name;
      }
      if (args.dashboard_state !== undefined && args.dashboard_state !== null) {
        this.dashboard_state = args.dashboard_state;
      }
      if (args.image_hash !== undefined && args.image_hash !== null) {
        this.image_hash = args.image_hash;
      }
      if (args.dashboard_metadata !== undefined && args.dashboard_metadata !== null) {
        this.dashboard_metadata = args.dashboard_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.image_hash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_name !== null && this.dashboard_name !== undefined) {
      output.writeFieldBegin('dashboard_name', Thrift.Type.STRING, 2);
      output.writeString(this.dashboard_name);
      output.writeFieldEnd();
    }
    if (this.dashboard_state !== null && this.dashboard_state !== undefined) {
      output.writeFieldBegin('dashboard_state', Thrift.Type.STRING, 3);
      output.writeString(this.dashboard_state);
      output.writeFieldEnd();
    }
    if (this.image_hash !== null && this.image_hash !== undefined) {
      output.writeFieldBegin('image_hash', Thrift.Type.STRING, 4);
      output.writeString(this.image_hash);
      output.writeFieldEnd();
    }
    if (this.dashboard_metadata !== null && this.dashboard_metadata !== undefined) {
      output.writeFieldBegin('dashboard_metadata', Thrift.Type.STRING, 5);
      output.writeString(this.dashboard_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_dashboard_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_dashboard_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_replace_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    this.dashboard_name = null;
    this.dashboard_owner = null;
    this.dashboard_state = null;
    this.image_hash = null;
    this.dashboard_metadata = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
      if (args.dashboard_name !== undefined && args.dashboard_name !== null) {
        this.dashboard_name = args.dashboard_name;
      }
      if (args.dashboard_owner !== undefined && args.dashboard_owner !== null) {
        this.dashboard_owner = args.dashboard_owner;
      }
      if (args.dashboard_state !== undefined && args.dashboard_state !== null) {
        this.dashboard_state = args.dashboard_state;
      }
      if (args.image_hash !== undefined && args.image_hash !== null) {
        this.image_hash = args.image_hash;
      }
      if (args.dashboard_metadata !== undefined && args.dashboard_metadata !== null) {
        this.dashboard_metadata = args.dashboard_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_owner = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.image_hash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_replace_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    if (this.dashboard_name !== null && this.dashboard_name !== undefined) {
      output.writeFieldBegin('dashboard_name', Thrift.Type.STRING, 3);
      output.writeString(this.dashboard_name);
      output.writeFieldEnd();
    }
    if (this.dashboard_owner !== null && this.dashboard_owner !== undefined) {
      output.writeFieldBegin('dashboard_owner', Thrift.Type.STRING, 4);
      output.writeString(this.dashboard_owner);
      output.writeFieldEnd();
    }
    if (this.dashboard_state !== null && this.dashboard_state !== undefined) {
      output.writeFieldBegin('dashboard_state', Thrift.Type.STRING, 5);
      output.writeString(this.dashboard_state);
      output.writeFieldEnd();
    }
    if (this.image_hash !== null && this.image_hash !== undefined) {
      output.writeFieldBegin('image_hash', Thrift.Type.STRING, 6);
      output.writeString(this.image_hash);
      output.writeFieldEnd();
    }
    if (this.dashboard_metadata !== null && this.dashboard_metadata !== undefined) {
      output.writeFieldBegin('dashboard_metadata', Thrift.Type.STRING, 7);
      output.writeString(this.dashboard_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_replace_dashboard_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_replace_dashboard_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_dashboard_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_dashboard_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_share_dashboards_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_ids = null;
    this.groups = null;
    this.permissions = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_ids !== undefined && args.dashboard_ids !== null) {
        this.dashboard_ids = Thrift.copyList(args.dashboard_ids, [null]);
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [null]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.dashboard_ids = [];
          const _rtmp3298 = input.readListBegin();
          const _size297 = _rtmp3298.size || 0;
          for (let _i299 = 0; _i299 < _size297; ++_i299) {
            let elem300 = null;
            elem300 = input.readI32();
            this.dashboard_ids.push(elem300);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp3302 = input.readListBegin();
          const _size301 = _rtmp3302.size || 0;
          for (let _i303 = 0; _i303 < _size301; ++_i303) {
            let elem304 = null;
            elem304 = input.readString();
            this.groups.push(elem304);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_share_dashboards_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_ids !== null && this.dashboard_ids !== undefined) {
      output.writeFieldBegin('dashboard_ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.dashboard_ids.length);
      for (let iter305 in this.dashboard_ids) {
        if (this.dashboard_ids.hasOwnProperty(iter305)) {
          iter305 = this.dashboard_ids[iter305];
          output.writeI32(iter305);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.groups.length);
      for (let iter306 in this.groups) {
        if (this.groups.hasOwnProperty(iter306)) {
          iter306 = this.groups[iter306];
          output.writeString(iter306);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 4);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_share_dashboards_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_share_dashboards_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_dashboards_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_ids = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_ids !== undefined && args.dashboard_ids !== null) {
        this.dashboard_ids = Thrift.copyList(args.dashboard_ids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.dashboard_ids = [];
          const _rtmp3308 = input.readListBegin();
          const _size307 = _rtmp3308.size || 0;
          for (let _i309 = 0; _i309 < _size307; ++_i309) {
            let elem310 = null;
            elem310 = input.readI32();
            this.dashboard_ids.push(elem310);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_dashboards_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_ids !== null && this.dashboard_ids !== undefined) {
      output.writeFieldBegin('dashboard_ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.dashboard_ids.length);
      for (let iter311 in this.dashboard_ids) {
        if (this.dashboard_ids.hasOwnProperty(iter311)) {
          iter311 = this.dashboard_ids[iter311];
          output.writeI32(iter311);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_dashboards_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_dashboards_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_share_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    this.groups = null;
    this.objects = null;
    this.permissions = null;
    this.grant_role = false;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [null]);
      }
      if (args.objects !== undefined && args.objects !== null) {
        this.objects = Thrift.copyList(args.objects, [null]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
      if (args.grant_role !== undefined && args.grant_role !== null) {
        this.grant_role = args.grant_role;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp3313 = input.readListBegin();
          const _size312 = _rtmp3313.size || 0;
          for (let _i314 = 0; _i314 < _size312; ++_i314) {
            let elem315 = null;
            elem315 = input.readString();
            this.groups.push(elem315);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.objects = [];
          const _rtmp3317 = input.readListBegin();
          const _size316 = _rtmp3317.size || 0;
          for (let _i318 = 0; _i318 < _size316; ++_i318) {
            let elem319 = null;
            elem319 = input.readString();
            this.objects.push(elem319);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.grant_role = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_share_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.groups.length);
      for (let iter320 in this.groups) {
        if (this.groups.hasOwnProperty(iter320)) {
          iter320 = this.groups[iter320];
          output.writeString(iter320);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.objects !== null && this.objects !== undefined) {
      output.writeFieldBegin('objects', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.objects.length);
      for (let iter321 in this.objects) {
        if (this.objects.hasOwnProperty(iter321)) {
          iter321 = this.objects[iter321];
          output.writeString(iter321);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 5);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    if (this.grant_role !== null && this.grant_role !== undefined) {
      output.writeFieldBegin('grant_role', Thrift.Type.BOOL, 6);
      output.writeBool(this.grant_role);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_share_dashboard_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_share_dashboard_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_unshare_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    this.groups = null;
    this.objects = null;
    this.permissions = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [null]);
      }
      if (args.objects !== undefined && args.objects !== null) {
        this.objects = Thrift.copyList(args.objects, [null]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp3323 = input.readListBegin();
          const _size322 = _rtmp3323.size || 0;
          for (let _i324 = 0; _i324 < _size322; ++_i324) {
            let elem325 = null;
            elem325 = input.readString();
            this.groups.push(elem325);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.objects = [];
          const _rtmp3327 = input.readListBegin();
          const _size326 = _rtmp3327.size || 0;
          for (let _i328 = 0; _i328 < _size326; ++_i328) {
            let elem329 = null;
            elem329 = input.readString();
            this.objects.push(elem329);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_unshare_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.groups.length);
      for (let iter330 in this.groups) {
        if (this.groups.hasOwnProperty(iter330)) {
          iter330 = this.groups[iter330];
          output.writeString(iter330);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.objects !== null && this.objects !== undefined) {
      output.writeFieldBegin('objects', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.objects.length);
      for (let iter331 in this.objects) {
        if (this.objects.hasOwnProperty(iter331)) {
          iter331 = this.objects[iter331];
          output.writeString(iter331);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 5);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_unshare_dashboard_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_unshare_dashboard_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_unshare_dashboards_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_ids = null;
    this.groups = null;
    this.permissions = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_ids !== undefined && args.dashboard_ids !== null) {
        this.dashboard_ids = Thrift.copyList(args.dashboard_ids, [null]);
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [null]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.dashboard_ids = [];
          const _rtmp3333 = input.readListBegin();
          const _size332 = _rtmp3333.size || 0;
          for (let _i334 = 0; _i334 < _size332; ++_i334) {
            let elem335 = null;
            elem335 = input.readI32();
            this.dashboard_ids.push(elem335);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp3337 = input.readListBegin();
          const _size336 = _rtmp3337.size || 0;
          for (let _i338 = 0; _i338 < _size336; ++_i338) {
            let elem339 = null;
            elem339 = input.readString();
            this.groups.push(elem339);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_unshare_dashboards_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_ids !== null && this.dashboard_ids !== undefined) {
      output.writeFieldBegin('dashboard_ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.dashboard_ids.length);
      for (let iter340 in this.dashboard_ids) {
        if (this.dashboard_ids.hasOwnProperty(iter340)) {
          iter340 = this.dashboard_ids[iter340];
          output.writeI32(iter340);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.groups.length);
      for (let iter341 in this.groups) {
        if (this.groups.hasOwnProperty(iter341)) {
          iter341 = this.groups[iter341];
          output.writeString(iter341);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 4);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_unshare_dashboards_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_unshare_dashboards_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboard_grantees_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboard_grantees_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboard_grantees_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDashboardGrantees]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3343 = input.readListBegin();
          const _size342 = _rtmp3343.size || 0;
          for (let _i344 = 0; _i344 < _size342; ++_i344) {
            let elem345 = null;
            elem345 = new ttypes.TDashboardGrantees();
            elem345.read(input);
            this.success.push(elem345);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboard_grantees_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter346 in this.success) {
        if (this.success.hasOwnProperty(iter346)) {
          iter346 = this.success[iter346];
          iter346.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_link_view_args = class {
  constructor(args) {
    this.session = null;
    this.link = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.link !== undefined && args.link !== null) {
        this.link = args.link;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.link = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_link_view_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.link !== null && this.link !== undefined) {
      output.writeFieldBegin('link', Thrift.Type.STRING, 2);
      output.writeString(this.link);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_link_view_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TFrontendView(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TFrontendView();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_link_view_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_link_args = class {
  constructor(args) {
    this.session = null;
    this.view_state = null;
    this.view_metadata = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.view_state !== undefined && args.view_state !== null) {
        this.view_state = args.view_state;
      }
      if (args.view_metadata !== undefined && args.view_metadata !== null) {
        this.view_metadata = args.view_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.view_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.view_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_link_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.view_state !== null && this.view_state !== undefined) {
      output.writeFieldBegin('view_state', Thrift.Type.STRING, 2);
      output.writeString(this.view_state);
      output.writeFieldEnd();
    }
    if (this.view_metadata !== null && this.view_metadata !== undefined) {
      output.writeFieldBegin('view_metadata', Thrift.Type.STRING, 3);
      output.writeString(this.view_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_link_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_link_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.rows = null;
    this.column_names = [];
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.rows !== undefined && args.rows !== null) {
        this.rows = Thrift.copyList(args.rows, [ttypes.TRow]);
      }
      if (args.column_names !== undefined && args.column_names !== null) {
        this.column_names = Thrift.copyList(args.column_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.rows = [];
          const _rtmp3348 = input.readListBegin();
          const _size347 = _rtmp3348.size || 0;
          for (let _i349 = 0; _i349 < _size347; ++_i349) {
            let elem350 = null;
            elem350 = new ttypes.TRow();
            elem350.read(input);
            this.rows.push(elem350);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.column_names = [];
          const _rtmp3352 = input.readListBegin();
          const _size351 = _rtmp3352.size || 0;
          for (let _i353 = 0; _i353 < _size351; ++_i353) {
            let elem354 = null;
            elem354 = input.readString();
            this.column_names.push(elem354);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.rows !== null && this.rows !== undefined) {
      output.writeFieldBegin('rows', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.rows.length);
      for (let iter355 in this.rows) {
        if (this.rows.hasOwnProperty(iter355)) {
          iter355 = this.rows[iter355];
          iter355.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.column_names !== null && this.column_names !== undefined) {
      output.writeFieldBegin('column_names', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.column_names.length);
      for (let iter356 in this.column_names) {
        if (this.column_names.hasOwnProperty(iter356)) {
          iter356 = this.column_names[iter356];
          output.writeString(iter356);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_columnar_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.cols = null;
    this.column_names = [];
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.cols !== undefined && args.cols !== null) {
        this.cols = Thrift.copyList(args.cols, [ttypes.TColumn]);
      }
      if (args.column_names !== undefined && args.column_names !== null) {
        this.column_names = Thrift.copyList(args.column_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.cols = [];
          const _rtmp3358 = input.readListBegin();
          const _size357 = _rtmp3358.size || 0;
          for (let _i359 = 0; _i359 < _size357; ++_i359) {
            let elem360 = null;
            elem360 = new ttypes.TColumn();
            elem360.read(input);
            this.cols.push(elem360);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.column_names = [];
          const _rtmp3362 = input.readListBegin();
          const _size361 = _rtmp3362.size || 0;
          for (let _i363 = 0; _i363 < _size361; ++_i363) {
            let elem364 = null;
            elem364 = input.readString();
            this.column_names.push(elem364);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_columnar_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.cols !== null && this.cols !== undefined) {
      output.writeFieldBegin('cols', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.cols.length);
      for (let iter365 in this.cols) {
        if (this.cols.hasOwnProperty(iter365)) {
          iter365 = this.cols[iter365];
          iter365.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.column_names !== null && this.column_names !== undefined) {
      output.writeFieldBegin('column_names', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.column_names.length);
      for (let iter366 in this.column_names) {
        if (this.column_names.hasOwnProperty(iter366)) {
          iter366 = this.column_names[iter366];
          output.writeString(iter366);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_columnar_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_columnar_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_columnar_polys_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.cols = null;
    this.column_names = [];
    this.assign_render_groups = true;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.cols !== undefined && args.cols !== null) {
        this.cols = Thrift.copyList(args.cols, [ttypes.TColumn]);
      }
      if (args.column_names !== undefined && args.column_names !== null) {
        this.column_names = Thrift.copyList(args.column_names, [null]);
      }
      if (args.assign_render_groups !== undefined && args.assign_render_groups !== null) {
        this.assign_render_groups = args.assign_render_groups;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.cols = [];
          const _rtmp3368 = input.readListBegin();
          const _size367 = _rtmp3368.size || 0;
          for (let _i369 = 0; _i369 < _size367; ++_i369) {
            let elem370 = null;
            elem370 = new ttypes.TColumn();
            elem370.read(input);
            this.cols.push(elem370);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.column_names = [];
          const _rtmp3372 = input.readListBegin();
          const _size371 = _rtmp3372.size || 0;
          for (let _i373 = 0; _i373 < _size371; ++_i373) {
            let elem374 = null;
            elem374 = input.readString();
            this.column_names.push(elem374);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.assign_render_groups = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_columnar_polys_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.cols !== null && this.cols !== undefined) {
      output.writeFieldBegin('cols', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.cols.length);
      for (let iter375 in this.cols) {
        if (this.cols.hasOwnProperty(iter375)) {
          iter375 = this.cols[iter375];
          iter375.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.column_names !== null && this.column_names !== undefined) {
      output.writeFieldBegin('column_names', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.column_names.length);
      for (let iter376 in this.column_names) {
        if (this.column_names.hasOwnProperty(iter376)) {
          iter376 = this.column_names[iter376];
          output.writeString(iter376);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.assign_render_groups !== null && this.assign_render_groups !== undefined) {
      output.writeFieldBegin('assign_render_groups', Thrift.Type.BOOL, 5);
      output.writeBool(this.assign_render_groups);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_columnar_polys_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_columnar_polys_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_arrow_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.arrow_stream = null;
    this.use_column_names = false;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.arrow_stream !== undefined && args.arrow_stream !== null) {
        this.arrow_stream = args.arrow_stream;
      }
      if (args.use_column_names !== undefined && args.use_column_names !== null) {
        this.use_column_names = args.use_column_names;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.arrow_stream = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.use_column_names = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_arrow_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.arrow_stream !== null && this.arrow_stream !== undefined) {
      output.writeFieldBegin('arrow_stream', Thrift.Type.STRING, 3);
      output.writeBinary(this.arrow_stream);
      output.writeFieldEnd();
    }
    if (this.use_column_names !== null && this.use_column_names !== undefined) {
      output.writeFieldBegin('use_column_names', Thrift.Type.BOOL, 4);
      output.writeBool(this.use_column_names);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_arrow_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_arrow_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.rows = null;
    this.column_names = [];
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.rows !== undefined && args.rows !== null) {
        this.rows = Thrift.copyList(args.rows, [ttypes.TStringRow]);
      }
      if (args.column_names !== undefined && args.column_names !== null) {
        this.column_names = Thrift.copyList(args.column_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.rows = [];
          const _rtmp3378 = input.readListBegin();
          const _size377 = _rtmp3378.size || 0;
          for (let _i379 = 0; _i379 < _size377; ++_i379) {
            let elem380 = null;
            elem380 = new ttypes.TStringRow();
            elem380.read(input);
            this.rows.push(elem380);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.column_names = [];
          const _rtmp3382 = input.readListBegin();
          const _size381 = _rtmp3382.size || 0;
          for (let _i383 = 0; _i383 < _size381; ++_i383) {
            let elem384 = null;
            elem384 = input.readString();
            this.column_names.push(elem384);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.rows !== null && this.rows !== undefined) {
      output.writeFieldBegin('rows', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.rows.length);
      for (let iter385 in this.rows) {
        if (this.rows.hasOwnProperty(iter385)) {
          iter385 = this.rows[iter385];
          iter385.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.column_names !== null && this.column_names !== undefined) {
      output.writeFieldBegin('column_names', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.column_names.length);
      for (let iter386 in this.column_names) {
        if (this.column_names.hasOwnProperty(iter386)) {
          iter386 = this.column_names[iter386];
          output.writeString(iter386);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_detect_column_types_args = class {
  constructor(args) {
    this.session = null;
    this.file_name = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.file_name !== undefined && args.file_name !== null) {
        this.file_name = args.file_name;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.file_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_detect_column_types_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.file_name !== null && this.file_name !== undefined) {
      output.writeFieldBegin('file_name', Thrift.Type.STRING, 2);
      output.writeString(this.file_name);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 3);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_detect_column_types_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TDetectResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TDetectResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_detect_column_types_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_table_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.row_desc = null;
    this.create_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.create_params !== undefined && args.create_params !== null) {
        this.create_params = new ttypes.TCreateParams(args.create_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp3388 = input.readListBegin();
          const _size387 = _rtmp3388.size || 0;
          for (let _i389 = 0; _i389 < _size387; ++_i389) {
            let elem390 = null;
            elem390 = new ttypes.TColumnType();
            elem390.read(input);
            this.row_desc.push(elem390);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.create_params = new ttypes.TCreateParams();
          this.create_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_table_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter391 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter391)) {
          iter391 = this.row_desc[iter391];
          iter391.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.create_params !== null && this.create_params !== undefined) {
      output.writeFieldBegin('create_params', Thrift.Type.STRUCT, 4);
      this.create_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_table_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_table_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_table_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.file_name = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.file_name !== undefined && args.file_name !== null) {
        this.file_name = args.file_name;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.file_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_table_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.file_name !== null && this.file_name !== undefined) {
      output.writeFieldBegin('file_name', Thrift.Type.STRING, 3);
      output.writeString(this.file_name);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 4);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_table_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_table_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_geo_table_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.file_name = null;
    this.copy_params = null;
    this.row_desc = null;
    this.create_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.file_name !== undefined && args.file_name !== null) {
        this.file_name = args.file_name;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.create_params !== undefined && args.create_params !== null) {
        this.create_params = new ttypes.TCreateParams(args.create_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.file_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp3393 = input.readListBegin();
          const _size392 = _rtmp3393.size || 0;
          for (let _i394 = 0; _i394 < _size392; ++_i394) {
            let elem395 = null;
            elem395 = new ttypes.TColumnType();
            elem395.read(input);
            this.row_desc.push(elem395);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.create_params = new ttypes.TCreateParams();
          this.create_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_geo_table_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.file_name !== null && this.file_name !== undefined) {
      output.writeFieldBegin('file_name', Thrift.Type.STRING, 3);
      output.writeString(this.file_name);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 4);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter396 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter396)) {
          iter396 = this.row_desc[iter396];
          iter396.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.create_params !== null && this.create_params !== undefined) {
      output.writeFieldBegin('create_params', Thrift.Type.STRUCT, 6);
      this.create_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_geo_table_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_geo_table_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_table_status_args = class {
  constructor(args) {
    this.session = null;
    this.import_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.import_id !== undefined && args.import_id !== null) {
        this.import_id = args.import_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.import_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_table_status_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.import_id !== null && this.import_id !== undefined) {
      output.writeFieldBegin('import_id', Thrift.Type.STRING, 2);
      output.writeString(this.import_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_table_status_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TImportStatus(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TImportStatus();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_table_status_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_first_geo_file_in_archive_args = class {
  constructor(args) {
    this.session = null;
    this.archive_path = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.archive_path !== undefined && args.archive_path !== null) {
        this.archive_path = args.archive_path;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.archive_path = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_first_geo_file_in_archive_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.archive_path !== null && this.archive_path !== undefined) {
      output.writeFieldBegin('archive_path', Thrift.Type.STRING, 2);
      output.writeString(this.archive_path);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 3);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_first_geo_file_in_archive_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_first_geo_file_in_archive_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_files_in_archive_args = class {
  constructor(args) {
    this.session = null;
    this.archive_path = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.archive_path !== undefined && args.archive_path !== null) {
        this.archive_path = args.archive_path;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.archive_path = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_files_in_archive_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.archive_path !== null && this.archive_path !== undefined) {
      output.writeFieldBegin('archive_path', Thrift.Type.STRING, 2);
      output.writeString(this.archive_path);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 3);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_files_in_archive_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3398 = input.readListBegin();
          const _size397 = _rtmp3398.size || 0;
          for (let _i399 = 0; _i399 < _size397; ++_i399) {
            let elem400 = null;
            elem400 = input.readString();
            this.success.push(elem400);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_files_in_archive_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter401 in this.success) {
        if (this.success.hasOwnProperty(iter401)) {
          iter401 = this.success[iter401];
          output.writeString(iter401);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_layers_in_geo_file_args = class {
  constructor(args) {
    this.session = null;
    this.file_name = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.file_name !== undefined && args.file_name !== null) {
        this.file_name = args.file_name;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.file_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_layers_in_geo_file_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.file_name !== null && this.file_name !== undefined) {
      output.writeFieldBegin('file_name', Thrift.Type.STRING, 2);
      output.writeString(this.file_name);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 3);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_layers_in_geo_file_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TGeoFileLayerInfo]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3403 = input.readListBegin();
          const _size402 = _rtmp3403.size || 0;
          for (let _i404 = 0; _i404 < _size402; ++_i404) {
            let elem405 = null;
            elem405 = new ttypes.TGeoFileLayerInfo();
            elem405.read(input);
            this.success.push(elem405);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_layers_in_geo_file_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter406 in this.success) {
        if (this.success.hasOwnProperty(iter406)) {
          iter406 = this.success[iter406];
          iter406.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_query_get_outer_fragment_count_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_query_get_outer_fragment_count_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_query_get_outer_fragment_count_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_query_get_outer_fragment_count_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_check_table_consistency_args = class {
  constructor(args) {
    this.session = null;
    this.table_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_check_table_consistency_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 2);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_check_table_consistency_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableMeta(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableMeta();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_check_table_consistency_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_query_args = class {
  constructor(args) {
    this.leaf_session = null;
    this.parent_session = null;
    this.query_ra = null;
    this.start_time_str = null;
    this.just_explain = null;
    this.outer_fragment_indices = null;
    if (args) {
      if (args.leaf_session !== undefined && args.leaf_session !== null) {
        this.leaf_session = args.leaf_session;
      }
      if (args.parent_session !== undefined && args.parent_session !== null) {
        this.parent_session = args.parent_session;
      }
      if (args.query_ra !== undefined && args.query_ra !== null) {
        this.query_ra = args.query_ra;
      }
      if (args.start_time_str !== undefined && args.start_time_str !== null) {
        this.start_time_str = args.start_time_str;
      }
      if (args.just_explain !== undefined && args.just_explain !== null) {
        this.just_explain = args.just_explain;
      }
      if (args.outer_fragment_indices !== undefined && args.outer_fragment_indices !== null) {
        this.outer_fragment_indices = Thrift.copyList(args.outer_fragment_indices, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.leaf_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.parent_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.query_ra = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.start_time_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.just_explain = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.outer_fragment_indices = [];
          const _rtmp3408 = input.readListBegin();
          const _size407 = _rtmp3408.size || 0;
          for (let _i409 = 0; _i409 < _size407; ++_i409) {
            let elem410 = null;
            elem410 = input.readI64();
            this.outer_fragment_indices.push(elem410);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_query_args');
    if (this.leaf_session !== null && this.leaf_session !== undefined) {
      output.writeFieldBegin('leaf_session', Thrift.Type.STRING, 1);
      output.writeString(this.leaf_session);
      output.writeFieldEnd();
    }
    if (this.parent_session !== null && this.parent_session !== undefined) {
      output.writeFieldBegin('parent_session', Thrift.Type.STRING, 2);
      output.writeString(this.parent_session);
      output.writeFieldEnd();
    }
    if (this.query_ra !== null && this.query_ra !== undefined) {
      output.writeFieldBegin('query_ra', Thrift.Type.STRING, 3);
      output.writeString(this.query_ra);
      output.writeFieldEnd();
    }
    if (this.start_time_str !== null && this.start_time_str !== undefined) {
      output.writeFieldBegin('start_time_str', Thrift.Type.STRING, 4);
      output.writeString(this.start_time_str);
      output.writeFieldEnd();
    }
    if (this.just_explain !== null && this.just_explain !== undefined) {
      output.writeFieldBegin('just_explain', Thrift.Type.BOOL, 5);
      output.writeBool(this.just_explain);
      output.writeFieldEnd();
    }
    if (this.outer_fragment_indices !== null && this.outer_fragment_indices !== undefined) {
      output.writeFieldBegin('outer_fragment_indices', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.I64, this.outer_fragment_indices.length);
      for (let iter411 in this.outer_fragment_indices) {
        if (this.outer_fragment_indices.hasOwnProperty(iter411)) {
          iter411 = this.outer_fragment_indices[iter411];
          output.writeI64(iter411);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_query_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TPendingQuery(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TPendingQuery();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_query_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_execute_query_step_args = class {
  constructor(args) {
    this.pending_query = null;
    this.subquery_id = null;
    this.start_time_str = null;
    if (args) {
      if (args.pending_query !== undefined && args.pending_query !== null) {
        this.pending_query = new ttypes.TPendingQuery(args.pending_query);
      }
      if (args.subquery_id !== undefined && args.subquery_id !== null) {
        this.subquery_id = args.subquery_id;
      }
      if (args.start_time_str !== undefined && args.start_time_str !== null) {
        this.start_time_str = args.start_time_str;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.pending_query = new ttypes.TPendingQuery();
          this.pending_query.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.subquery_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.start_time_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_execute_query_step_args');
    if (this.pending_query !== null && this.pending_query !== undefined) {
      output.writeFieldBegin('pending_query', Thrift.Type.STRUCT, 1);
      this.pending_query.write(output);
      output.writeFieldEnd();
    }
    if (this.subquery_id !== null && this.subquery_id !== undefined) {
      output.writeFieldBegin('subquery_id', Thrift.Type.I64, 2);
      output.writeI64(this.subquery_id);
      output.writeFieldEnd();
    }
    if (this.start_time_str !== null && this.start_time_str !== undefined) {
      output.writeFieldBegin('start_time_str', Thrift.Type.STRING, 3);
      output.writeString(this.start_time_str);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_execute_query_step_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TStepResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TStepResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_execute_query_step_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_broadcast_serialized_rows_args = class {
  constructor(args) {
    this.serialized_rows = null;
    this.row_desc = null;
    this.query_id = null;
    this.subquery_id = null;
    this.is_final_subquery_result = null;
    if (args) {
      if (args.serialized_rows !== undefined && args.serialized_rows !== null) {
        this.serialized_rows = new serialized_result_set_ttypes.TSerializedRows(args.serialized_rows);
      }
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.query_id !== undefined && args.query_id !== null) {
        this.query_id = args.query_id;
      }
      if (args.subquery_id !== undefined && args.subquery_id !== null) {
        this.subquery_id = args.subquery_id;
      }
      if (args.is_final_subquery_result !== undefined && args.is_final_subquery_result !== null) {
        this.is_final_subquery_result = args.is_final_subquery_result;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.serialized_rows = new serialized_result_set_ttypes.TSerializedRows();
          this.serialized_rows.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp3413 = input.readListBegin();
          const _size412 = _rtmp3413.size || 0;
          for (let _i414 = 0; _i414 < _size412; ++_i414) {
            let elem415 = null;
            elem415 = new ttypes.TColumnType();
            elem415.read(input);
            this.row_desc.push(elem415);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.query_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.subquery_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.is_final_subquery_result = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_broadcast_serialized_rows_args');
    if (this.serialized_rows !== null && this.serialized_rows !== undefined) {
      output.writeFieldBegin('serialized_rows', Thrift.Type.STRUCT, 1);
      this.serialized_rows.write(output);
      output.writeFieldEnd();
    }
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter416 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter416)) {
          iter416 = this.row_desc[iter416];
          iter416.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.query_id !== null && this.query_id !== undefined) {
      output.writeFieldBegin('query_id', Thrift.Type.I64, 3);
      output.writeI64(this.query_id);
      output.writeFieldEnd();
    }
    if (this.subquery_id !== null && this.subquery_id !== undefined) {
      output.writeFieldBegin('subquery_id', Thrift.Type.I64, 4);
      output.writeI64(this.subquery_id);
      output.writeFieldEnd();
    }
    if (this.is_final_subquery_result !== null && this.is_final_subquery_result !== undefined) {
      output.writeFieldBegin('is_final_subquery_result', Thrift.Type.BOOL, 5);
      output.writeBool(this.is_final_subquery_result);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_broadcast_serialized_rows_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_broadcast_serialized_rows_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_render_query_args = class {
  constructor(args) {
    this.session = null;
    this.widget_id = null;
    this.node_idx = null;
    this.vega_json = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.widget_id !== undefined && args.widget_id !== null) {
        this.widget_id = args.widget_id;
      }
      if (args.node_idx !== undefined && args.node_idx !== null) {
        this.node_idx = args.node_idx;
      }
      if (args.vega_json !== undefined && args.vega_json !== null) {
        this.vega_json = args.vega_json;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.widget_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I16) {
          this.node_idx = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.vega_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_render_query_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.widget_id !== null && this.widget_id !== undefined) {
      output.writeFieldBegin('widget_id', Thrift.Type.I64, 2);
      output.writeI64(this.widget_id);
      output.writeFieldEnd();
    }
    if (this.node_idx !== null && this.node_idx !== undefined) {
      output.writeFieldBegin('node_idx', Thrift.Type.I16, 3);
      output.writeI16(this.node_idx);
      output.writeFieldEnd();
    }
    if (this.vega_json !== null && this.vega_json !== undefined) {
      output.writeFieldBegin('vega_json', Thrift.Type.STRING, 4);
      output.writeString(this.vega_json);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_render_query_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TPendingRenderQuery(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TPendingRenderQuery();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_render_query_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_execute_next_render_step_args = class {
  constructor(args) {
    this.pending_render = null;
    this.merged_data = null;
    if (args) {
      if (args.pending_render !== undefined && args.pending_render !== null) {
        this.pending_render = new ttypes.TPendingRenderQuery(args.pending_render);
      }
      if (args.merged_data !== undefined && args.merged_data !== null) {
        this.merged_data = Thrift.copyMap(args.merged_data, [Thrift.copyMap, Thrift.copyMap, Thrift.copyMap, Thrift.copyList, ttypes.TRenderDatum]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.pending_render = new ttypes.TPendingRenderQuery();
          this.pending_render.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.merged_data = {};
          const _rtmp3418 = input.readMapBegin();
          const _size417 = _rtmp3418.size || 0;
          for (let _i419 = 0; _i419 < _size417; ++_i419) {
            let key420 = null;
            let val421 = null;
            key420 = input.readString();
            val421 = {};
            const _rtmp3423 = input.readMapBegin();
            const _size422 = _rtmp3423.size || 0;
            for (let _i424 = 0; _i424 < _size422; ++_i424) {
              let key425 = null;
              let val426 = null;
              key425 = input.readString();
              val426 = {};
              const _rtmp3428 = input.readMapBegin();
              const _size427 = _rtmp3428.size || 0;
              for (let _i429 = 0; _i429 < _size427; ++_i429) {
                let key430 = null;
                let val431 = null;
                key430 = input.readString();
                val431 = {};
                const _rtmp3433 = input.readMapBegin();
                const _size432 = _rtmp3433.size || 0;
                for (let _i434 = 0; _i434 < _size432; ++_i434) {
                  let key435 = null;
                  let val436 = null;
                  key435 = input.readString();
                  val436 = [];
                  const _rtmp3438 = input.readListBegin();
                  const _size437 = _rtmp3438.size || 0;
                  for (let _i439 = 0; _i439 < _size437; ++_i439) {
                    let elem440 = null;
                    elem440 = new ttypes.TRenderDatum();
                    elem440.read(input);
                    val436.push(elem440);
                  }
                  input.readListEnd();
                  val431[key435] = val436;
                }
                input.readMapEnd();
                val426[key430] = val431;
              }
              input.readMapEnd();
              val421[key425] = val426;
            }
            input.readMapEnd();
            this.merged_data[key420] = val421;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_execute_next_render_step_args');
    if (this.pending_render !== null && this.pending_render !== undefined) {
      output.writeFieldBegin('pending_render', Thrift.Type.STRUCT, 1);
      this.pending_render.write(output);
      output.writeFieldEnd();
    }
    if (this.merged_data !== null && this.merged_data !== undefined) {
      output.writeFieldBegin('merged_data', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.merged_data));
      for (let kiter441 in this.merged_data) {
        if (this.merged_data.hasOwnProperty(kiter441)) {
          let viter442 = this.merged_data[kiter441];
          output.writeString(kiter441);
          output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(viter442));
          for (let kiter443 in viter442) {
            if (viter442.hasOwnProperty(kiter443)) {
              let viter444 = viter442[kiter443];
              output.writeString(kiter443);
              output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(viter444));
              for (let kiter445 in viter444) {
                if (viter444.hasOwnProperty(kiter445)) {
                  let viter446 = viter444[kiter445];
                  output.writeString(kiter445);
                  output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter446));
                  for (let kiter447 in viter446) {
                    if (viter446.hasOwnProperty(kiter447)) {
                      let viter448 = viter446[kiter447];
                      output.writeString(kiter447);
                      output.writeListBegin(Thrift.Type.STRUCT, viter448.length);
                      for (let iter449 in viter448) {
                        if (viter448.hasOwnProperty(iter449)) {
                          iter449 = viter448[iter449];
                          iter449.write(output);
                        }
                      }
                      output.writeListEnd();
                    }
                  }
                  output.writeMapEnd();
                }
              }
              output.writeMapEnd();
            }
          }
          output.writeMapEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_execute_next_render_step_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TRenderStepResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TRenderStepResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_execute_next_render_step_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_insert_data_args = class {
  constructor(args) {
    this.session = null;
    this.insert_data = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.insert_data !== undefined && args.insert_data !== null) {
        this.insert_data = new ttypes.TInsertData(args.insert_data);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.insert_data = new ttypes.TInsertData();
          this.insert_data.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_insert_data_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.insert_data !== null && this.insert_data !== undefined) {
      output.writeFieldBegin('insert_data', Thrift.Type.STRUCT, 2);
      this.insert_data.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_insert_data_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_insert_data_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_insert_chunks_args = class {
  constructor(args) {
    this.session = null;
    this.insert_chunks = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.insert_chunks !== undefined && args.insert_chunks !== null) {
        this.insert_chunks = new ttypes.TInsertChunks(args.insert_chunks);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.insert_chunks = new ttypes.TInsertChunks();
          this.insert_chunks.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_insert_chunks_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.insert_chunks !== null && this.insert_chunks !== undefined) {
      output.writeFieldBegin('insert_chunks', Thrift.Type.STRUCT, 2);
      this.insert_chunks.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_insert_chunks_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_insert_chunks_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_checkpoint_args = class {
  constructor(args) {
    this.session = null;
    this.table_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_checkpoint_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 2);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_checkpoint_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_checkpoint_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_roles_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_roles_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_roles_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3451 = input.readListBegin();
          const _size450 = _rtmp3451.size || 0;
          for (let _i452 = 0; _i452 < _size450; ++_i452) {
            let elem453 = null;
            elem453 = input.readString();
            this.success.push(elem453);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_roles_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter454 in this.success) {
        if (this.success.hasOwnProperty(iter454)) {
          iter454 = this.success[iter454];
          output.writeString(iter454);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_db_objects_for_grantee_args = class {
  constructor(args) {
    this.session = null;
    this.roleName = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.roleName !== undefined && args.roleName !== null) {
        this.roleName = args.roleName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.roleName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_db_objects_for_grantee_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.roleName !== null && this.roleName !== undefined) {
      output.writeFieldBegin('roleName', Thrift.Type.STRING, 2);
      output.writeString(this.roleName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_db_objects_for_grantee_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDBObject]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3456 = input.readListBegin();
          const _size455 = _rtmp3456.size || 0;
          for (let _i457 = 0; _i457 < _size455; ++_i457) {
            let elem458 = null;
            elem458 = new ttypes.TDBObject();
            elem458.read(input);
            this.success.push(elem458);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_db_objects_for_grantee_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter459 in this.success) {
        if (this.success.hasOwnProperty(iter459)) {
          iter459 = this.success[iter459];
          iter459.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_db_object_privs_args = class {
  constructor(args) {
    this.session = null;
    this.objectName = null;
    this.type = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.objectName !== undefined && args.objectName !== null) {
        this.objectName = args.objectName;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.objectName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_db_object_privs_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.objectName !== null && this.objectName !== undefined) {
      output.writeFieldBegin('objectName', Thrift.Type.STRING, 2);
      output.writeString(this.objectName);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_db_object_privs_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDBObject]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3461 = input.readListBegin();
          const _size460 = _rtmp3461.size || 0;
          for (let _i462 = 0; _i462 < _size460; ++_i462) {
            let elem463 = null;
            elem463 = new ttypes.TDBObject();
            elem463.read(input);
            this.success.push(elem463);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_db_object_privs_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter464 in this.success) {
        if (this.success.hasOwnProperty(iter464)) {
          iter464 = this.success[iter464];
          iter464.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_roles_for_user_args = class {
  constructor(args) {
    this.session = null;
    this.userName = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.userName !== undefined && args.userName !== null) {
        this.userName = args.userName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_roles_for_user_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.userName !== null && this.userName !== undefined) {
      output.writeFieldBegin('userName', Thrift.Type.STRING, 2);
      output.writeString(this.userName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_roles_for_user_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3466 = input.readListBegin();
          const _size465 = _rtmp3466.size || 0;
          for (let _i467 = 0; _i467 < _size465; ++_i467) {
            let elem468 = null;
            elem468 = input.readString();
            this.success.push(elem468);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_roles_for_user_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter469 in this.success) {
        if (this.success.hasOwnProperty(iter469)) {
          iter469 = this.success[iter469];
          output.writeString(iter469);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_effective_roles_for_user_args = class {
  constructor(args) {
    this.session = null;
    this.userName = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.userName !== undefined && args.userName !== null) {
        this.userName = args.userName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_effective_roles_for_user_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.userName !== null && this.userName !== undefined) {
      output.writeFieldBegin('userName', Thrift.Type.STRING, 2);
      output.writeString(this.userName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_effective_roles_for_user_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3471 = input.readListBegin();
          const _size470 = _rtmp3471.size || 0;
          for (let _i472 = 0; _i472 < _size470; ++_i472) {
            let elem473 = null;
            elem473 = input.readString();
            this.success.push(elem473);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_effective_roles_for_user_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter474 in this.success) {
        if (this.success.hasOwnProperty(iter474)) {
          iter474 = this.success[iter474];
          output.writeString(iter474);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_has_role_args = class {
  constructor(args) {
    this.session = null;
    this.granteeName = null;
    this.roleName = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.granteeName !== undefined && args.granteeName !== null) {
        this.granteeName = args.granteeName;
      }
      if (args.roleName !== undefined && args.roleName !== null) {
        this.roleName = args.roleName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.granteeName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.roleName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_has_role_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.granteeName !== null && this.granteeName !== undefined) {
      output.writeFieldBegin('granteeName', Thrift.Type.STRING, 2);
      output.writeString(this.granteeName);
      output.writeFieldEnd();
    }
    if (this.roleName !== null && this.roleName !== undefined) {
      output.writeFieldBegin('roleName', Thrift.Type.STRING, 3);
      output.writeString(this.roleName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_has_role_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_has_role_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_has_object_privilege_args = class {
  constructor(args) {
    this.session = null;
    this.granteeName = null;
    this.ObjectName = null;
    this.objectType = null;
    this.permissions = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.granteeName !== undefined && args.granteeName !== null) {
        this.granteeName = args.granteeName;
      }
      if (args.ObjectName !== undefined && args.ObjectName !== null) {
        this.ObjectName = args.ObjectName;
      }
      if (args.objectType !== undefined && args.objectType !== null) {
        this.objectType = args.objectType;
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDBObjectPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.granteeName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.ObjectName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.objectType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDBObjectPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_has_object_privilege_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.granteeName !== null && this.granteeName !== undefined) {
      output.writeFieldBegin('granteeName', Thrift.Type.STRING, 2);
      output.writeString(this.granteeName);
      output.writeFieldEnd();
    }
    if (this.ObjectName !== null && this.ObjectName !== undefined) {
      output.writeFieldBegin('ObjectName', Thrift.Type.STRING, 3);
      output.writeString(this.ObjectName);
      output.writeFieldEnd();
    }
    if (this.objectType !== null && this.objectType !== undefined) {
      output.writeFieldBegin('objectType', Thrift.Type.I32, 4);
      output.writeI32(this.objectType);
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 5);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_has_object_privilege_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_has_object_privilege_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_license_key_args = class {
  constructor(args) {
    this.session = null;
    this.key = null;
    this.nonce = '';
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_license_key_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 3);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_license_key_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TLicenseInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TLicenseInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_license_key_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_license_claims_args = class {
  constructor(args) {
    this.session = null;
    this.nonce = '';
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_license_claims_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 2);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_license_claims_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TLicenseInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TLicenseInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_license_claims_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_device_parameters_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_device_parameters_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_device_parameters_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3476 = input.readMapBegin();
          const _size475 = _rtmp3476.size || 0;
          for (let _i477 = 0; _i477 < _size475; ++_i477) {
            let key478 = null;
            let val479 = null;
            key478 = input.readString();
            val479 = input.readString();
            this.success[key478] = val479;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_device_parameters_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter480 in this.success) {
        if (this.success.hasOwnProperty(kiter480)) {
          let viter481 = this.success[kiter480];
          output.writeString(kiter480);
          output.writeString(viter481);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_register_runtime_extension_functions_args = class {
  constructor(args) {
    this.session = null;
    this.udfs = null;
    this.udtfs = null;
    this.device_ir_map = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.udfs !== undefined && args.udfs !== null) {
        this.udfs = Thrift.copyList(args.udfs, [extension_functions_ttypes.TUserDefinedFunction]);
      }
      if (args.udtfs !== undefined && args.udtfs !== null) {
        this.udtfs = Thrift.copyList(args.udtfs, [extension_functions_ttypes.TUserDefinedTableFunction]);
      }
      if (args.device_ir_map !== undefined && args.device_ir_map !== null) {
        this.device_ir_map = Thrift.copyMap(args.device_ir_map, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.udfs = [];
          const _rtmp3483 = input.readListBegin();
          const _size482 = _rtmp3483.size || 0;
          for (let _i484 = 0; _i484 < _size482; ++_i484) {
            let elem485 = null;
            elem485 = new extension_functions_ttypes.TUserDefinedFunction();
            elem485.read(input);
            this.udfs.push(elem485);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.udtfs = [];
          const _rtmp3487 = input.readListBegin();
          const _size486 = _rtmp3487.size || 0;
          for (let _i488 = 0; _i488 < _size486; ++_i488) {
            let elem489 = null;
            elem489 = new extension_functions_ttypes.TUserDefinedTableFunction();
            elem489.read(input);
            this.udtfs.push(elem489);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.MAP) {
          this.device_ir_map = {};
          const _rtmp3491 = input.readMapBegin();
          const _size490 = _rtmp3491.size || 0;
          for (let _i492 = 0; _i492 < _size490; ++_i492) {
            let key493 = null;
            let val494 = null;
            key493 = input.readString();
            val494 = input.readString();
            this.device_ir_map[key493] = val494;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_register_runtime_extension_functions_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.udfs !== null && this.udfs !== undefined) {
      output.writeFieldBegin('udfs', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.udfs.length);
      for (let iter495 in this.udfs) {
        if (this.udfs.hasOwnProperty(iter495)) {
          iter495 = this.udfs[iter495];
          iter495.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.udtfs !== null && this.udtfs !== undefined) {
      output.writeFieldBegin('udtfs', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.udtfs.length);
      for (let iter496 in this.udtfs) {
        if (this.udtfs.hasOwnProperty(iter496)) {
          iter496 = this.udtfs[iter496];
          iter496.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.device_ir_map !== null && this.device_ir_map !== undefined) {
      output.writeFieldBegin('device_ir_map', Thrift.Type.MAP, 4);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.device_ir_map));
      for (let kiter497 in this.device_ir_map) {
        if (this.device_ir_map.hasOwnProperty(kiter497)) {
          let viter498 = this.device_ir_map[kiter497];
          output.writeString(kiter497);
          output.writeString(viter498);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_register_runtime_extension_functions_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_register_runtime_extension_functions_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_function_names_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_function_names_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_function_names_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3500 = input.readListBegin();
          const _size499 = _rtmp3500.size || 0;
          for (let _i501 = 0; _i501 < _size499; ++_i501) {
            let elem502 = null;
            elem502 = input.readString();
            this.success.push(elem502);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_function_names_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter503 in this.success) {
        if (this.success.hasOwnProperty(iter503)) {
          iter503 = this.success[iter503];
          output.writeString(iter503);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_runtime_table_function_names_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_runtime_table_function_names_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_runtime_table_function_names_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3505 = input.readListBegin();
          const _size504 = _rtmp3505.size || 0;
          for (let _i506 = 0; _i506 < _size504; ++_i506) {
            let elem507 = null;
            elem507 = input.readString();
            this.success.push(elem507);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_runtime_table_function_names_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter508 in this.success) {
        if (this.success.hasOwnProperty(iter508)) {
          iter508 = this.success[iter508];
          output.writeString(iter508);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_function_details_args = class {
  constructor(args) {
    this.session = null;
    this.udtf_names = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.udtf_names !== undefined && args.udtf_names !== null) {
        this.udtf_names = Thrift.copyList(args.udtf_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.udtf_names = [];
          const _rtmp3510 = input.readListBegin();
          const _size509 = _rtmp3510.size || 0;
          for (let _i511 = 0; _i511 < _size509; ++_i511) {
            let elem512 = null;
            elem512 = input.readString();
            this.udtf_names.push(elem512);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_function_details_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.udtf_names !== null && this.udtf_names !== undefined) {
      output.writeFieldBegin('udtf_names', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.udtf_names.length);
      for (let iter513 in this.udtf_names) {
        if (this.udtf_names.hasOwnProperty(iter513)) {
          iter513 = this.udtf_names[iter513];
          output.writeString(iter513);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_function_details_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [extension_functions_ttypes.TUserDefinedTableFunction]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3515 = input.readListBegin();
          const _size514 = _rtmp3515.size || 0;
          for (let _i516 = 0; _i516 < _size514; ++_i516) {
            let elem517 = null;
            elem517 = new extension_functions_ttypes.TUserDefinedTableFunction();
            elem517.read(input);
            this.success.push(elem517);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_function_details_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter518 in this.success) {
        if (this.success.hasOwnProperty(iter518)) {
          iter518 = this.success[iter518];
          iter518.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_function_names_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_function_names_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_function_names_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3520 = input.readListBegin();
          const _size519 = _rtmp3520.size || 0;
          for (let _i521 = 0; _i521 < _size519; ++_i521) {
            let elem522 = null;
            elem522 = input.readString();
            this.success.push(elem522);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_function_names_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter523 in this.success) {
        if (this.success.hasOwnProperty(iter523)) {
          iter523 = this.success[iter523];
          output.writeString(iter523);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_runtime_function_names_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_runtime_function_names_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_runtime_function_names_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3525 = input.readListBegin();
          const _size524 = _rtmp3525.size || 0;
          for (let _i526 = 0; _i526 < _size524; ++_i526) {
            let elem527 = null;
            elem527 = input.readString();
            this.success.push(elem527);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_runtime_function_names_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter528 in this.success) {
        if (this.success.hasOwnProperty(iter528)) {
          iter528 = this.success[iter528];
          output.writeString(iter528);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_function_details_args = class {
  constructor(args) {
    this.session = null;
    this.udf_names = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.udf_names !== undefined && args.udf_names !== null) {
        this.udf_names = Thrift.copyList(args.udf_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.udf_names = [];
          const _rtmp3530 = input.readListBegin();
          const _size529 = _rtmp3530.size || 0;
          for (let _i531 = 0; _i531 < _size529; ++_i531) {
            let elem532 = null;
            elem532 = input.readString();
            this.udf_names.push(elem532);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_function_details_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.udf_names !== null && this.udf_names !== undefined) {
      output.writeFieldBegin('udf_names', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.udf_names.length);
      for (let iter533 in this.udf_names) {
        if (this.udf_names.hasOwnProperty(iter533)) {
          iter533 = this.udf_names[iter533];
          output.writeString(iter533);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_function_details_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [extension_functions_ttypes.TUserDefinedFunction]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3535 = input.readListBegin();
          const _size534 = _rtmp3535.size || 0;
          for (let _i536 = 0; _i536 < _size534; ++_i536) {
            let elem537 = null;
            elem537 = new extension_functions_ttypes.TUserDefinedFunction();
            elem537.read(input);
            this.success.push(elem537);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_function_details_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter538 in this.success) {
        if (this.success.hasOwnProperty(iter538)) {
          iter538 = this.success[iter538];
          iter538.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const HeavyClient = exports.Client = class HeavyClient {
  constructor(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this._seqid = 0;
    this._reqs = {};
  }
  seqid () { return this._seqid; }
  new_seqid () { return this._seqid += 1; }

  connect (user, passwd, dbname) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_connect(user, passwd, dbname);
    });
  }

  send_connect (user, passwd, dbname) {
    const output = new this.pClass(this.output);
    const params = {
      user: user,
      passwd: passwd,
      dbname: dbname
    };
    const args = new Heavy_connect_args(params);
    try {
      output.writeMessageBegin('connect', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_connect (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_connect_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('connect failed: unknown result');
  }

  krb5_connect (inputToken, dbname) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_krb5_connect(inputToken, dbname);
    });
  }

  send_krb5_connect (inputToken, dbname) {
    const output = new this.pClass(this.output);
    const params = {
      inputToken: inputToken,
      dbname: dbname
    };
    const args = new Heavy_krb5_connect_args(params);
    try {
      output.writeMessageBegin('krb5_connect', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_krb5_connect (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_krb5_connect_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('krb5_connect failed: unknown result');
  }

  disconnect (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_disconnect(session);
    });
  }

  send_disconnect (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_disconnect_args(params);
    try {
      output.writeMessageBegin('disconnect', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_disconnect (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_disconnect_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  switch_database (session, dbname) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_switch_database(session, dbname);
    });
  }

  send_switch_database (session, dbname) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dbname: dbname
    };
    const args = new Heavy_switch_database_args(params);
    try {
      output.writeMessageBegin('switch_database', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_switch_database (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_switch_database_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  clone_session (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clone_session(session);
    });
  }

  send_clone_session (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_clone_session_args(params);
    try {
      output.writeMessageBegin('clone_session', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clone_session (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_clone_session_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('clone_session failed: unknown result');
  }

  get_server_status (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_server_status(session);
    });
  }

  send_get_server_status (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_server_status_args(params);
    try {
      output.writeMessageBegin('get_server_status', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_server_status (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_server_status_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_server_status failed: unknown result');
  }

  get_status (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_status(session);
    });
  }

  send_get_status (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_status_args(params);
    try {
      output.writeMessageBegin('get_status', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_status (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_status_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_status failed: unknown result');
  }

  get_hardware_info (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_hardware_info(session);
    });
  }

  send_get_hardware_info (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_hardware_info_args(params);
    try {
      output.writeMessageBegin('get_hardware_info', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_hardware_info (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_hardware_info_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_hardware_info failed: unknown result');
  }

  get_tables (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_tables(session);
    });
  }

  send_get_tables (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_tables_args(params);
    try {
      output.writeMessageBegin('get_tables', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_tables (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_tables_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_tables failed: unknown result');
  }

  get_tables_for_database (session, database_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_tables_for_database(session, database_name);
    });
  }

  send_get_tables_for_database (session, database_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      database_name: database_name
    };
    const args = new Heavy_get_tables_for_database_args(params);
    try {
      output.writeMessageBegin('get_tables_for_database', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_tables_for_database (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_tables_for_database_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_tables_for_database failed: unknown result');
  }

  get_physical_tables (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_physical_tables(session);
    });
  }

  send_get_physical_tables (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_physical_tables_args(params);
    try {
      output.writeMessageBegin('get_physical_tables', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_physical_tables (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_physical_tables_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_physical_tables failed: unknown result');
  }

  get_views (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_views(session);
    });
  }

  send_get_views (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_views_args(params);
    try {
      output.writeMessageBegin('get_views', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_views (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_views_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_views failed: unknown result');
  }

  get_tables_meta (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_tables_meta(session);
    });
  }

  send_get_tables_meta (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_tables_meta_args(params);
    try {
      output.writeMessageBegin('get_tables_meta', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_tables_meta (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_tables_meta_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_tables_meta failed: unknown result');
  }

  get_table_details (session, table_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_details(session, table_name);
    });
  }

  send_get_table_details (session, table_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name
    };
    const args = new Heavy_get_table_details_args(params);
    try {
      output.writeMessageBegin('get_table_details', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_details (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_details_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_details failed: unknown result');
  }

  get_table_details_for_database (session, table_name, database_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_details_for_database(session, table_name, database_name);
    });
  }

  send_get_table_details_for_database (session, table_name, database_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      database_name: database_name
    };
    const args = new Heavy_get_table_details_for_database_args(params);
    try {
      output.writeMessageBegin('get_table_details_for_database', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_details_for_database (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_details_for_database_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_details_for_database failed: unknown result');
  }

  get_internal_table_details (session, table_name, include_system_columns) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_internal_table_details(session, table_name, include_system_columns);
    });
  }

  send_get_internal_table_details (session, table_name, include_system_columns) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      include_system_columns: include_system_columns
    };
    const args = new Heavy_get_internal_table_details_args(params);
    try {
      output.writeMessageBegin('get_internal_table_details', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_internal_table_details (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_internal_table_details_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_internal_table_details failed: unknown result');
  }

  get_internal_table_details_for_database (session, table_name, database_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_internal_table_details_for_database(session, table_name, database_name);
    });
  }

  send_get_internal_table_details_for_database (session, table_name, database_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      database_name: database_name
    };
    const args = new Heavy_get_internal_table_details_for_database_args(params);
    try {
      output.writeMessageBegin('get_internal_table_details_for_database', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_internal_table_details_for_database (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_internal_table_details_for_database_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_internal_table_details_for_database failed: unknown result');
  }

  get_users (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_users(session);
    });
  }

  send_get_users (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_users_args(params);
    try {
      output.writeMessageBegin('get_users', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_users (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_users_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_users failed: unknown result');
  }

  get_databases (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_databases(session);
    });
  }

  send_get_databases (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_databases_args(params);
    try {
      output.writeMessageBegin('get_databases', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_databases (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_databases_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_databases failed: unknown result');
  }

  get_version () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_version();
    });
  }

  send_get_version () {
    const output = new this.pClass(this.output);
    const args = new Heavy_get_version_args();
    try {
      output.writeMessageBegin('get_version', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_version (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_version_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_version failed: unknown result');
  }

  start_heap_profile (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_start_heap_profile(session);
    });
  }

  send_start_heap_profile (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_start_heap_profile_args(params);
    try {
      output.writeMessageBegin('start_heap_profile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_start_heap_profile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_start_heap_profile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  stop_heap_profile (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_stop_heap_profile(session);
    });
  }

  send_stop_heap_profile (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_stop_heap_profile_args(params);
    try {
      output.writeMessageBegin('stop_heap_profile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_stop_heap_profile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_stop_heap_profile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_heap_profile (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_heap_profile(session);
    });
  }

  send_get_heap_profile (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_heap_profile_args(params);
    try {
      output.writeMessageBegin('get_heap_profile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_heap_profile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_heap_profile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_heap_profile failed: unknown result');
  }

  get_memory (session, memory_level) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_memory(session, memory_level);
    });
  }

  send_get_memory (session, memory_level) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      memory_level: memory_level
    };
    const args = new Heavy_get_memory_args(params);
    try {
      output.writeMessageBegin('get_memory', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_memory (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_memory_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_memory failed: unknown result');
  }

  clear_cpu_memory (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clear_cpu_memory(session);
    });
  }

  send_clear_cpu_memory (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_clear_cpu_memory_args(params);
    try {
      output.writeMessageBegin('clear_cpu_memory', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clear_cpu_memory (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_clear_cpu_memory_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  clear_gpu_memory (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clear_gpu_memory(session);
    });
  }

  send_clear_gpu_memory (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_clear_gpu_memory_args(params);
    try {
      output.writeMessageBegin('clear_gpu_memory', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clear_gpu_memory (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_clear_gpu_memory_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  set_cur_session (parent_session, leaf_session, start_time_str, label, for_running_query_kernel) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_cur_session(parent_session, leaf_session, start_time_str, label, for_running_query_kernel);
    });
  }

  send_set_cur_session (parent_session, leaf_session, start_time_str, label, for_running_query_kernel) {
    const output = new this.pClass(this.output);
    const params = {
      parent_session: parent_session,
      leaf_session: leaf_session,
      start_time_str: start_time_str,
      label: label,
      for_running_query_kernel: for_running_query_kernel
    };
    const args = new Heavy_set_cur_session_args(params);
    try {
      output.writeMessageBegin('set_cur_session', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_cur_session (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_cur_session_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  invalidate_cur_session (parent_session, leaf_session, start_time_str, label, for_running_query_kernel) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_invalidate_cur_session(parent_session, leaf_session, start_time_str, label, for_running_query_kernel);
    });
  }

  send_invalidate_cur_session (parent_session, leaf_session, start_time_str, label, for_running_query_kernel) {
    const output = new this.pClass(this.output);
    const params = {
      parent_session: parent_session,
      leaf_session: leaf_session,
      start_time_str: start_time_str,
      label: label,
      for_running_query_kernel: for_running_query_kernel
    };
    const args = new Heavy_invalidate_cur_session_args(params);
    try {
      output.writeMessageBegin('invalidate_cur_session', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_invalidate_cur_session (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_invalidate_cur_session_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  set_table_epoch (session, db_id, table_id, new_epoch) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_table_epoch(session, db_id, table_id, new_epoch);
    });
  }

  send_set_table_epoch (session, db_id, table_id, new_epoch) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      db_id: db_id,
      table_id: table_id,
      new_epoch: new_epoch
    };
    const args = new Heavy_set_table_epoch_args(params);
    try {
      output.writeMessageBegin('set_table_epoch', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_table_epoch (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_table_epoch_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  set_table_epoch_by_name (session, table_name, new_epoch) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_table_epoch_by_name(session, table_name, new_epoch);
    });
  }

  send_set_table_epoch_by_name (session, table_name, new_epoch) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      new_epoch: new_epoch
    };
    const args = new Heavy_set_table_epoch_by_name_args(params);
    try {
      output.writeMessageBegin('set_table_epoch_by_name', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_table_epoch_by_name (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_table_epoch_by_name_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_table_epoch (session, db_id, table_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_epoch(session, db_id, table_id);
    });
  }

  send_get_table_epoch (session, db_id, table_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      db_id: db_id,
      table_id: table_id
    };
    const args = new Heavy_get_table_epoch_args(params);
    try {
      output.writeMessageBegin('get_table_epoch', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_epoch (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_epoch_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_epoch failed: unknown result');
  }

  get_table_epoch_by_name (session, table_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_epoch_by_name(session, table_name);
    });
  }

  send_get_table_epoch_by_name (session, table_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name
    };
    const args = new Heavy_get_table_epoch_by_name_args(params);
    try {
      output.writeMessageBegin('get_table_epoch_by_name', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_epoch_by_name (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_epoch_by_name_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_epoch_by_name failed: unknown result');
  }

  get_table_epochs (session, db_id, table_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_epochs(session, db_id, table_id);
    });
  }

  send_get_table_epochs (session, db_id, table_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      db_id: db_id,
      table_id: table_id
    };
    const args = new Heavy_get_table_epochs_args(params);
    try {
      output.writeMessageBegin('get_table_epochs', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_epochs (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_epochs_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_epochs failed: unknown result');
  }

  set_table_epochs (session, db_id, table_epochs) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_table_epochs(session, db_id, table_epochs);
    });
  }

  send_set_table_epochs (session, db_id, table_epochs) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      db_id: db_id,
      table_epochs: table_epochs
    };
    const args = new Heavy_set_table_epochs_args(params);
    try {
      output.writeMessageBegin('set_table_epochs', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_table_epochs (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_table_epochs_result();
    result.read(input);
    input.readMessageEnd();

    callback(null);
  }

  get_session_info (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_session_info(session);
    });
  }

  send_get_session_info (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_session_info_args(params);
    try {
      output.writeMessageBegin('get_session_info', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_session_info (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_session_info_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_session_info failed: unknown result');
  }

  get_queries_info (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_queries_info(session);
    });
  }

  send_get_queries_info (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_queries_info_args(params);
    try {
      output.writeMessageBegin('get_queries_info', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_queries_info (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_queries_info_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_queries_info failed: unknown result');
  }

  set_leaf_info (session, leaf_info) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_leaf_info(session, leaf_info);
    });
  }

  send_set_leaf_info (session, leaf_info) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      leaf_info: leaf_info
    };
    const args = new Heavy_set_leaf_info_args(params);
    try {
      output.writeMessageBegin('set_leaf_info', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_leaf_info (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_leaf_info_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  sql_execute (session, query, column_format, nonce, first_n, at_most_n) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sql_execute(session, query, column_format, nonce, first_n, at_most_n);
    });
  }

  send_sql_execute (session, query, column_format, nonce, first_n, at_most_n) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query,
      column_format: column_format,
      nonce: nonce,
      first_n: first_n,
      at_most_n: at_most_n
    };
    const args = new Heavy_sql_execute_args(params);
    try {
      output.writeMessageBegin('sql_execute', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sql_execute (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_sql_execute_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sql_execute failed: unknown result');
  }

  sql_execute_df (session, query, device_type, device_id, first_n, transport_method) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sql_execute_df(session, query, device_type, device_id, first_n, transport_method);
    });
  }

  send_sql_execute_df (session, query, device_type, device_id, first_n, transport_method) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query,
      device_type: device_type,
      device_id: device_id,
      first_n: first_n,
      transport_method: transport_method
    };
    const args = new Heavy_sql_execute_df_args(params);
    try {
      output.writeMessageBegin('sql_execute_df', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sql_execute_df (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_sql_execute_df_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sql_execute_df failed: unknown result');
  }

  sql_execute_gdf (session, query, device_id, first_n) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sql_execute_gdf(session, query, device_id, first_n);
    });
  }

  send_sql_execute_gdf (session, query, device_id, first_n) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query,
      device_id: device_id,
      first_n: first_n
    };
    const args = new Heavy_sql_execute_gdf_args(params);
    try {
      output.writeMessageBegin('sql_execute_gdf', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sql_execute_gdf (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_sql_execute_gdf_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sql_execute_gdf failed: unknown result');
  }

  deallocate_df (session, df, device_type, device_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_deallocate_df(session, df, device_type, device_id);
    });
  }

  send_deallocate_df (session, df, device_type, device_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      df: df,
      device_type: device_type,
      device_id: device_id
    };
    const args = new Heavy_deallocate_df_args(params);
    try {
      output.writeMessageBegin('deallocate_df', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_deallocate_df (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_deallocate_df_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  interrupt (query_session, interrupt_session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_interrupt(query_session, interrupt_session);
    });
  }

  send_interrupt (query_session, interrupt_session) {
    const output = new this.pClass(this.output);
    const params = {
      query_session: query_session,
      interrupt_session: interrupt_session
    };
    const args = new Heavy_interrupt_args(params);
    try {
      output.writeMessageBegin('interrupt', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_interrupt (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_interrupt_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  sql_validate (session, query) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sql_validate(session, query);
    });
  }

  send_sql_validate (session, query) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query
    };
    const args = new Heavy_sql_validate_args(params);
    try {
      output.writeMessageBegin('sql_validate', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sql_validate (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_sql_validate_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sql_validate failed: unknown result');
  }

  get_completion_hints (session, sql, cursor) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_completion_hints(session, sql, cursor);
    });
  }

  send_get_completion_hints (session, sql, cursor) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      sql: sql,
      cursor: cursor
    };
    const args = new Heavy_get_completion_hints_args(params);
    try {
      output.writeMessageBegin('get_completion_hints', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_completion_hints (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_completion_hints_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_completion_hints failed: unknown result');
  }

  set_execution_mode (session, mode) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_execution_mode(session, mode);
    });
  }

  send_set_execution_mode (session, mode) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      mode: mode
    };
    const args = new Heavy_set_execution_mode_args(params);
    try {
      output.writeMessageBegin('set_execution_mode', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_execution_mode (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_execution_mode_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  render_vega (session, widget_id, vega_json, compression_level, nonce) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_render_vega(session, widget_id, vega_json, compression_level, nonce);
    });
  }

  send_render_vega (session, widget_id, vega_json, compression_level, nonce) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      widget_id: widget_id,
      vega_json: vega_json,
      compression_level: compression_level,
      nonce: nonce
    };
    const args = new Heavy_render_vega_args(params);
    try {
      output.writeMessageBegin('render_vega', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_render_vega (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_render_vega_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('render_vega failed: unknown result');
  }

  get_result_row_for_pixel (session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_result_row_for_pixel(session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce);
    });
  }

  send_get_result_row_for_pixel (session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      widget_id: widget_id,
      pixel: pixel,
      table_col_names: table_col_names,
      column_format: column_format,
      pixelRadius: pixelRadius,
      nonce: nonce
    };
    const args = new Heavy_get_result_row_for_pixel_args(params);
    try {
      output.writeMessageBegin('get_result_row_for_pixel', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_result_row_for_pixel (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_result_row_for_pixel_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_result_row_for_pixel failed: unknown result');
  }

  create_custom_expression (session, custom_expression) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_create_custom_expression(session, custom_expression);
    });
  }

  send_create_custom_expression (session, custom_expression) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      custom_expression: custom_expression
    };
    const args = new Heavy_create_custom_expression_args(params);
    try {
      output.writeMessageBegin('create_custom_expression', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_create_custom_expression (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_create_custom_expression_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('create_custom_expression failed: unknown result');
  }

  get_custom_expressions (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_custom_expressions(session);
    });
  }

  send_get_custom_expressions (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_custom_expressions_args(params);
    try {
      output.writeMessageBegin('get_custom_expressions', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_custom_expressions (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_custom_expressions_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_custom_expressions failed: unknown result');
  }

  update_custom_expression (session, id, expression_json) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_update_custom_expression(session, id, expression_json);
    });
  }

  send_update_custom_expression (session, id, expression_json) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      id: id,
      expression_json: expression_json
    };
    const args = new Heavy_update_custom_expression_args(params);
    try {
      output.writeMessageBegin('update_custom_expression', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_update_custom_expression (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_update_custom_expression_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  delete_custom_expressions (session, custom_expression_ids, do_soft_delete) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_delete_custom_expressions(session, custom_expression_ids, do_soft_delete);
    });
  }

  send_delete_custom_expressions (session, custom_expression_ids, do_soft_delete) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      custom_expression_ids: custom_expression_ids,
      do_soft_delete: do_soft_delete
    };
    const args = new Heavy_delete_custom_expressions_args(params);
    try {
      output.writeMessageBegin('delete_custom_expressions', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_delete_custom_expressions (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_delete_custom_expressions_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_dashboard (session, dashboard_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_dashboard(session, dashboard_id);
    });
  }

  send_get_dashboard (session, dashboard_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id
    };
    const args = new Heavy_get_dashboard_args(params);
    try {
      output.writeMessageBegin('get_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_dashboard failed: unknown result');
  }

  get_dashboards (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_dashboards(session);
    });
  }

  send_get_dashboards (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_dashboards_args(params);
    try {
      output.writeMessageBegin('get_dashboards', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_dashboards (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_dashboards_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_dashboards failed: unknown result');
  }

  create_dashboard (session, dashboard_name, dashboard_state, image_hash, dashboard_metadata) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_create_dashboard(session, dashboard_name, dashboard_state, image_hash, dashboard_metadata);
    });
  }

  send_create_dashboard (session, dashboard_name, dashboard_state, image_hash, dashboard_metadata) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_name: dashboard_name,
      dashboard_state: dashboard_state,
      image_hash: image_hash,
      dashboard_metadata: dashboard_metadata
    };
    const args = new Heavy_create_dashboard_args(params);
    try {
      output.writeMessageBegin('create_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_create_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_create_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('create_dashboard failed: unknown result');
  }

  replace_dashboard (session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_replace_dashboard(session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata);
    });
  }

  send_replace_dashboard (session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id,
      dashboard_name: dashboard_name,
      dashboard_owner: dashboard_owner,
      dashboard_state: dashboard_state,
      image_hash: image_hash,
      dashboard_metadata: dashboard_metadata
    };
    const args = new Heavy_replace_dashboard_args(params);
    try {
      output.writeMessageBegin('replace_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_replace_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_replace_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  delete_dashboard (session, dashboard_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_delete_dashboard(session, dashboard_id);
    });
  }

  send_delete_dashboard (session, dashboard_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id
    };
    const args = new Heavy_delete_dashboard_args(params);
    try {
      output.writeMessageBegin('delete_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_delete_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_delete_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  share_dashboards (session, dashboard_ids, groups, permissions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_share_dashboards(session, dashboard_ids, groups, permissions);
    });
  }

  send_share_dashboards (session, dashboard_ids, groups, permissions) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_ids: dashboard_ids,
      groups: groups,
      permissions: permissions
    };
    const args = new Heavy_share_dashboards_args(params);
    try {
      output.writeMessageBegin('share_dashboards', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_share_dashboards (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_share_dashboards_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  delete_dashboards (session, dashboard_ids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_delete_dashboards(session, dashboard_ids);
    });
  }

  send_delete_dashboards (session, dashboard_ids) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_ids: dashboard_ids
    };
    const args = new Heavy_delete_dashboards_args(params);
    try {
      output.writeMessageBegin('delete_dashboards', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_delete_dashboards (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_delete_dashboards_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  share_dashboard (session, dashboard_id, groups, objects, permissions, grant_role) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_share_dashboard(session, dashboard_id, groups, objects, permissions, grant_role);
    });
  }

  send_share_dashboard (session, dashboard_id, groups, objects, permissions, grant_role) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id,
      groups: groups,
      objects: objects,
      permissions: permissions,
      grant_role: grant_role
    };
    const args = new Heavy_share_dashboard_args(params);
    try {
      output.writeMessageBegin('share_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_share_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_share_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  unshare_dashboard (session, dashboard_id, groups, objects, permissions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_unshare_dashboard(session, dashboard_id, groups, objects, permissions);
    });
  }

  send_unshare_dashboard (session, dashboard_id, groups, objects, permissions) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id,
      groups: groups,
      objects: objects,
      permissions: permissions
    };
    const args = new Heavy_unshare_dashboard_args(params);
    try {
      output.writeMessageBegin('unshare_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_unshare_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_unshare_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  unshare_dashboards (session, dashboard_ids, groups, permissions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_unshare_dashboards(session, dashboard_ids, groups, permissions);
    });
  }

  send_unshare_dashboards (session, dashboard_ids, groups, permissions) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_ids: dashboard_ids,
      groups: groups,
      permissions: permissions
    };
    const args = new Heavy_unshare_dashboards_args(params);
    try {
      output.writeMessageBegin('unshare_dashboards', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_unshare_dashboards (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_unshare_dashboards_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_dashboard_grantees (session, dashboard_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_dashboard_grantees(session, dashboard_id);
    });
  }

  send_get_dashboard_grantees (session, dashboard_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id
    };
    const args = new Heavy_get_dashboard_grantees_args(params);
    try {
      output.writeMessageBegin('get_dashboard_grantees', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_dashboard_grantees (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_dashboard_grantees_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_dashboard_grantees failed: unknown result');
  }

  get_link_view (session, link) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_link_view(session, link);
    });
  }

  send_get_link_view (session, link) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      link: link
    };
    const args = new Heavy_get_link_view_args(params);
    try {
      output.writeMessageBegin('get_link_view', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_link_view (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_link_view_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_link_view failed: unknown result');
  }

  create_link (session, view_state, view_metadata) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_create_link(session, view_state, view_metadata);
    });
  }

  send_create_link (session, view_state, view_metadata) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      view_state: view_state,
      view_metadata: view_metadata
    };
    const args = new Heavy_create_link_args(params);
    try {
      output.writeMessageBegin('create_link', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_create_link (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_create_link_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('create_link failed: unknown result');
  }

  load_table_binary (session, table_name, rows, column_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table_binary(session, table_name, rows, column_names);
    });
  }

  send_load_table_binary (session, table_name, rows, column_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      rows: rows,
      column_names: column_names
    };
    const args = new Heavy_load_table_binary_args(params);
    try {
      output.writeMessageBegin('load_table_binary', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table_binary (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_binary_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  load_table_binary_columnar (session, table_name, cols, column_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table_binary_columnar(session, table_name, cols, column_names);
    });
  }

  send_load_table_binary_columnar (session, table_name, cols, column_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      cols: cols,
      column_names: column_names
    };
    const args = new Heavy_load_table_binary_columnar_args(params);
    try {
      output.writeMessageBegin('load_table_binary_columnar', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table_binary_columnar (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_binary_columnar_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  load_table_binary_columnar_polys (session, table_name, cols, column_names, assign_render_groups) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table_binary_columnar_polys(session, table_name, cols, column_names, assign_render_groups);
    });
  }

  send_load_table_binary_columnar_polys (session, table_name, cols, column_names, assign_render_groups) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      cols: cols,
      column_names: column_names,
      assign_render_groups: assign_render_groups
    };
    const args = new Heavy_load_table_binary_columnar_polys_args(params);
    try {
      output.writeMessageBegin('load_table_binary_columnar_polys', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table_binary_columnar_polys (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_binary_columnar_polys_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  load_table_binary_arrow (session, table_name, arrow_stream, use_column_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table_binary_arrow(session, table_name, arrow_stream, use_column_names);
    });
  }

  send_load_table_binary_arrow (session, table_name, arrow_stream, use_column_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      arrow_stream: arrow_stream,
      use_column_names: use_column_names
    };
    const args = new Heavy_load_table_binary_arrow_args(params);
    try {
      output.writeMessageBegin('load_table_binary_arrow', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table_binary_arrow (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_binary_arrow_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  load_table (session, table_name, rows, column_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table(session, table_name, rows, column_names);
    });
  }

  send_load_table (session, table_name, rows, column_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      rows: rows,
      column_names: column_names
    };
    const args = new Heavy_load_table_args(params);
    try {
      output.writeMessageBegin('load_table', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  detect_column_types (session, file_name, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_detect_column_types(session, file_name, copy_params);
    });
  }

  send_detect_column_types (session, file_name, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      file_name: file_name,
      copy_params: copy_params
    };
    const args = new Heavy_detect_column_types_args(params);
    try {
      output.writeMessageBegin('detect_column_types', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_detect_column_types (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_detect_column_types_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('detect_column_types failed: unknown result');
  }

  create_table (session, table_name, row_desc, create_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_create_table(session, table_name, row_desc, create_params);
    });
  }

  send_create_table (session, table_name, row_desc, create_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      row_desc: row_desc,
      create_params: create_params
    };
    const args = new Heavy_create_table_args(params);
    try {
      output.writeMessageBegin('create_table', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_create_table (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_create_table_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  import_table (session, table_name, file_name, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_import_table(session, table_name, file_name, copy_params);
    });
  }

  send_import_table (session, table_name, file_name, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      file_name: file_name,
      copy_params: copy_params
    };
    const args = new Heavy_import_table_args(params);
    try {
      output.writeMessageBegin('import_table', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_import_table (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_import_table_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  import_geo_table (session, table_name, file_name, copy_params, row_desc, create_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_import_geo_table(session, table_name, file_name, copy_params, row_desc, create_params);
    });
  }

  send_import_geo_table (session, table_name, file_name, copy_params, row_desc, create_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      file_name: file_name,
      copy_params: copy_params,
      row_desc: row_desc,
      create_params: create_params
    };
    const args = new Heavy_import_geo_table_args(params);
    try {
      output.writeMessageBegin('import_geo_table', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_import_geo_table (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_import_geo_table_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  import_table_status (session, import_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_import_table_status(session, import_id);
    });
  }

  send_import_table_status (session, import_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      import_id: import_id
    };
    const args = new Heavy_import_table_status_args(params);
    try {
      output.writeMessageBegin('import_table_status', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_import_table_status (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_import_table_status_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('import_table_status failed: unknown result');
  }

  get_first_geo_file_in_archive (session, archive_path, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_first_geo_file_in_archive(session, archive_path, copy_params);
    });
  }

  send_get_first_geo_file_in_archive (session, archive_path, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      archive_path: archive_path,
      copy_params: copy_params
    };
    const args = new Heavy_get_first_geo_file_in_archive_args(params);
    try {
      output.writeMessageBegin('get_first_geo_file_in_archive', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_first_geo_file_in_archive (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_first_geo_file_in_archive_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_first_geo_file_in_archive failed: unknown result');
  }

  get_all_files_in_archive (session, archive_path, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_all_files_in_archive(session, archive_path, copy_params);
    });
  }

  send_get_all_files_in_archive (session, archive_path, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      archive_path: archive_path,
      copy_params: copy_params
    };
    const args = new Heavy_get_all_files_in_archive_args(params);
    try {
      output.writeMessageBegin('get_all_files_in_archive', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_all_files_in_archive (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_all_files_in_archive_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_all_files_in_archive failed: unknown result');
  }

  get_layers_in_geo_file (session, file_name, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_layers_in_geo_file(session, file_name, copy_params);
    });
  }

  send_get_layers_in_geo_file (session, file_name, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      file_name: file_name,
      copy_params: copy_params
    };
    const args = new Heavy_get_layers_in_geo_file_args(params);
    try {
      output.writeMessageBegin('get_layers_in_geo_file', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_layers_in_geo_file (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_layers_in_geo_file_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_layers_in_geo_file failed: unknown result');
  }

  query_get_outer_fragment_count (session, query) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_query_get_outer_fragment_count(session, query);
    });
  }

  send_query_get_outer_fragment_count (session, query) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query
    };
    const args = new Heavy_query_get_outer_fragment_count_args(params);
    try {
      output.writeMessageBegin('query_get_outer_fragment_count', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_query_get_outer_fragment_count (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_query_get_outer_fragment_count_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('query_get_outer_fragment_count failed: unknown result');
  }

  check_table_consistency (session, table_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_check_table_consistency(session, table_id);
    });
  }

  send_check_table_consistency (session, table_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_id: table_id
    };
    const args = new Heavy_check_table_consistency_args(params);
    try {
      output.writeMessageBegin('check_table_consistency', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_check_table_consistency (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_check_table_consistency_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('check_table_consistency failed: unknown result');
  }

  start_query (leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_start_query(leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices);
    });
  }

  send_start_query (leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices) {
    const output = new this.pClass(this.output);
    const params = {
      leaf_session: leaf_session,
      parent_session: parent_session,
      query_ra: query_ra,
      start_time_str: start_time_str,
      just_explain: just_explain,
      outer_fragment_indices: outer_fragment_indices
    };
    const args = new Heavy_start_query_args(params);
    try {
      output.writeMessageBegin('start_query', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_start_query (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_start_query_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('start_query failed: unknown result');
  }

  execute_query_step (pending_query, subquery_id, start_time_str) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_execute_query_step(pending_query, subquery_id, start_time_str);
    });
  }

  send_execute_query_step (pending_query, subquery_id, start_time_str) {
    const output = new this.pClass(this.output);
    const params = {
      pending_query: pending_query,
      subquery_id: subquery_id,
      start_time_str: start_time_str
    };
    const args = new Heavy_execute_query_step_args(params);
    try {
      output.writeMessageBegin('execute_query_step', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_execute_query_step (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_execute_query_step_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('execute_query_step failed: unknown result');
  }

  broadcast_serialized_rows (serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_broadcast_serialized_rows(serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result);
    });
  }

  send_broadcast_serialized_rows (serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result) {
    const output = new this.pClass(this.output);
    const params = {
      serialized_rows: serialized_rows,
      row_desc: row_desc,
      query_id: query_id,
      subquery_id: subquery_id,
      is_final_subquery_result: is_final_subquery_result
    };
    const args = new Heavy_broadcast_serialized_rows_args(params);
    try {
      output.writeMessageBegin('broadcast_serialized_rows', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_broadcast_serialized_rows (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_broadcast_serialized_rows_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  start_render_query (session, widget_id, node_idx, vega_json) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_start_render_query(session, widget_id, node_idx, vega_json);
    });
  }

  send_start_render_query (session, widget_id, node_idx, vega_json) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      widget_id: widget_id,
      node_idx: node_idx,
      vega_json: vega_json
    };
    const args = new Heavy_start_render_query_args(params);
    try {
      output.writeMessageBegin('start_render_query', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_start_render_query (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_start_render_query_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('start_render_query failed: unknown result');
  }

  execute_next_render_step (pending_render, merged_data) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_execute_next_render_step(pending_render, merged_data);
    });
  }

  send_execute_next_render_step (pending_render, merged_data) {
    const output = new this.pClass(this.output);
    const params = {
      pending_render: pending_render,
      merged_data: merged_data
    };
    const args = new Heavy_execute_next_render_step_args(params);
    try {
      output.writeMessageBegin('execute_next_render_step', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_execute_next_render_step (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_execute_next_render_step_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('execute_next_render_step failed: unknown result');
  }

  insert_data (session, insert_data) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_insert_data(session, insert_data);
    });
  }

  send_insert_data (session, insert_data) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      insert_data: insert_data
    };
    const args = new Heavy_insert_data_args(params);
    try {
      output.writeMessageBegin('insert_data', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_insert_data (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_insert_data_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  insert_chunks (session, insert_chunks) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_insert_chunks(session, insert_chunks);
    });
  }

  send_insert_chunks (session, insert_chunks) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      insert_chunks: insert_chunks
    };
    const args = new Heavy_insert_chunks_args(params);
    try {
      output.writeMessageBegin('insert_chunks', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_insert_chunks (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_insert_chunks_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  checkpoint (session, table_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_checkpoint(session, table_id);
    });
  }

  send_checkpoint (session, table_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_id: table_id
    };
    const args = new Heavy_checkpoint_args(params);
    try {
      output.writeMessageBegin('checkpoint', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_checkpoint (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_checkpoint_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_roles (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_roles(session);
    });
  }

  send_get_roles (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_roles_args(params);
    try {
      output.writeMessageBegin('get_roles', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_roles (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_roles_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_roles failed: unknown result');
  }

  get_db_objects_for_grantee (session, roleName) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_db_objects_for_grantee(session, roleName);
    });
  }

  send_get_db_objects_for_grantee (session, roleName) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      roleName: roleName
    };
    const args = new Heavy_get_db_objects_for_grantee_args(params);
    try {
      output.writeMessageBegin('get_db_objects_for_grantee', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_db_objects_for_grantee (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_db_objects_for_grantee_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_db_objects_for_grantee failed: unknown result');
  }

  get_db_object_privs (session, objectName, type) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_db_object_privs(session, objectName, type);
    });
  }

  send_get_db_object_privs (session, objectName, type) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      objectName: objectName,
      type: type
    };
    const args = new Heavy_get_db_object_privs_args(params);
    try {
      output.writeMessageBegin('get_db_object_privs', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_db_object_privs (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_db_object_privs_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_db_object_privs failed: unknown result');
  }

  get_all_roles_for_user (session, userName) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_all_roles_for_user(session, userName);
    });
  }

  send_get_all_roles_for_user (session, userName) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      userName: userName
    };
    const args = new Heavy_get_all_roles_for_user_args(params);
    try {
      output.writeMessageBegin('get_all_roles_for_user', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_all_roles_for_user (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_all_roles_for_user_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_all_roles_for_user failed: unknown result');
  }

  get_all_effective_roles_for_user (session, userName) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_all_effective_roles_for_user(session, userName);
    });
  }

  send_get_all_effective_roles_for_user (session, userName) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      userName: userName
    };
    const args = new Heavy_get_all_effective_roles_for_user_args(params);
    try {
      output.writeMessageBegin('get_all_effective_roles_for_user', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_all_effective_roles_for_user (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_all_effective_roles_for_user_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_all_effective_roles_for_user failed: unknown result');
  }

  has_role (session, granteeName, roleName) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_has_role(session, granteeName, roleName);
    });
  }

  send_has_role (session, granteeName, roleName) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      granteeName: granteeName,
      roleName: roleName
    };
    const args = new Heavy_has_role_args(params);
    try {
      output.writeMessageBegin('has_role', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_has_role (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_has_role_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('has_role failed: unknown result');
  }

  has_object_privilege (session, granteeName, ObjectName, objectType, permissions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_has_object_privilege(session, granteeName, ObjectName, objectType, permissions);
    });
  }

  send_has_object_privilege (session, granteeName, ObjectName, objectType, permissions) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      granteeName: granteeName,
      ObjectName: ObjectName,
      objectType: objectType,
      permissions: permissions
    };
    const args = new Heavy_has_object_privilege_args(params);
    try {
      output.writeMessageBegin('has_object_privilege', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_has_object_privilege (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_has_object_privilege_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('has_object_privilege failed: unknown result');
  }

  set_license_key (session, key, nonce) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_license_key(session, key, nonce);
    });
  }

  send_set_license_key (session, key, nonce) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      key: key,
      nonce: nonce
    };
    const args = new Heavy_set_license_key_args(params);
    try {
      output.writeMessageBegin('set_license_key', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_license_key (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_license_key_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('set_license_key failed: unknown result');
  }

  get_license_claims (session, nonce) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_license_claims(session, nonce);
    });
  }

  send_get_license_claims (session, nonce) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      nonce: nonce
    };
    const args = new Heavy_get_license_claims_args(params);
    try {
      output.writeMessageBegin('get_license_claims', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_license_claims (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_license_claims_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_license_claims failed: unknown result');
  }

  get_device_parameters (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_device_parameters(session);
    });
  }

  send_get_device_parameters (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_device_parameters_args(params);
    try {
      output.writeMessageBegin('get_device_parameters', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_device_parameters (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_device_parameters_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_device_parameters failed: unknown result');
  }

  register_runtime_extension_functions (session, udfs, udtfs, device_ir_map) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_register_runtime_extension_functions(session, udfs, udtfs, device_ir_map);
    });
  }

  send_register_runtime_extension_functions (session, udfs, udtfs, device_ir_map) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      udfs: udfs,
      udtfs: udtfs,
      device_ir_map: device_ir_map
    };
    const args = new Heavy_register_runtime_extension_functions_args(params);
    try {
      output.writeMessageBegin('register_runtime_extension_functions', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_register_runtime_extension_functions (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_register_runtime_extension_functions_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_table_function_names (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_function_names(session);
    });
  }

  send_get_table_function_names (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_table_function_names_args(params);
    try {
      output.writeMessageBegin('get_table_function_names', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_function_names (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_function_names_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_function_names failed: unknown result');
  }

  get_runtime_table_function_names (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_runtime_table_function_names(session);
    });
  }

  send_get_runtime_table_function_names (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_runtime_table_function_names_args(params);
    try {
      output.writeMessageBegin('get_runtime_table_function_names', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_runtime_table_function_names (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_runtime_table_function_names_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_runtime_table_function_names failed: unknown result');
  }

  get_table_function_details (session, udtf_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_function_details(session, udtf_names);
    });
  }

  send_get_table_function_details (session, udtf_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      udtf_names: udtf_names
    };
    const args = new Heavy_get_table_function_details_args(params);
    try {
      output.writeMessageBegin('get_table_function_details', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_function_details (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_function_details_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_function_details failed: unknown result');
  }

  get_function_names (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_function_names(session);
    });
  }

  send_get_function_names (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_function_names_args(params);
    try {
      output.writeMessageBegin('get_function_names', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_function_names (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_function_names_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_function_names failed: unknown result');
  }

  get_runtime_function_names (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_runtime_function_names(session);
    });
  }

  send_get_runtime_function_names (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_runtime_function_names_args(params);
    try {
      output.writeMessageBegin('get_runtime_function_names', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_runtime_function_names (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_runtime_function_names_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_runtime_function_names failed: unknown result');
  }

  get_function_details (session, udf_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_function_details(session, udf_names);
    });
  }

  send_get_function_details (session, udf_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      udf_names: udf_names
    };
    const args = new Heavy_get_function_details_args(params);
    try {
      output.writeMessageBegin('get_function_details', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_function_details (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_function_details_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_function_details failed: unknown result');
  }
};
const HeavyProcessor = exports.Processor = class HeavyProcessor {
  constructor(handler) {
    this._handler = handler;
  }
  process (input, output) {
    const r = input.readMessageBegin();
    if (this['process_' + r.fname]) {
      return this['process_' + r.fname].call(this, r.rseqid, input, output);
    } else {
      input.skip(Thrift.Type.STRUCT);
      input.readMessageEnd();
      const x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname);
      output.writeMessageBegin(r.fname, Thrift.MessageType.EXCEPTION, r.rseqid);
      x.write(output);
      output.writeMessageEnd();
      output.flush();
    }
  }
  process_connect (seqid, input, output) {
    const args = new Heavy_connect_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.connect.length === 3) {
      Promise.resolve(this._handler.connect.bind(this._handler)(
        args.user,
        args.passwd,
        args.dbname
      )).then(result => {
        const result_obj = new Heavy_connect_result({success: result});
        output.writeMessageBegin("connect", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_connect_result(err);
          output.writeMessageBegin("connect", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("connect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.connect(args.user, args.passwd, args.dbname, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_connect_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("connect", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("connect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_krb5_connect (seqid, input, output) {
    const args = new Heavy_krb5_connect_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.krb5_connect.length === 2) {
      Promise.resolve(this._handler.krb5_connect.bind(this._handler)(
        args.inputToken,
        args.dbname
      )).then(result => {
        const result_obj = new Heavy_krb5_connect_result({success: result});
        output.writeMessageBegin("krb5_connect", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_krb5_connect_result(err);
          output.writeMessageBegin("krb5_connect", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("krb5_connect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.krb5_connect(args.inputToken, args.dbname, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_krb5_connect_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("krb5_connect", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("krb5_connect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_disconnect (seqid, input, output) {
    const args = new Heavy_disconnect_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.disconnect.length === 1) {
      Promise.resolve(this._handler.disconnect.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_disconnect_result({success: result});
        output.writeMessageBegin("disconnect", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_disconnect_result(err);
          output.writeMessageBegin("disconnect", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("disconnect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.disconnect(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_disconnect_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("disconnect", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("disconnect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_switch_database (seqid, input, output) {
    const args = new Heavy_switch_database_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.switch_database.length === 2) {
      Promise.resolve(this._handler.switch_database.bind(this._handler)(
        args.session,
        args.dbname
      )).then(result => {
        const result_obj = new Heavy_switch_database_result({success: result});
        output.writeMessageBegin("switch_database", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_switch_database_result(err);
          output.writeMessageBegin("switch_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("switch_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.switch_database(args.session, args.dbname, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_switch_database_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("switch_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("switch_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clone_session (seqid, input, output) {
    const args = new Heavy_clone_session_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clone_session.length === 1) {
      Promise.resolve(this._handler.clone_session.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_clone_session_result({success: result});
        output.writeMessageBegin("clone_session", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_clone_session_result(err);
          output.writeMessageBegin("clone_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clone_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clone_session(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_clone_session_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clone_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clone_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_server_status (seqid, input, output) {
    const args = new Heavy_get_server_status_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_server_status.length === 1) {
      Promise.resolve(this._handler.get_server_status.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_server_status_result({success: result});
        output.writeMessageBegin("get_server_status", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_server_status_result(err);
          output.writeMessageBegin("get_server_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_server_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_server_status(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_server_status_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_server_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_server_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_status (seqid, input, output) {
    const args = new Heavy_get_status_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_status.length === 1) {
      Promise.resolve(this._handler.get_status.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_status_result({success: result});
        output.writeMessageBegin("get_status", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_status_result(err);
          output.writeMessageBegin("get_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_status(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_status_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_hardware_info (seqid, input, output) {
    const args = new Heavy_get_hardware_info_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_hardware_info.length === 1) {
      Promise.resolve(this._handler.get_hardware_info.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_hardware_info_result({success: result});
        output.writeMessageBegin("get_hardware_info", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_hardware_info_result(err);
          output.writeMessageBegin("get_hardware_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_hardware_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_hardware_info(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_hardware_info_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_hardware_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_hardware_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_tables (seqid, input, output) {
    const args = new Heavy_get_tables_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_tables.length === 1) {
      Promise.resolve(this._handler.get_tables.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_tables_result({success: result});
        output.writeMessageBegin("get_tables", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_tables_result(err);
          output.writeMessageBegin("get_tables", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_tables(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_tables_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_tables", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_tables_for_database (seqid, input, output) {
    const args = new Heavy_get_tables_for_database_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_tables_for_database.length === 2) {
      Promise.resolve(this._handler.get_tables_for_database.bind(this._handler)(
        args.session,
        args.database_name
      )).then(result => {
        const result_obj = new Heavy_get_tables_for_database_result({success: result});
        output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_tables_for_database_result(err);
          output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_tables_for_database(args.session, args.database_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_tables_for_database_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_physical_tables (seqid, input, output) {
    const args = new Heavy_get_physical_tables_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_physical_tables.length === 1) {
      Promise.resolve(this._handler.get_physical_tables.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_physical_tables_result({success: result});
        output.writeMessageBegin("get_physical_tables", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_physical_tables_result(err);
          output.writeMessageBegin("get_physical_tables", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_physical_tables", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_physical_tables(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_physical_tables_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_physical_tables", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_physical_tables", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_views (seqid, input, output) {
    const args = new Heavy_get_views_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_views.length === 1) {
      Promise.resolve(this._handler.get_views.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_views_result({success: result});
        output.writeMessageBegin("get_views", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_views_result(err);
          output.writeMessageBegin("get_views", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_views", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_views(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_views_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_views", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_views", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_tables_meta (seqid, input, output) {
    const args = new Heavy_get_tables_meta_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_tables_meta.length === 1) {
      Promise.resolve(this._handler.get_tables_meta.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_tables_meta_result({success: result});
        output.writeMessageBegin("get_tables_meta", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_tables_meta_result(err);
          output.writeMessageBegin("get_tables_meta", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables_meta", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_tables_meta(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_tables_meta_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_tables_meta", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables_meta", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_details (seqid, input, output) {
    const args = new Heavy_get_table_details_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_details.length === 2) {
      Promise.resolve(this._handler.get_table_details.bind(this._handler)(
        args.session,
        args.table_name
      )).then(result => {
        const result_obj = new Heavy_get_table_details_result({success: result});
        output.writeMessageBegin("get_table_details", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_table_details_result(err);
          output.writeMessageBegin("get_table_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_details(args.session, args.table_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_table_details_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_details_for_database (seqid, input, output) {
    const args = new Heavy_get_table_details_for_database_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_details_for_database.length === 3) {
      Promise.resolve(this._handler.get_table_details_for_database.bind(this._handler)(
        args.session,
        args.table_name,
        args.database_name
      )).then(result => {
        const result_obj = new Heavy_get_table_details_for_database_result({success: result});
        output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_table_details_for_database_result(err);
          output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_details_for_database(args.session, args.table_name, args.database_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_table_details_for_database_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_internal_table_details (seqid, input, output) {
    const args = new Heavy_get_internal_table_details_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_internal_table_details.length === 3) {
      Promise.resolve(this._handler.get_internal_table_details.bind(this._handler)(
        args.session,
        args.table_name,
        args.include_system_columns
      )).then(result => {
        const result_obj = new Heavy_get_internal_table_details_result({success: result});
        output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_internal_table_details_result(err);
          output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_internal_table_details(args.session, args.table_name, args.include_system_columns, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_internal_table_details_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_internal_table_details_for_database (seqid, input, output) {
    const args = new Heavy_get_internal_table_details_for_database_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_internal_table_details_for_database.length === 3) {
      Promise.resolve(this._handler.get_internal_table_details_for_database.bind(this._handler)(
        args.session,
        args.table_name,
        args.database_name
      )).then(result => {
        const result_obj = new Heavy_get_internal_table_details_for_database_result({success: result});
        output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_internal_table_details_for_database_result(err);
          output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_internal_table_details_for_database(args.session, args.table_name, args.database_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_internal_table_details_for_database_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_users (seqid, input, output) {
    const args = new Heavy_get_users_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_users.length === 1) {
      Promise.resolve(this._handler.get_users.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_users_result({success: result});
        output.writeMessageBegin("get_users", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_users_result(err);
          output.writeMessageBegin("get_users", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_users", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_users(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_users_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_users", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_users", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_databases (seqid, input, output) {
    const args = new Heavy_get_databases_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_databases.length === 1) {
      Promise.resolve(this._handler.get_databases.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_databases_result({success: result});
        output.writeMessageBegin("get_databases", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_databases_result(err);
          output.writeMessageBegin("get_databases", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_databases", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_databases(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_databases_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_databases", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_databases", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_version (seqid, input, output) {
    const args = new Heavy_get_version_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_version.length === 0) {
      Promise.resolve(this._handler.get_version.bind(this._handler)(
      )).then(result => {
        const result_obj = new Heavy_get_version_result({success: result});
        output.writeMessageBegin("get_version", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_version_result(err);
          output.writeMessageBegin("get_version", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_version", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_version((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_version_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_version", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_version", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_start_heap_profile (seqid, input, output) {
    const args = new Heavy_start_heap_profile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.start_heap_profile.length === 1) {
      Promise.resolve(this._handler.start_heap_profile.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_start_heap_profile_result({success: result});
        output.writeMessageBegin("start_heap_profile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_start_heap_profile_result(err);
          output.writeMessageBegin("start_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.start_heap_profile(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_start_heap_profile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("start_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_stop_heap_profile (seqid, input, output) {
    const args = new Heavy_stop_heap_profile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.stop_heap_profile.length === 1) {
      Promise.resolve(this._handler.stop_heap_profile.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_stop_heap_profile_result({success: result});
        output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_stop_heap_profile_result(err);
          output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.stop_heap_profile(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_stop_heap_profile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_heap_profile (seqid, input, output) {
    const args = new Heavy_get_heap_profile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_heap_profile.length === 1) {
      Promise.resolve(this._handler.get_heap_profile.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_heap_profile_result({success: result});
        output.writeMessageBegin("get_heap_profile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_heap_profile_result(err);
          output.writeMessageBegin("get_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_heap_profile(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_heap_profile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_memory (seqid, input, output) {
    const args = new Heavy_get_memory_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_memory.length === 2) {
      Promise.resolve(this._handler.get_memory.bind(this._handler)(
        args.session,
        args.memory_level
      )).then(result => {
        const result_obj = new Heavy_get_memory_result({success: result});
        output.writeMessageBegin("get_memory", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_memory_result(err);
          output.writeMessageBegin("get_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_memory(args.session, args.memory_level, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_memory_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clear_cpu_memory (seqid, input, output) {
    const args = new Heavy_clear_cpu_memory_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clear_cpu_memory.length === 1) {
      Promise.resolve(this._handler.clear_cpu_memory.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_clear_cpu_memory_result({success: result});
        output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_clear_cpu_memory_result(err);
          output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clear_cpu_memory(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_clear_cpu_memory_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clear_gpu_memory (seqid, input, output) {
    const args = new Heavy_clear_gpu_memory_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clear_gpu_memory.length === 1) {
      Promise.resolve(this._handler.clear_gpu_memory.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_clear_gpu_memory_result({success: result});
        output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_clear_gpu_memory_result(err);
          output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clear_gpu_memory(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_clear_gpu_memory_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_cur_session (seqid, input, output) {
    const args = new Heavy_set_cur_session_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_cur_session.length === 5) {
      Promise.resolve(this._handler.set_cur_session.bind(this._handler)(
        args.parent_session,
        args.leaf_session,
        args.start_time_str,
        args.label,
        args.for_running_query_kernel
      )).then(result => {
        const result_obj = new Heavy_set_cur_session_result({success: result});
        output.writeMessageBegin("set_cur_session", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_cur_session_result(err);
          output.writeMessageBegin("set_cur_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_cur_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_cur_session(args.parent_session, args.leaf_session, args.start_time_str, args.label, args.for_running_query_kernel, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_cur_session_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_cur_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_cur_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_invalidate_cur_session (seqid, input, output) {
    const args = new Heavy_invalidate_cur_session_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.invalidate_cur_session.length === 5) {
      Promise.resolve(this._handler.invalidate_cur_session.bind(this._handler)(
        args.parent_session,
        args.leaf_session,
        args.start_time_str,
        args.label,
        args.for_running_query_kernel
      )).then(result => {
        const result_obj = new Heavy_invalidate_cur_session_result({success: result});
        output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_invalidate_cur_session_result(err);
          output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.invalidate_cur_session(args.parent_session, args.leaf_session, args.start_time_str, args.label, args.for_running_query_kernel, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_invalidate_cur_session_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_table_epoch (seqid, input, output) {
    const args = new Heavy_set_table_epoch_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_table_epoch.length === 4) {
      Promise.resolve(this._handler.set_table_epoch.bind(this._handler)(
        args.session,
        args.db_id,
        args.table_id,
        args.new_epoch
      )).then(result => {
        const result_obj = new Heavy_set_table_epoch_result({success: result});
        output.writeMessageBegin("set_table_epoch", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_table_epoch_result(err);
          output.writeMessageBegin("set_table_epoch", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epoch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_table_epoch(args.session, args.db_id, args.table_id, args.new_epoch, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_table_epoch_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_table_epoch", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epoch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_table_epoch_by_name (seqid, input, output) {
    const args = new Heavy_set_table_epoch_by_name_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_table_epoch_by_name.length === 3) {
      Promise.resolve(this._handler.set_table_epoch_by_name.bind(this._handler)(
        args.session,
        args.table_name,
        args.new_epoch
      )).then(result => {
        const result_obj = new Heavy_set_table_epoch_by_name_result({success: result});
        output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_table_epoch_by_name_result(err);
          output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_table_epoch_by_name(args.session, args.table_name, args.new_epoch, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_table_epoch_by_name_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_epoch (seqid, input, output) {
    const args = new Heavy_get_table_epoch_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_epoch.length === 3) {
      Promise.resolve(this._handler.get_table_epoch.bind(this._handler)(
        args.session,
        args.db_id,
        args.table_id
      )).then(result => {
        const result_obj = new Heavy_get_table_epoch_result({success: result});
        output.writeMessageBegin("get_table_epoch", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("get_table_epoch", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_epoch(args.session, args.db_id, args.table_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new Heavy_get_table_epoch_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_epoch", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_epoch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_epoch_by_name (seqid, input, output) {
    const args = new Heavy_get_table_epoch_by_name_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_epoch_by_name.length === 2) {
      Promise.resolve(this._handler.get_table_epoch_by_name.bind(this._handler)(
        args.session,
        args.table_name
      )).then(result => {
        const result_obj = new Heavy_get_table_epoch_by_name_result({success: result});
        output.writeMessageBegin("get_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("get_table_epoch_by_name", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_epoch_by_name(args.session, args.table_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new Heavy_get_table_epoch_by_name_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_epoch_by_name", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_epochs (seqid, input, output) {
    const args = new Heavy_get_table_epochs_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_epochs.length === 3) {
      Promise.resolve(this._handler.get_table_epochs.bind(this._handler)(
        args.session,
        args.db_id,
        args.table_id
      )).then(result => {
        const result_obj = new Heavy_get_table_epochs_result({success: result});
        output.writeMessageBegin("get_table_epochs", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("get_table_epochs", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_epochs(args.session, args.db_id, args.table_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new Heavy_get_table_epochs_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_epochs", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_epochs", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_table_epochs (seqid, input, output) {
    const args = new Heavy_set_table_epochs_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_table_epochs.length === 3) {
      Promise.resolve(this._handler.set_table_epochs.bind(this._handler)(
        args.session,
        args.db_id,
        args.table_epochs
      )).then(result => {
        const result_obj = new Heavy_set_table_epochs_result({success: result});
        output.writeMessageBegin("set_table_epochs", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("set_table_epochs", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_table_epochs(args.session, args.db_id, args.table_epochs, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new Heavy_set_table_epochs_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_table_epochs", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epochs", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_session_info (seqid, input, output) {
    const args = new Heavy_get_session_info_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_session_info.length === 1) {
      Promise.resolve(this._handler.get_session_info.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_session_info_result({success: result});
        output.writeMessageBegin("get_session_info", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_session_info_result(err);
          output.writeMessageBegin("get_session_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_session_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_session_info(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_session_info_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_session_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_session_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_queries_info (seqid, input, output) {
    const args = new Heavy_get_queries_info_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_queries_info.length === 1) {
      Promise.resolve(this._handler.get_queries_info.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_queries_info_result({success: result});
        output.writeMessageBegin("get_queries_info", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_queries_info_result(err);
          output.writeMessageBegin("get_queries_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_queries_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_queries_info(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_queries_info_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_queries_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_queries_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_leaf_info (seqid, input, output) {
    const args = new Heavy_set_leaf_info_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_leaf_info.length === 2) {
      Promise.resolve(this._handler.set_leaf_info.bind(this._handler)(
        args.session,
        args.leaf_info
      )).then(result => {
        const result_obj = new Heavy_set_leaf_info_result({success: result});
        output.writeMessageBegin("set_leaf_info", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_leaf_info_result(err);
          output.writeMessageBegin("set_leaf_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_leaf_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_leaf_info(args.session, args.leaf_info, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_leaf_info_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_leaf_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_leaf_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sql_execute (seqid, input, output) {
    const args = new Heavy_sql_execute_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sql_execute.length === 6) {
      Promise.resolve(this._handler.sql_execute.bind(this._handler)(
        args.session,
        args.query,
        args.column_format,
        args.nonce,
        args.first_n,
        args.at_most_n
      )).then(result => {
        const result_obj = new Heavy_sql_execute_result({success: result});
        output.writeMessageBegin("sql_execute", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_sql_execute_result(err);
          output.writeMessageBegin("sql_execute", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sql_execute(args.session, args.query, args.column_format, args.nonce, args.first_n, args.at_most_n, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_sql_execute_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sql_execute", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sql_execute_df (seqid, input, output) {
    const args = new Heavy_sql_execute_df_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sql_execute_df.length === 6) {
      Promise.resolve(this._handler.sql_execute_df.bind(this._handler)(
        args.session,
        args.query,
        args.device_type,
        args.device_id,
        args.first_n,
        args.transport_method
      )).then(result => {
        const result_obj = new Heavy_sql_execute_df_result({success: result});
        output.writeMessageBegin("sql_execute_df", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_sql_execute_df_result(err);
          output.writeMessageBegin("sql_execute_df", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute_df", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sql_execute_df(args.session, args.query, args.device_type, args.device_id, args.first_n, args.transport_method, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_sql_execute_df_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sql_execute_df", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute_df", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sql_execute_gdf (seqid, input, output) {
    const args = new Heavy_sql_execute_gdf_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sql_execute_gdf.length === 4) {
      Promise.resolve(this._handler.sql_execute_gdf.bind(this._handler)(
        args.session,
        args.query,
        args.device_id,
        args.first_n
      )).then(result => {
        const result_obj = new Heavy_sql_execute_gdf_result({success: result});
        output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_sql_execute_gdf_result(err);
          output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sql_execute_gdf(args.session, args.query, args.device_id, args.first_n, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_sql_execute_gdf_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_deallocate_df (seqid, input, output) {
    const args = new Heavy_deallocate_df_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.deallocate_df.length === 4) {
      Promise.resolve(this._handler.deallocate_df.bind(this._handler)(
        args.session,
        args.df,
        args.device_type,
        args.device_id
      )).then(result => {
        const result_obj = new Heavy_deallocate_df_result({success: result});
        output.writeMessageBegin("deallocate_df", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_deallocate_df_result(err);
          output.writeMessageBegin("deallocate_df", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("deallocate_df", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.deallocate_df(args.session, args.df, args.device_type, args.device_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_deallocate_df_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("deallocate_df", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("deallocate_df", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_interrupt (seqid, input, output) {
    const args = new Heavy_interrupt_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.interrupt.length === 2) {
      Promise.resolve(this._handler.interrupt.bind(this._handler)(
        args.query_session,
        args.interrupt_session
      )).then(result => {
        const result_obj = new Heavy_interrupt_result({success: result});
        output.writeMessageBegin("interrupt", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_interrupt_result(err);
          output.writeMessageBegin("interrupt", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("interrupt", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.interrupt(args.query_session, args.interrupt_session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_interrupt_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("interrupt", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("interrupt", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sql_validate (seqid, input, output) {
    const args = new Heavy_sql_validate_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sql_validate.length === 2) {
      Promise.resolve(this._handler.sql_validate.bind(this._handler)(
        args.session,
        args.query
      )).then(result => {
        const result_obj = new Heavy_sql_validate_result({success: result});
        output.writeMessageBegin("sql_validate", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_sql_validate_result(err);
          output.writeMessageBegin("sql_validate", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_validate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sql_validate(args.session, args.query, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_sql_validate_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sql_validate", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_validate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_completion_hints (seqid, input, output) {
    const args = new Heavy_get_completion_hints_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_completion_hints.length === 3) {
      Promise.resolve(this._handler.get_completion_hints.bind(this._handler)(
        args.session,
        args.sql,
        args.cursor
      )).then(result => {
        const result_obj = new Heavy_get_completion_hints_result({success: result});
        output.writeMessageBegin("get_completion_hints", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_completion_hints_result(err);
          output.writeMessageBegin("get_completion_hints", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_completion_hints", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_completion_hints(args.session, args.sql, args.cursor, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_completion_hints_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_completion_hints", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_completion_hints", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_execution_mode (seqid, input, output) {
    const args = new Heavy_set_execution_mode_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_execution_mode.length === 2) {
      Promise.resolve(this._handler.set_execution_mode.bind(this._handler)(
        args.session,
        args.mode
      )).then(result => {
        const result_obj = new Heavy_set_execution_mode_result({success: result});
        output.writeMessageBegin("set_execution_mode", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_execution_mode_result(err);
          output.writeMessageBegin("set_execution_mode", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_execution_mode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_execution_mode(args.session, args.mode, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_execution_mode_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_execution_mode", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_execution_mode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_render_vega (seqid, input, output) {
    const args = new Heavy_render_vega_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.render_vega.length === 5) {
      Promise.resolve(this._handler.render_vega.bind(this._handler)(
        args.session,
        args.widget_id,
        args.vega_json,
        args.compression_level,
        args.nonce
      )).then(result => {
        const result_obj = new Heavy_render_vega_result({success: result});
        output.writeMessageBegin("render_vega", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_render_vega_result(err);
          output.writeMessageBegin("render_vega", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("render_vega", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.render_vega(args.session, args.widget_id, args.vega_json, args.compression_level, args.nonce, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_render_vega_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("render_vega", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("render_vega", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_result_row_for_pixel (seqid, input, output) {
    const args = new Heavy_get_result_row_for_pixel_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_result_row_for_pixel.length === 7) {
      Promise.resolve(this._handler.get_result_row_for_pixel.bind(this._handler)(
        args.session,
        args.widget_id,
        args.pixel,
        args.table_col_names,
        args.column_format,
        args.pixelRadius,
        args.nonce
      )).then(result => {
        const result_obj = new Heavy_get_result_row_for_pixel_result({success: result});
        output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_result_row_for_pixel_result(err);
          output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_result_row_for_pixel(args.session, args.widget_id, args.pixel, args.table_col_names, args.column_format, args.pixelRadius, args.nonce, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_result_row_for_pixel_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_create_custom_expression (seqid, input, output) {
    const args = new Heavy_create_custom_expression_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.create_custom_expression.length === 2) {
      Promise.resolve(this._handler.create_custom_expression.bind(this._handler)(
        args.session,
        args.custom_expression
      )).then(result => {
        const result_obj = new Heavy_create_custom_expression_result({success: result});
        output.writeMessageBegin("create_custom_expression", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_create_custom_expression_result(err);
          output.writeMessageBegin("create_custom_expression", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_custom_expression", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.create_custom_expression(args.session, args.custom_expression, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_create_custom_expression_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("create_custom_expression", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_custom_expression", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_custom_expressions (seqid, input, output) {
    const args = new Heavy_get_custom_expressions_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_custom_expressions.length === 1) {
      Promise.resolve(this._handler.get_custom_expressions.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_custom_expressions_result({success: result});
        output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_custom_expressions_result(err);
          output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_custom_expressions(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_custom_expressions_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_update_custom_expression (seqid, input, output) {
    const args = new Heavy_update_custom_expression_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.update_custom_expression.length === 3) {
      Promise.resolve(this._handler.update_custom_expression.bind(this._handler)(
        args.session,
        args.id,
        args.expression_json
      )).then(result => {
        const result_obj = new Heavy_update_custom_expression_result({success: result});
        output.writeMessageBegin("update_custom_expression", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_update_custom_expression_result(err);
          output.writeMessageBegin("update_custom_expression", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("update_custom_expression", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.update_custom_expression(args.session, args.id, args.expression_json, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_update_custom_expression_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("update_custom_expression", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("update_custom_expression", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_delete_custom_expressions (seqid, input, output) {
    const args = new Heavy_delete_custom_expressions_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.delete_custom_expressions.length === 3) {
      Promise.resolve(this._handler.delete_custom_expressions.bind(this._handler)(
        args.session,
        args.custom_expression_ids,
        args.do_soft_delete
      )).then(result => {
        const result_obj = new Heavy_delete_custom_expressions_result({success: result});
        output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_delete_custom_expressions_result(err);
          output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.delete_custom_expressions(args.session, args.custom_expression_ids, args.do_soft_delete, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_delete_custom_expressions_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_dashboard (seqid, input, output) {
    const args = new Heavy_get_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_dashboard.length === 2) {
      Promise.resolve(this._handler.get_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id
      )).then(result => {
        const result_obj = new Heavy_get_dashboard_result({success: result});
        output.writeMessageBegin("get_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_dashboard_result(err);
          output.writeMessageBegin("get_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_dashboard(args.session, args.dashboard_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_dashboards (seqid, input, output) {
    const args = new Heavy_get_dashboards_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_dashboards.length === 1) {
      Promise.resolve(this._handler.get_dashboards.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_dashboards_result({success: result});
        output.writeMessageBegin("get_dashboards", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_dashboards_result(err);
          output.writeMessageBegin("get_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_dashboards(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_dashboards_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_create_dashboard (seqid, input, output) {
    const args = new Heavy_create_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.create_dashboard.length === 5) {
      Promise.resolve(this._handler.create_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_name,
        args.dashboard_state,
        args.image_hash,
        args.dashboard_metadata
      )).then(result => {
        const result_obj = new Heavy_create_dashboard_result({success: result});
        output.writeMessageBegin("create_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_create_dashboard_result(err);
          output.writeMessageBegin("create_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.create_dashboard(args.session, args.dashboard_name, args.dashboard_state, args.image_hash, args.dashboard_metadata, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_create_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("create_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_replace_dashboard (seqid, input, output) {
    const args = new Heavy_replace_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.replace_dashboard.length === 7) {
      Promise.resolve(this._handler.replace_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id,
        args.dashboard_name,
        args.dashboard_owner,
        args.dashboard_state,
        args.image_hash,
        args.dashboard_metadata
      )).then(result => {
        const result_obj = new Heavy_replace_dashboard_result({success: result});
        output.writeMessageBegin("replace_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_replace_dashboard_result(err);
          output.writeMessageBegin("replace_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("replace_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.replace_dashboard(args.session, args.dashboard_id, args.dashboard_name, args.dashboard_owner, args.dashboard_state, args.image_hash, args.dashboard_metadata, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_replace_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("replace_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("replace_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_delete_dashboard (seqid, input, output) {
    const args = new Heavy_delete_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.delete_dashboard.length === 2) {
      Promise.resolve(this._handler.delete_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id
      )).then(result => {
        const result_obj = new Heavy_delete_dashboard_result({success: result});
        output.writeMessageBegin("delete_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_delete_dashboard_result(err);
          output.writeMessageBegin("delete_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.delete_dashboard(args.session, args.dashboard_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_delete_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("delete_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_share_dashboards (seqid, input, output) {
    const args = new Heavy_share_dashboards_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.share_dashboards.length === 4) {
      Promise.resolve(this._handler.share_dashboards.bind(this._handler)(
        args.session,
        args.dashboard_ids,
        args.groups,
        args.permissions
      )).then(result => {
        const result_obj = new Heavy_share_dashboards_result({success: result});
        output.writeMessageBegin("share_dashboards", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_share_dashboards_result(err);
          output.writeMessageBegin("share_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("share_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.share_dashboards(args.session, args.dashboard_ids, args.groups, args.permissions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_share_dashboards_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("share_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("share_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_delete_dashboards (seqid, input, output) {
    const args = new Heavy_delete_dashboards_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.delete_dashboards.length === 2) {
      Promise.resolve(this._handler.delete_dashboards.bind(this._handler)(
        args.session,
        args.dashboard_ids
      )).then(result => {
        const result_obj = new Heavy_delete_dashboards_result({success: result});
        output.writeMessageBegin("delete_dashboards", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_delete_dashboards_result(err);
          output.writeMessageBegin("delete_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.delete_dashboards(args.session, args.dashboard_ids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_delete_dashboards_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("delete_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_share_dashboard (seqid, input, output) {
    const args = new Heavy_share_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.share_dashboard.length === 6) {
      Promise.resolve(this._handler.share_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id,
        args.groups,
        args.objects,
        args.permissions,
        args.grant_role
      )).then(result => {
        const result_obj = new Heavy_share_dashboard_result({success: result});
        output.writeMessageBegin("share_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_share_dashboard_result(err);
          output.writeMessageBegin("share_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("share_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.share_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions, args.grant_role, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_share_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("share_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("share_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_unshare_dashboard (seqid, input, output) {
    const args = new Heavy_unshare_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.unshare_dashboard.length === 5) {
      Promise.resolve(this._handler.unshare_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id,
        args.groups,
        args.objects,
        args.permissions
      )).then(result => {
        const result_obj = new Heavy_unshare_dashboard_result({success: result});
        output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_unshare_dashboard_result(err);
          output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.unshare_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_unshare_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_unshare_dashboards (seqid, input, output) {
    const args = new Heavy_unshare_dashboards_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.unshare_dashboards.length === 4) {
      Promise.resolve(this._handler.unshare_dashboards.bind(this._handler)(
        args.session,
        args.dashboard_ids,
        args.groups,
        args.permissions
      )).then(result => {
        const result_obj = new Heavy_unshare_dashboards_result({success: result});
        output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_unshare_dashboards_result(err);
          output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.unshare_dashboards(args.session, args.dashboard_ids, args.groups, args.permissions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_unshare_dashboards_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_dashboard_grantees (seqid, input, output) {
    const args = new Heavy_get_dashboard_grantees_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_dashboard_grantees.length === 2) {
      Promise.resolve(this._handler.get_dashboard_grantees.bind(this._handler)(
        args.session,
        args.dashboard_id
      )).then(result => {
        const result_obj = new Heavy_get_dashboard_grantees_result({success: result});
        output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_dashboard_grantees_result(err);
          output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_dashboard_grantees(args.session, args.dashboard_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_dashboard_grantees_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_link_view (seqid, input, output) {
    const args = new Heavy_get_link_view_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_link_view.length === 2) {
      Promise.resolve(this._handler.get_link_view.bind(this._handler)(
        args.session,
        args.link
      )).then(result => {
        const result_obj = new Heavy_get_link_view_result({success: result});
        output.writeMessageBegin("get_link_view", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_link_view_result(err);
          output.writeMessageBegin("get_link_view", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_link_view", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_link_view(args.session, args.link, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_link_view_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_link_view", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_link_view", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_create_link (seqid, input, output) {
    const args = new Heavy_create_link_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.create_link.length === 3) {
      Promise.resolve(this._handler.create_link.bind(this._handler)(
        args.session,
        args.view_state,
        args.view_metadata
      )).then(result => {
        const result_obj = new Heavy_create_link_result({success: result});
        output.writeMessageBegin("create_link", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_create_link_result(err);
          output.writeMessageBegin("create_link", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_link", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.create_link(args.session, args.view_state, args.view_metadata, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_create_link_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("create_link", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_link", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table_binary (seqid, input, output) {
    const args = new Heavy_load_table_binary_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table_binary.length === 4) {
      Promise.resolve(this._handler.load_table_binary.bind(this._handler)(
        args.session,
        args.table_name,
        args.rows,
        args.column_names
      )).then(result => {
        const result_obj = new Heavy_load_table_binary_result({success: result});
        output.writeMessageBegin("load_table_binary", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_binary_result(err);
          output.writeMessageBegin("load_table_binary", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table_binary(args.session, args.table_name, args.rows, args.column_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_binary_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table_binary", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table_binary_columnar (seqid, input, output) {
    const args = new Heavy_load_table_binary_columnar_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table_binary_columnar.length === 4) {
      Promise.resolve(this._handler.load_table_binary_columnar.bind(this._handler)(
        args.session,
        args.table_name,
        args.cols,
        args.column_names
      )).then(result => {
        const result_obj = new Heavy_load_table_binary_columnar_result({success: result});
        output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_binary_columnar_result(err);
          output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table_binary_columnar(args.session, args.table_name, args.cols, args.column_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_binary_columnar_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table_binary_columnar_polys (seqid, input, output) {
    const args = new Heavy_load_table_binary_columnar_polys_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table_binary_columnar_polys.length === 5) {
      Promise.resolve(this._handler.load_table_binary_columnar_polys.bind(this._handler)(
        args.session,
        args.table_name,
        args.cols,
        args.column_names,
        args.assign_render_groups
      )).then(result => {
        const result_obj = new Heavy_load_table_binary_columnar_polys_result({success: result});
        output.writeMessageBegin("load_table_binary_columnar_polys", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_binary_columnar_polys_result(err);
          output.writeMessageBegin("load_table_binary_columnar_polys", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_columnar_polys", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table_binary_columnar_polys(args.session, args.table_name, args.cols, args.column_names, args.assign_render_groups, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_binary_columnar_polys_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table_binary_columnar_polys", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_columnar_polys", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table_binary_arrow (seqid, input, output) {
    const args = new Heavy_load_table_binary_arrow_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table_binary_arrow.length === 4) {
      Promise.resolve(this._handler.load_table_binary_arrow.bind(this._handler)(
        args.session,
        args.table_name,
        args.arrow_stream,
        args.use_column_names
      )).then(result => {
        const result_obj = new Heavy_load_table_binary_arrow_result({success: result});
        output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_binary_arrow_result(err);
          output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table_binary_arrow(args.session, args.table_name, args.arrow_stream, args.use_column_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_binary_arrow_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table (seqid, input, output) {
    const args = new Heavy_load_table_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table.length === 4) {
      Promise.resolve(this._handler.load_table.bind(this._handler)(
        args.session,
        args.table_name,
        args.rows,
        args.column_names
      )).then(result => {
        const result_obj = new Heavy_load_table_result({success: result});
        output.writeMessageBegin("load_table", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_result(err);
          output.writeMessageBegin("load_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table(args.session, args.table_name, args.rows, args.column_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_detect_column_types (seqid, input, output) {
    const args = new Heavy_detect_column_types_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.detect_column_types.length === 3) {
      Promise.resolve(this._handler.detect_column_types.bind(this._handler)(
        args.session,
        args.file_name,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_detect_column_types_result({success: result});
        output.writeMessageBegin("detect_column_types", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_detect_column_types_result(err);
          output.writeMessageBegin("detect_column_types", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("detect_column_types", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.detect_column_types(args.session, args.file_name, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_detect_column_types_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("detect_column_types", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("detect_column_types", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_create_table (seqid, input, output) {
    const args = new Heavy_create_table_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.create_table.length === 4) {
      Promise.resolve(this._handler.create_table.bind(this._handler)(
        args.session,
        args.table_name,
        args.row_desc,
        args.create_params
      )).then(result => {
        const result_obj = new Heavy_create_table_result({success: result});
        output.writeMessageBegin("create_table", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_create_table_result(err);
          output.writeMessageBegin("create_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.create_table(args.session, args.table_name, args.row_desc, args.create_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_create_table_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("create_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_import_table (seqid, input, output) {
    const args = new Heavy_import_table_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.import_table.length === 4) {
      Promise.resolve(this._handler.import_table.bind(this._handler)(
        args.session,
        args.table_name,
        args.file_name,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_import_table_result({success: result});
        output.writeMessageBegin("import_table", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_import_table_result(err);
          output.writeMessageBegin("import_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.import_table(args.session, args.table_name, args.file_name, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_import_table_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("import_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_import_geo_table (seqid, input, output) {
    const args = new Heavy_import_geo_table_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.import_geo_table.length === 6) {
      Promise.resolve(this._handler.import_geo_table.bind(this._handler)(
        args.session,
        args.table_name,
        args.file_name,
        args.copy_params,
        args.row_desc,
        args.create_params
      )).then(result => {
        const result_obj = new Heavy_import_geo_table_result({success: result});
        output.writeMessageBegin("import_geo_table", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_import_geo_table_result(err);
          output.writeMessageBegin("import_geo_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_geo_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.import_geo_table(args.session, args.table_name, args.file_name, args.copy_params, args.row_desc, args.create_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_import_geo_table_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("import_geo_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_geo_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_import_table_status (seqid, input, output) {
    const args = new Heavy_import_table_status_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.import_table_status.length === 2) {
      Promise.resolve(this._handler.import_table_status.bind(this._handler)(
        args.session,
        args.import_id
      )).then(result => {
        const result_obj = new Heavy_import_table_status_result({success: result});
        output.writeMessageBegin("import_table_status", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_import_table_status_result(err);
          output.writeMessageBegin("import_table_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_table_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.import_table_status(args.session, args.import_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_import_table_status_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("import_table_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_table_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_first_geo_file_in_archive (seqid, input, output) {
    const args = new Heavy_get_first_geo_file_in_archive_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_first_geo_file_in_archive.length === 3) {
      Promise.resolve(this._handler.get_first_geo_file_in_archive.bind(this._handler)(
        args.session,
        args.archive_path,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_get_first_geo_file_in_archive_result({success: result});
        output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_first_geo_file_in_archive_result(err);
          output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_first_geo_file_in_archive(args.session, args.archive_path, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_first_geo_file_in_archive_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_all_files_in_archive (seqid, input, output) {
    const args = new Heavy_get_all_files_in_archive_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_all_files_in_archive.length === 3) {
      Promise.resolve(this._handler.get_all_files_in_archive.bind(this._handler)(
        args.session,
        args.archive_path,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_get_all_files_in_archive_result({success: result});
        output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_all_files_in_archive_result(err);
          output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_all_files_in_archive(args.session, args.archive_path, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_all_files_in_archive_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_layers_in_geo_file (seqid, input, output) {
    const args = new Heavy_get_layers_in_geo_file_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_layers_in_geo_file.length === 3) {
      Promise.resolve(this._handler.get_layers_in_geo_file.bind(this._handler)(
        args.session,
        args.file_name,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_get_layers_in_geo_file_result({success: result});
        output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_layers_in_geo_file_result(err);
          output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_layers_in_geo_file(args.session, args.file_name, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_layers_in_geo_file_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_query_get_outer_fragment_count (seqid, input, output) {
    const args = new Heavy_query_get_outer_fragment_count_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.query_get_outer_fragment_count.length === 2) {
      Promise.resolve(this._handler.query_get_outer_fragment_count.bind(this._handler)(
        args.session,
        args.query
      )).then(result => {
        const result_obj = new Heavy_query_get_outer_fragment_count_result({success: result});
        output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_query_get_outer_fragment_count_result(err);
          output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.query_get_outer_fragment_count(args.session, args.query, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_query_get_outer_fragment_count_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_check_table_consistency (seqid, input, output) {
    const args = new Heavy_check_table_consistency_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.check_table_consistency.length === 2) {
      Promise.resolve(this._handler.check_table_consistency.bind(this._handler)(
        args.session,
        args.table_id
      )).then(result => {
        const result_obj = new Heavy_check_table_consistency_result({success: result});
        output.writeMessageBegin("check_table_consistency", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_check_table_consistency_result(err);
          output.writeMessageBegin("check_table_consistency", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("check_table_consistency", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.check_table_consistency(args.session, args.table_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_check_table_consistency_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("check_table_consistency", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("check_table_consistency", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_start_query (seqid, input, output) {
    const args = new Heavy_start_query_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.start_query.length === 6) {
      Promise.resolve(this._handler.start_query.bind(this._handler)(
        args.leaf_session,
        args.parent_session,
        args.query_ra,
        args.start_time_str,
        args.just_explain,
        args.outer_fragment_indices
      )).then(result => {
        const result_obj = new Heavy_start_query_result({success: result});
        output.writeMessageBegin("start_query", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_start_query_result(err);
          output.writeMessageBegin("start_query", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_query", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.start_query(args.leaf_session, args.parent_session, args.query_ra, args.start_time_str, args.just_explain, args.outer_fragment_indices, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_start_query_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("start_query", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_query", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_execute_query_step (seqid, input, output) {
    const args = new Heavy_execute_query_step_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.execute_query_step.length === 3) {
      Promise.resolve(this._handler.execute_query_step.bind(this._handler)(
        args.pending_query,
        args.subquery_id,
        args.start_time_str
      )).then(result => {
        const result_obj = new Heavy_execute_query_step_result({success: result});
        output.writeMessageBegin("execute_query_step", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_execute_query_step_result(err);
          output.writeMessageBegin("execute_query_step", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("execute_query_step", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.execute_query_step(args.pending_query, args.subquery_id, args.start_time_str, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_execute_query_step_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("execute_query_step", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("execute_query_step", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_broadcast_serialized_rows (seqid, input, output) {
    const args = new Heavy_broadcast_serialized_rows_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.broadcast_serialized_rows.length === 5) {
      Promise.resolve(this._handler.broadcast_serialized_rows.bind(this._handler)(
        args.serialized_rows,
        args.row_desc,
        args.query_id,
        args.subquery_id,
        args.is_final_subquery_result
      )).then(result => {
        const result_obj = new Heavy_broadcast_serialized_rows_result({success: result});
        output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_broadcast_serialized_rows_result(err);
          output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.broadcast_serialized_rows(args.serialized_rows, args.row_desc, args.query_id, args.subquery_id, args.is_final_subquery_result, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_broadcast_serialized_rows_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_start_render_query (seqid, input, output) {
    const args = new Heavy_start_render_query_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.start_render_query.length === 4) {
      Promise.resolve(this._handler.start_render_query.bind(this._handler)(
        args.session,
        args.widget_id,
        args.node_idx,
        args.vega_json
      )).then(result => {
        const result_obj = new Heavy_start_render_query_result({success: result});
        output.writeMessageBegin("start_render_query", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_start_render_query_result(err);
          output.writeMessageBegin("start_render_query", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_render_query", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.start_render_query(args.session, args.widget_id, args.node_idx, args.vega_json, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_start_render_query_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("start_render_query", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_render_query", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_execute_next_render_step (seqid, input, output) {
    const args = new Heavy_execute_next_render_step_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.execute_next_render_step.length === 2) {
      Promise.resolve(this._handler.execute_next_render_step.bind(this._handler)(
        args.pending_render,
        args.merged_data
      )).then(result => {
        const result_obj = new Heavy_execute_next_render_step_result({success: result});
        output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_execute_next_render_step_result(err);
          output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.execute_next_render_step(args.pending_render, args.merged_data, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_execute_next_render_step_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_insert_data (seqid, input, output) {
    const args = new Heavy_insert_data_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.insert_data.length === 2) {
      Promise.resolve(this._handler.insert_data.bind(this._handler)(
        args.session,
        args.insert_data
      )).then(result => {
        const result_obj = new Heavy_insert_data_result({success: result});
        output.writeMessageBegin("insert_data", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_insert_data_result(err);
          output.writeMessageBegin("insert_data", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("insert_data", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.insert_data(args.session, args.insert_data, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_insert_data_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("insert_data", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("insert_data", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_insert_chunks (seqid, input, output) {
    const args = new Heavy_insert_chunks_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.insert_chunks.length === 2) {
      Promise.resolve(this._handler.insert_chunks.bind(this._handler)(
        args.session,
        args.insert_chunks
      )).then(result => {
        const result_obj = new Heavy_insert_chunks_result({success: result});
        output.writeMessageBegin("insert_chunks", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_insert_chunks_result(err);
          output.writeMessageBegin("insert_chunks", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("insert_chunks", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.insert_chunks(args.session, args.insert_chunks, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_insert_chunks_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("insert_chunks", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("insert_chunks", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_checkpoint (seqid, input, output) {
    const args = new Heavy_checkpoint_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.checkpoint.length === 2) {
      Promise.resolve(this._handler.checkpoint.bind(this._handler)(
        args.session,
        args.table_id
      )).then(result => {
        const result_obj = new Heavy_checkpoint_result({success: result});
        output.writeMessageBegin("checkpoint", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_checkpoint_result(err);
          output.writeMessageBegin("checkpoint", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("checkpoint", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.checkpoint(args.session, args.table_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_checkpoint_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("checkpoint", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("checkpoint", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_roles (seqid, input, output) {
    const args = new Heavy_get_roles_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_roles.length === 1) {
      Promise.resolve(this._handler.get_roles.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_roles_result({success: result});
        output.writeMessageBegin("get_roles", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_roles_result(err);
          output.writeMessageBegin("get_roles", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_roles", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_roles(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_roles_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_roles", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_roles", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_db_objects_for_grantee (seqid, input, output) {
    const args = new Heavy_get_db_objects_for_grantee_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_db_objects_for_grantee.length === 2) {
      Promise.resolve(this._handler.get_db_objects_for_grantee.bind(this._handler)(
        args.session,
        args.roleName
      )).then(result => {
        const result_obj = new Heavy_get_db_objects_for_grantee_result({success: result});
        output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_db_objects_for_grantee_result(err);
          output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_db_objects_for_grantee(args.session, args.roleName, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_db_objects_for_grantee_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_db_object_privs (seqid, input, output) {
    const args = new Heavy_get_db_object_privs_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_db_object_privs.length === 3) {
      Promise.resolve(this._handler.get_db_object_privs.bind(this._handler)(
        args.session,
        args.objectName,
        args.type
      )).then(result => {
        const result_obj = new Heavy_get_db_object_privs_result({success: result});
        output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_db_object_privs_result(err);
          output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_db_object_privs(args.session, args.objectName, args.type, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_db_object_privs_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_all_roles_for_user (seqid, input, output) {
    const args = new Heavy_get_all_roles_for_user_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_all_roles_for_user.length === 2) {
      Promise.resolve(this._handler.get_all_roles_for_user.bind(this._handler)(
        args.session,
        args.userName
      )).then(result => {
        const result_obj = new Heavy_get_all_roles_for_user_result({success: result});
        output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_all_roles_for_user_result(err);
          output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_all_roles_for_user(args.session, args.userName, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_all_roles_for_user_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_all_effective_roles_for_user (seqid, input, output) {
    const args = new Heavy_get_all_effective_roles_for_user_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_all_effective_roles_for_user.length === 2) {
      Promise.resolve(this._handler.get_all_effective_roles_for_user.bind(this._handler)(
        args.session,
        args.userName
      )).then(result => {
        const result_obj = new Heavy_get_all_effective_roles_for_user_result({success: result});
        output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_all_effective_roles_for_user_result(err);
          output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_all_effective_roles_for_user(args.session, args.userName, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_all_effective_roles_for_user_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_has_role (seqid, input, output) {
    const args = new Heavy_has_role_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.has_role.length === 3) {
      Promise.resolve(this._handler.has_role.bind(this._handler)(
        args.session,
        args.granteeName,
        args.roleName
      )).then(result => {
        const result_obj = new Heavy_has_role_result({success: result});
        output.writeMessageBegin("has_role", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_has_role_result(err);
          output.writeMessageBegin("has_role", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("has_role", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.has_role(args.session, args.granteeName, args.roleName, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_has_role_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("has_role", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("has_role", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_has_object_privilege (seqid, input, output) {
    const args = new Heavy_has_object_privilege_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.has_object_privilege.length === 5) {
      Promise.resolve(this._handler.has_object_privilege.bind(this._handler)(
        args.session,
        args.granteeName,
        args.ObjectName,
        args.objectType,
        args.permissions
      )).then(result => {
        const result_obj = new Heavy_has_object_privilege_result({success: result});
        output.writeMessageBegin("has_object_privilege", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_has_object_privilege_result(err);
          output.writeMessageBegin("has_object_privilege", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("has_object_privilege", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.has_object_privilege(args.session, args.granteeName, args.ObjectName, args.objectType, args.permissions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_has_object_privilege_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("has_object_privilege", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("has_object_privilege", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_license_key (seqid, input, output) {
    const args = new Heavy_set_license_key_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_license_key.length === 3) {
      Promise.resolve(this._handler.set_license_key.bind(this._handler)(
        args.session,
        args.key,
        args.nonce
      )).then(result => {
        const result_obj = new Heavy_set_license_key_result({success: result});
        output.writeMessageBegin("set_license_key", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_license_key_result(err);
          output.writeMessageBegin("set_license_key", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_license_key", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_license_key(args.session, args.key, args.nonce, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_license_key_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_license_key", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_license_key", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_license_claims (seqid, input, output) {
    const args = new Heavy_get_license_claims_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_license_claims.length === 2) {
      Promise.resolve(this._handler.get_license_claims.bind(this._handler)(
        args.session,
        args.nonce
      )).then(result => {
        const result_obj = new Heavy_get_license_claims_result({success: result});
        output.writeMessageBegin("get_license_claims", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_license_claims_result(err);
          output.writeMessageBegin("get_license_claims", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_license_claims", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_license_claims(args.session, args.nonce, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_license_claims_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_license_claims", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_license_claims", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_device_parameters (seqid, input, output) {
    const args = new Heavy_get_device_parameters_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_device_parameters.length === 1) {
      Promise.resolve(this._handler.get_device_parameters.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_device_parameters_result({success: result});
        output.writeMessageBegin("get_device_parameters", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_device_parameters_result(err);
          output.writeMessageBegin("get_device_parameters", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_device_parameters", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_device_parameters(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_device_parameters_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_device_parameters", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_device_parameters", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_register_runtime_extension_functions (seqid, input, output) {
    const args = new Heavy_register_runtime_extension_functions_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.register_runtime_extension_functions.length === 4) {
      Promise.resolve(this._handler.register_runtime_extension_functions.bind(this._handler)(
        args.session,
        args.udfs,
        args.udtfs,
        args.device_ir_map
      )).then(result => {
        const result_obj = new Heavy_register_runtime_extension_functions_result({success: result});
        output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_register_runtime_extension_functions_result(err);
          output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.register_runtime_extension_functions(args.session, args.udfs, args.udtfs, args.device_ir_map, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_register_runtime_extension_functions_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_function_names (seqid, input, output) {
    const args = new Heavy_get_table_function_names_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_function_names.length === 1) {
      Promise.resolve(this._handler.get_table_function_names.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_table_function_names_result({success: result});
        output.writeMessageBegin("get_table_function_names", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_table_function_names_result(err);
          output.writeMessageBegin("get_table_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_function_names(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_table_function_names_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_runtime_table_function_names (seqid, input, output) {
    const args = new Heavy_get_runtime_table_function_names_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_runtime_table_function_names.length === 1) {
      Promise.resolve(this._handler.get_runtime_table_function_names.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_runtime_table_function_names_result({success: result});
        output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_runtime_table_function_names_result(err);
          output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_runtime_table_function_names(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_runtime_table_function_names_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_function_details (seqid, input, output) {
    const args = new Heavy_get_table_function_details_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_function_details.length === 2) {
      Promise.resolve(this._handler.get_table_function_details.bind(this._handler)(
        args.session,
        args.udtf_names
      )).then(result => {
        const result_obj = new Heavy_get_table_function_details_result({success: result});
        output.writeMessageBegin("get_table_function_details", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_table_function_details_result(err);
          output.writeMessageBegin("get_table_function_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_function_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_function_details(args.session, args.udtf_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_table_function_details_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_function_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_function_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_function_names (seqid, input, output) {
    const args = new Heavy_get_function_names_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_function_names.length === 1) {
      Promise.resolve(this._handler.get_function_names.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_function_names_result({success: result});
        output.writeMessageBegin("get_function_names", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_function_names_result(err);
          output.writeMessageBegin("get_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_function_names(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_function_names_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_runtime_function_names (seqid, input, output) {
    const args = new Heavy_get_runtime_function_names_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_runtime_function_names.length === 1) {
      Promise.resolve(this._handler.get_runtime_function_names.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_runtime_function_names_result({success: result});
        output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_runtime_function_names_result(err);
          output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_runtime_function_names(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_runtime_function_names_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_function_details (seqid, input, output) {
    const args = new Heavy_get_function_details_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_function_details.length === 2) {
      Promise.resolve(this._handler.get_function_details.bind(this._handler)(
        args.session,
        args.udf_names
      )).then(result => {
        const result_obj = new Heavy_get_function_details_result({success: result});
        output.writeMessageBegin("get_function_details", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_function_details_result(err);
          output.writeMessageBegin("get_function_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_function_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_function_details(args.session, args.udf_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_function_details_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_function_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_function_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
};


/***/ }),

/***/ 2818:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(9262);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);


const ttypes = module.exports = {};
ttypes.TDeviceType = {
  'CPU' : 0,
  'GPU' : 1
};
ttypes.TDatumType = {
  'SMALLINT' : 0,
  'INT' : 1,
  'BIGINT' : 2,
  'FLOAT' : 3,
  'DECIMAL' : 4,
  'DOUBLE' : 5,
  'STR' : 6,
  'TIME' : 7,
  'TIMESTAMP' : 8,
  'DATE' : 9,
  'BOOL' : 10,
  'INTERVAL_DAY_TIME' : 11,
  'INTERVAL_YEAR_MONTH' : 12,
  'POINT' : 13,
  'LINESTRING' : 14,
  'POLYGON' : 15,
  'MULTIPOLYGON' : 16,
  'TINYINT' : 17,
  'GEOMETRY' : 18,
  'GEOGRAPHY' : 19,
  'MULTILINESTRING' : 20,
  'MULTIPOINT' : 21
};
ttypes.TEncodingType = {
  'NONE' : 0,
  'FIXED' : 1,
  'RL' : 2,
  'DIFF' : 3,
  'DICT' : 4,
  'SPARSE' : 5,
  'GEOINT' : 6,
  'DATE_IN_DAYS' : 7,
  'ARRAY' : 8,
  'ARRAY_DICT' : 9
};
const TTypeInfo = module.exports.TTypeInfo = class {
  constructor(args) {
    this.type = null;
    this.encoding = null;
    this.nullable = null;
    this.is_array = null;
    this.precision = null;
    this.scale = null;
    this.comp_param = null;
    this.size = -1;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.encoding !== undefined && args.encoding !== null) {
        this.encoding = args.encoding;
      }
      if (args.nullable !== undefined && args.nullable !== null) {
        this.nullable = args.nullable;
      }
      if (args.is_array !== undefined && args.is_array !== null) {
        this.is_array = args.is_array;
      }
      if (args.precision !== undefined && args.precision !== null) {
        this.precision = args.precision;
      }
      if (args.scale !== undefined && args.scale !== null) {
        this.scale = args.scale;
      }
      if (args.comp_param !== undefined && args.comp_param !== null) {
        this.comp_param = args.comp_param;
      }
      if (args.size !== undefined && args.size !== null) {
        this.size = args.size;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.encoding = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.nullable = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.is_array = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.precision = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.scale = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.comp_param = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.size = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTypeInfo');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
      output.writeFieldBegin('encoding', Thrift.Type.I32, 4);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.nullable !== null && this.nullable !== undefined) {
      output.writeFieldBegin('nullable', Thrift.Type.BOOL, 2);
      output.writeBool(this.nullable);
      output.writeFieldEnd();
    }
    if (this.is_array !== null && this.is_array !== undefined) {
      output.writeFieldBegin('is_array', Thrift.Type.BOOL, 3);
      output.writeBool(this.is_array);
      output.writeFieldEnd();
    }
    if (this.precision !== null && this.precision !== undefined) {
      output.writeFieldBegin('precision', Thrift.Type.I32, 5);
      output.writeI32(this.precision);
      output.writeFieldEnd();
    }
    if (this.scale !== null && this.scale !== undefined) {
      output.writeFieldBegin('scale', Thrift.Type.I32, 6);
      output.writeI32(this.scale);
      output.writeFieldEnd();
    }
    if (this.comp_param !== null && this.comp_param !== undefined) {
      output.writeFieldBegin('comp_param', Thrift.Type.I32, 7);
      output.writeI32(this.comp_param);
      output.writeFieldEnd();
    }
    if (this.size !== null && this.size !== undefined) {
      output.writeFieldBegin('size', Thrift.Type.I32, 8);
      output.writeI32(this.size);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 4494:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(9262);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);


const ttypes = module.exports = {};
ttypes.TCompletionHintType = {
  'COLUMN' : 0,
  'TABLE' : 1,
  'VIEW' : 2,
  'SCHEMA' : 3,
  'CATALOG' : 4,
  'REPOSITORY' : 5,
  'FUNCTION' : 6,
  'KEYWORD' : 7
};
const TCompletionHint = module.exports.TCompletionHint = class {
  constructor(args) {
    this.type = null;
    this.hints = null;
    this.replaced = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.hints !== undefined && args.hints !== null) {
        this.hints = Thrift.copyList(args.hints, [null]);
      }
      if (args.replaced !== undefined && args.replaced !== null) {
        this.replaced = args.replaced;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.hints = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readString();
            this.hints.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.replaced = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCompletionHint');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.hints !== null && this.hints !== undefined) {
      output.writeFieldBegin('hints', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.hints.length);
      for (let iter4 in this.hints) {
        if (this.hints.hasOwnProperty(iter4)) {
          iter4 = this.hints[iter4];
          output.writeString(iter4);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.replaced !== null && this.replaced !== undefined) {
      output.writeFieldBegin('replaced', Thrift.Type.STRING, 3);
      output.writeString(this.replaced);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 1396:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(9262);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);


const ttypes = module.exports = {};
ttypes.TExtArgumentType = {
  'Int8' : 0,
  'Int16' : 1,
  'Int32' : 2,
  'Int64' : 3,
  'Float' : 4,
  'Double' : 5,
  'Void' : 6,
  'PInt8' : 7,
  'PInt16' : 8,
  'PInt32' : 9,
  'PInt64' : 10,
  'PFloat' : 11,
  'PDouble' : 12,
  'PBool' : 13,
  'Bool' : 14,
  'ArrayInt8' : 15,
  'ArrayInt16' : 16,
  'ArrayInt32' : 17,
  'ArrayInt64' : 18,
  'ArrayFloat' : 19,
  'ArrayDouble' : 20,
  'ArrayBool' : 21,
  'GeoPoint' : 22,
  'GeoLineString' : 23,
  'Cursor' : 24,
  'GeoPolygon' : 25,
  'GeoMultiPolygon' : 26,
  'ColumnInt8' : 27,
  'ColumnInt16' : 28,
  'ColumnInt32' : 29,
  'ColumnInt64' : 30,
  'ColumnFloat' : 31,
  'ColumnDouble' : 32,
  'ColumnBool' : 33,
  'TextEncodingNone' : 34,
  'TextEncodingDict' : 35,
  'ColumnListInt8' : 36,
  'ColumnListInt16' : 37,
  'ColumnListInt32' : 38,
  'ColumnListInt64' : 39,
  'ColumnListFloat' : 40,
  'ColumnListDouble' : 41,
  'ColumnListBool' : 42,
  'ColumnTextEncodingDict' : 43,
  'ColumnListTextEncodingDict' : 44,
  'ColumnTimestamp' : 45,
  'Timestamp' : 46,
  'ColumnArrayInt8' : 47,
  'ColumnArrayInt16' : 48,
  'ColumnArrayInt32' : 49,
  'ColumnArrayInt64' : 50,
  'ColumnArrayFloat' : 51,
  'ColumnArrayDouble' : 52,
  'ColumnArrayBool' : 53,
  'ColumnListArrayInt8' : 54,
  'ColumnListArrayInt16' : 55,
  'ColumnListArrayInt32' : 56,
  'ColumnListArrayInt64' : 57,
  'ColumnListArrayFloat' : 58,
  'ColumnListArrayDouble' : 59,
  'ColumnListArrayBool' : 60,
  'GeoMultiLineString' : 61,
  'ArrayTextEncodingNone' : 62,
  'ColumnTextEncodingNone' : 63,
  'ColumnListTextEncodingNone' : 64,
  'ColumnArrayTextEncodingNone' : 65,
  'ColumnListArrayTextEncodingNone' : 66,
  'ArrayTextEncodingDict' : 67,
  'ColumnArrayTextEncodingDict' : 68,
  'ColumnListArrayTextEncodingDict' : 69,
  'GeoMultiPoint' : 70
};
ttypes.TOutputBufferSizeType = {
  'kConstant' : 0,
  'kUserSpecifiedConstantParameter' : 1,
  'kUserSpecifiedRowMultiplier' : 2,
  'kTableFunctionSpecifiedParameter' : 3,
  'kPreFlightParameter' : 4
};
const TUserDefinedFunction = module.exports.TUserDefinedFunction = class {
  constructor(args) {
    this.name = null;
    this.argTypes = null;
    this.retType = null;
    if (args) {
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.argTypes !== undefined && args.argTypes !== null) {
        this.argTypes = Thrift.copyList(args.argTypes, [null]);
      }
      if (args.retType !== undefined && args.retType !== null) {
        this.retType = args.retType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.argTypes = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readI32();
            this.argTypes.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.retType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TUserDefinedFunction');
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 1);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.argTypes !== null && this.argTypes !== undefined) {
      output.writeFieldBegin('argTypes', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.argTypes.length);
      for (let iter4 in this.argTypes) {
        if (this.argTypes.hasOwnProperty(iter4)) {
          iter4 = this.argTypes[iter4];
          output.writeI32(iter4);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.retType !== null && this.retType !== undefined) {
      output.writeFieldBegin('retType', Thrift.Type.I32, 3);
      output.writeI32(this.retType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TUserDefinedTableFunction = module.exports.TUserDefinedTableFunction = class {
  constructor(args) {
    this.name = null;
    this.sizerType = null;
    this.sizerArgPos = null;
    this.inputArgTypes = null;
    this.outputArgTypes = null;
    this.sqlArgTypes = null;
    this.annotations = null;
    if (args) {
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.sizerType !== undefined && args.sizerType !== null) {
        this.sizerType = args.sizerType;
      }
      if (args.sizerArgPos !== undefined && args.sizerArgPos !== null) {
        this.sizerArgPos = args.sizerArgPos;
      }
      if (args.inputArgTypes !== undefined && args.inputArgTypes !== null) {
        this.inputArgTypes = Thrift.copyList(args.inputArgTypes, [null]);
      }
      if (args.outputArgTypes !== undefined && args.outputArgTypes !== null) {
        this.outputArgTypes = Thrift.copyList(args.outputArgTypes, [null]);
      }
      if (args.sqlArgTypes !== undefined && args.sqlArgTypes !== null) {
        this.sqlArgTypes = Thrift.copyList(args.sqlArgTypes, [null]);
      }
      if (args.annotations !== undefined && args.annotations !== null) {
        this.annotations = Thrift.copyList(args.annotations, [Thrift.copyMap, null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.sizerType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.sizerArgPos = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.inputArgTypes = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = input.readI32();
            this.inputArgTypes.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.outputArgTypes = [];
          const _rtmp310 = input.readListBegin();
          const _size9 = _rtmp310.size || 0;
          for (let _i11 = 0; _i11 < _size9; ++_i11) {
            let elem12 = null;
            elem12 = input.readI32();
            this.outputArgTypes.push(elem12);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.sqlArgTypes = [];
          const _rtmp314 = input.readListBegin();
          const _size13 = _rtmp314.size || 0;
          for (let _i15 = 0; _i15 < _size13; ++_i15) {
            let elem16 = null;
            elem16 = input.readI32();
            this.sqlArgTypes.push(elem16);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.annotations = [];
          const _rtmp318 = input.readListBegin();
          const _size17 = _rtmp318.size || 0;
          for (let _i19 = 0; _i19 < _size17; ++_i19) {
            let elem20 = null;
            elem20 = {};
            const _rtmp322 = input.readMapBegin();
            const _size21 = _rtmp322.size || 0;
            for (let _i23 = 0; _i23 < _size21; ++_i23) {
              let key24 = null;
              let val25 = null;
              key24 = input.readString();
              val25 = input.readString();
              elem20[key24] = val25;
            }
            input.readMapEnd();
            this.annotations.push(elem20);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TUserDefinedTableFunction');
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 1);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.sizerType !== null && this.sizerType !== undefined) {
      output.writeFieldBegin('sizerType', Thrift.Type.I32, 2);
      output.writeI32(this.sizerType);
      output.writeFieldEnd();
    }
    if (this.sizerArgPos !== null && this.sizerArgPos !== undefined) {
      output.writeFieldBegin('sizerArgPos', Thrift.Type.I32, 3);
      output.writeI32(this.sizerArgPos);
      output.writeFieldEnd();
    }
    if (this.inputArgTypes !== null && this.inputArgTypes !== undefined) {
      output.writeFieldBegin('inputArgTypes', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.I32, this.inputArgTypes.length);
      for (let iter26 in this.inputArgTypes) {
        if (this.inputArgTypes.hasOwnProperty(iter26)) {
          iter26 = this.inputArgTypes[iter26];
          output.writeI32(iter26);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.outputArgTypes !== null && this.outputArgTypes !== undefined) {
      output.writeFieldBegin('outputArgTypes', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.I32, this.outputArgTypes.length);
      for (let iter27 in this.outputArgTypes) {
        if (this.outputArgTypes.hasOwnProperty(iter27)) {
          iter27 = this.outputArgTypes[iter27];
          output.writeI32(iter27);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.sqlArgTypes !== null && this.sqlArgTypes !== undefined) {
      output.writeFieldBegin('sqlArgTypes', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.I32, this.sqlArgTypes.length);
      for (let iter28 in this.sqlArgTypes) {
        if (this.sqlArgTypes.hasOwnProperty(iter28)) {
          iter28 = this.sqlArgTypes[iter28];
          output.writeI32(iter28);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.annotations !== null && this.annotations !== undefined) {
      output.writeFieldBegin('annotations', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.MAP, this.annotations.length);
      for (let iter29 in this.annotations) {
        if (this.annotations.hasOwnProperty(iter29)) {
          iter29 = this.annotations[iter29];
          output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(iter29));
          for (let kiter30 in iter29) {
            if (iter29.hasOwnProperty(kiter30)) {
              let viter31 = iter29[kiter30];
              output.writeString(kiter30);
              output.writeString(viter31);
            }
          }
          output.writeMapEnd();
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 2607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(9262);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);

const common_ttypes = __webpack_require__(2818);
const completion_hints_ttypes = __webpack_require__(4494);
const serialized_result_set_ttypes = __webpack_require__(3962);
const extension_functions_ttypes = __webpack_require__(1396);


const ttypes = module.exports = {};
ttypes.TExecuteMode = {
  'GPU' : 1,
  'CPU' : 2
};
ttypes.TSourceType = {
  'DELIMITED_FILE' : 0,
  'GEO_FILE' : 1,
  'PARQUET_FILE' : 2,
  'RASTER_FILE' : 3,
  'ODBC' : 4
};
ttypes.TPartitionDetail = {
  'DEFAULT' : 0,
  'REPLICATED' : 1,
  'SHARDED' : 2,
  'OTHER' : 3
};
ttypes.TGeoFileLayerContents = {
  'EMPTY' : 0,
  'GEO' : 1,
  'NON_GEO' : 2,
  'UNSUPPORTED_GEO' : 3
};
ttypes.TImportHeaderRow = {
  'AUTODETECT' : 0,
  'NO_HEADER' : 1,
  'HAS_HEADER' : 2
};
ttypes.TRole = {
  'SERVER' : 0,
  'AGGREGATOR' : 1,
  'LEAF' : 2,
  'STRING_DICTIONARY' : 3
};
ttypes.TTableType = {
  'DEFAULT' : 0,
  'TEMPORARY' : 1,
  'FOREIGN' : 2,
  'VIEW' : 3
};
ttypes.TTableRefreshUpdateType = {
  'ALL' : 0,
  'APPEND' : 1
};
ttypes.TTableRefreshTimingType = {
  'MANUAL' : 0,
  'SCHEDULED' : 1
};
ttypes.TTableRefreshIntervalType = {
  'NONE' : 0,
  'HOUR' : 1,
  'DAY' : 2
};
ttypes.TMergeType = {
  'UNION' : 0,
  'REDUCE' : 1
};
ttypes.TRasterPointType = {
  'NONE' : 0,
  'AUTO' : 1,
  'SMALLINT' : 2,
  'INT' : 3,
  'FLOAT' : 4,
  'DOUBLE' : 5,
  'POINT' : 6
};
ttypes.TRasterPointTransform = {
  'NONE' : 0,
  'AUTO' : 1,
  'FILE' : 2,
  'WORLD' : 3
};
ttypes.TQueryType = {
  'UNKNOWN' : 0,
  'READ' : 1,
  'WRITE' : 2,
  'SCHEMA_READ' : 3,
  'SCHEMA_WRITE' : 4
};
ttypes.TArrowTransport = {
  'SHARED_MEMORY' : 0,
  'WIRE' : 1
};
ttypes.TExpressionRangeType = {
  'INVALID' : 0,
  'INTEGER' : 1,
  'FLOAT' : 2,
  'DOUBLE' : 3
};
ttypes.TDBObjectType = {
  'AbstractDBObjectType' : 0,
  'DatabaseDBObjectType' : 1,
  'TableDBObjectType' : 2,
  'DashboardDBObjectType' : 3,
  'ViewDBObjectType' : 4,
  'ServerDBObjectType' : 5
};
ttypes.TDataSourceType = {
  'TABLE' : 0
};
const TDatumVal = module.exports.TDatumVal = class {
  constructor(args) {
    this.int_val = null;
    this.real_val = null;
    this.str_val = null;
    this.arr_val = null;
    if (args) {
      if (args.int_val !== undefined && args.int_val !== null) {
        this.int_val = args.int_val;
      }
      if (args.real_val !== undefined && args.real_val !== null) {
        this.real_val = args.real_val;
      }
      if (args.str_val !== undefined && args.str_val !== null) {
        this.str_val = args.str_val;
      }
      if (args.arr_val !== undefined && args.arr_val !== null) {
        this.arr_val = Thrift.copyList(args.arr_val, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.int_val = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.DOUBLE) {
          this.real_val = input.readDouble();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.str_val = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.arr_val = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new ttypes.TDatum();
            elem3.read(input);
            this.arr_val.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDatumVal');
    if (this.int_val !== null && this.int_val !== undefined) {
      output.writeFieldBegin('int_val', Thrift.Type.I64, 1);
      output.writeI64(this.int_val);
      output.writeFieldEnd();
    }
    if (this.real_val !== null && this.real_val !== undefined) {
      output.writeFieldBegin('real_val', Thrift.Type.DOUBLE, 2);
      output.writeDouble(this.real_val);
      output.writeFieldEnd();
    }
    if (this.str_val !== null && this.str_val !== undefined) {
      output.writeFieldBegin('str_val', Thrift.Type.STRING, 3);
      output.writeString(this.str_val);
      output.writeFieldEnd();
    }
    if (this.arr_val !== null && this.arr_val !== undefined) {
      output.writeFieldBegin('arr_val', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.arr_val.length);
      for (let iter4 in this.arr_val) {
        if (this.arr_val.hasOwnProperty(iter4)) {
          iter4 = this.arr_val[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDatum = module.exports.TDatum = class {
  constructor(args) {
    this.val = null;
    this.is_null = null;
    if (args) {
      if (args.val !== undefined && args.val !== null) {
        this.val = new ttypes.TDatumVal(args.val);
      }
      if (args.is_null !== undefined && args.is_null !== null) {
        this.is_null = args.is_null;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.val = new ttypes.TDatumVal();
          this.val.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.is_null = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDatum');
    if (this.val !== null && this.val !== undefined) {
      output.writeFieldBegin('val', Thrift.Type.STRUCT, 1);
      this.val.write(output);
      output.writeFieldEnd();
    }
    if (this.is_null !== null && this.is_null !== undefined) {
      output.writeFieldBegin('is_null', Thrift.Type.BOOL, 2);
      output.writeBool(this.is_null);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TStringValue = module.exports.TStringValue = class {
  constructor(args) {
    this.str_val = null;
    this.is_null = null;
    if (args) {
      if (args.str_val !== undefined && args.str_val !== null) {
        this.str_val = args.str_val;
      }
      if (args.is_null !== undefined && args.is_null !== null) {
        this.is_null = args.is_null;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.str_val = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.is_null = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TStringValue');
    if (this.str_val !== null && this.str_val !== undefined) {
      output.writeFieldBegin('str_val', Thrift.Type.STRING, 1);
      output.writeString(this.str_val);
      output.writeFieldEnd();
    }
    if (this.is_null !== null && this.is_null !== undefined) {
      output.writeFieldBegin('is_null', Thrift.Type.BOOL, 2);
      output.writeBool(this.is_null);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColumnType = module.exports.TColumnType = class {
  constructor(args) {
    this.col_name = null;
    this.col_type = null;
    this.is_reserved_keyword = null;
    this.src_name = null;
    this.is_system = null;
    this.is_physical = null;
    this.col_id = null;
    this.default_value = null;
    if (args) {
      if (args.col_name !== undefined && args.col_name !== null) {
        this.col_name = args.col_name;
      }
      if (args.col_type !== undefined && args.col_type !== null) {
        this.col_type = new common_ttypes.TTypeInfo(args.col_type);
      }
      if (args.is_reserved_keyword !== undefined && args.is_reserved_keyword !== null) {
        this.is_reserved_keyword = args.is_reserved_keyword;
      }
      if (args.src_name !== undefined && args.src_name !== null) {
        this.src_name = args.src_name;
      }
      if (args.is_system !== undefined && args.is_system !== null) {
        this.is_system = args.is_system;
      }
      if (args.is_physical !== undefined && args.is_physical !== null) {
        this.is_physical = args.is_physical;
      }
      if (args.col_id !== undefined && args.col_id !== null) {
        this.col_id = args.col_id;
      }
      if (args.default_value !== undefined && args.default_value !== null) {
        this.default_value = args.default_value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.col_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.col_type = new common_ttypes.TTypeInfo();
          this.col_type.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.is_reserved_keyword = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.src_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.is_system = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.is_physical = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.col_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.default_value = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColumnType');
    if (this.col_name !== null && this.col_name !== undefined) {
      output.writeFieldBegin('col_name', Thrift.Type.STRING, 1);
      output.writeString(this.col_name);
      output.writeFieldEnd();
    }
    if (this.col_type !== null && this.col_type !== undefined) {
      output.writeFieldBegin('col_type', Thrift.Type.STRUCT, 2);
      this.col_type.write(output);
      output.writeFieldEnd();
    }
    if (this.is_reserved_keyword !== null && this.is_reserved_keyword !== undefined) {
      output.writeFieldBegin('is_reserved_keyword', Thrift.Type.BOOL, 3);
      output.writeBool(this.is_reserved_keyword);
      output.writeFieldEnd();
    }
    if (this.src_name !== null && this.src_name !== undefined) {
      output.writeFieldBegin('src_name', Thrift.Type.STRING, 4);
      output.writeString(this.src_name);
      output.writeFieldEnd();
    }
    if (this.is_system !== null && this.is_system !== undefined) {
      output.writeFieldBegin('is_system', Thrift.Type.BOOL, 5);
      output.writeBool(this.is_system);
      output.writeFieldEnd();
    }
    if (this.is_physical !== null && this.is_physical !== undefined) {
      output.writeFieldBegin('is_physical', Thrift.Type.BOOL, 6);
      output.writeBool(this.is_physical);
      output.writeFieldEnd();
    }
    if (this.col_id !== null && this.col_id !== undefined) {
      output.writeFieldBegin('col_id', Thrift.Type.I64, 7);
      output.writeI64(this.col_id);
      output.writeFieldEnd();
    }
    if (this.default_value !== null && this.default_value !== undefined) {
      output.writeFieldBegin('default_value', Thrift.Type.STRING, 8);
      output.writeString(this.default_value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRow = module.exports.TRow = class {
  constructor(args) {
    this.cols = null;
    if (args) {
      if (args.cols !== undefined && args.cols !== null) {
        this.cols = Thrift.copyList(args.cols, [ttypes.TDatum]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.cols = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new ttypes.TDatum();
            elem8.read(input);
            this.cols.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRow');
    if (this.cols !== null && this.cols !== undefined) {
      output.writeFieldBegin('cols', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.cols.length);
      for (let iter9 in this.cols) {
        if (this.cols.hasOwnProperty(iter9)) {
          iter9 = this.cols[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColumnData = module.exports.TColumnData = class {
  constructor(args) {
    this.int_col = null;
    this.real_col = null;
    this.str_col = null;
    this.arr_col = null;
    if (args) {
      if (args.int_col !== undefined && args.int_col !== null) {
        this.int_col = Thrift.copyList(args.int_col, [null]);
      }
      if (args.real_col !== undefined && args.real_col !== null) {
        this.real_col = Thrift.copyList(args.real_col, [null]);
      }
      if (args.str_col !== undefined && args.str_col !== null) {
        this.str_col = Thrift.copyList(args.str_col, [null]);
      }
      if (args.arr_col !== undefined && args.arr_col !== null) {
        this.arr_col = Thrift.copyList(args.arr_col, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.int_col = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = input.readI64();
            this.int_col.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.real_col = [];
          const _rtmp315 = input.readListBegin();
          const _size14 = _rtmp315.size || 0;
          for (let _i16 = 0; _i16 < _size14; ++_i16) {
            let elem17 = null;
            elem17 = input.readDouble();
            this.real_col.push(elem17);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.str_col = [];
          const _rtmp319 = input.readListBegin();
          const _size18 = _rtmp319.size || 0;
          for (let _i20 = 0; _i20 < _size18; ++_i20) {
            let elem21 = null;
            elem21 = input.readString();
            this.str_col.push(elem21);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.arr_col = [];
          const _rtmp323 = input.readListBegin();
          const _size22 = _rtmp323.size || 0;
          for (let _i24 = 0; _i24 < _size22; ++_i24) {
            let elem25 = null;
            elem25 = new ttypes.TColumn();
            elem25.read(input);
            this.arr_col.push(elem25);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColumnData');
    if (this.int_col !== null && this.int_col !== undefined) {
      output.writeFieldBegin('int_col', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.I64, this.int_col.length);
      for (let iter26 in this.int_col) {
        if (this.int_col.hasOwnProperty(iter26)) {
          iter26 = this.int_col[iter26];
          output.writeI64(iter26);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.real_col !== null && this.real_col !== undefined) {
      output.writeFieldBegin('real_col', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.DOUBLE, this.real_col.length);
      for (let iter27 in this.real_col) {
        if (this.real_col.hasOwnProperty(iter27)) {
          iter27 = this.real_col[iter27];
          output.writeDouble(iter27);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.str_col !== null && this.str_col !== undefined) {
      output.writeFieldBegin('str_col', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.str_col.length);
      for (let iter28 in this.str_col) {
        if (this.str_col.hasOwnProperty(iter28)) {
          iter28 = this.str_col[iter28];
          output.writeString(iter28);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.arr_col !== null && this.arr_col !== undefined) {
      output.writeFieldBegin('arr_col', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.arr_col.length);
      for (let iter29 in this.arr_col) {
        if (this.arr_col.hasOwnProperty(iter29)) {
          iter29 = this.arr_col[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColumn = module.exports.TColumn = class {
  constructor(args) {
    this.data = null;
    this.nulls = null;
    if (args) {
      if (args.data !== undefined && args.data !== null) {
        this.data = new ttypes.TColumnData(args.data);
      }
      if (args.nulls !== undefined && args.nulls !== null) {
        this.nulls = Thrift.copyList(args.nulls, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.data = new ttypes.TColumnData();
          this.data.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.nulls = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = input.readBool();
            this.nulls.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColumn');
    if (this.data !== null && this.data !== undefined) {
      output.writeFieldBegin('data', Thrift.Type.STRUCT, 1);
      this.data.write(output);
      output.writeFieldEnd();
    }
    if (this.nulls !== null && this.nulls !== undefined) {
      output.writeFieldBegin('nulls', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.BOOL, this.nulls.length);
      for (let iter34 in this.nulls) {
        if (this.nulls.hasOwnProperty(iter34)) {
          iter34 = this.nulls[iter34];
          output.writeBool(iter34);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TStringRow = module.exports.TStringRow = class {
  constructor(args) {
    this.cols = null;
    if (args) {
      if (args.cols !== undefined && args.cols !== null) {
        this.cols = Thrift.copyList(args.cols, [ttypes.TStringValue]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.cols = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new ttypes.TStringValue();
            elem38.read(input);
            this.cols.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TStringRow');
    if (this.cols !== null && this.cols !== undefined) {
      output.writeFieldBegin('cols', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.cols.length);
      for (let iter39 in this.cols) {
        if (this.cols.hasOwnProperty(iter39)) {
          iter39 = this.cols[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TKrb5Session = module.exports.TKrb5Session = class {
  constructor(args) {
    this.sessionId = null;
    this.krbToken = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.krbToken !== undefined && args.krbToken !== null) {
        this.krbToken = args.krbToken;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.krbToken = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TKrb5Session');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 1);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.krbToken !== null && this.krbToken !== undefined) {
      output.writeFieldBegin('krbToken', Thrift.Type.STRING, 2);
      output.writeString(this.krbToken);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TStepResult = module.exports.TStepResult = class {
  constructor(args) {
    this.serialized_rows = null;
    this.execution_finished = null;
    this.merge_type = null;
    this.sharded = null;
    this.row_desc = null;
    this.node_id = null;
    if (args) {
      if (args.serialized_rows !== undefined && args.serialized_rows !== null) {
        this.serialized_rows = new serialized_result_set_ttypes.TSerializedRows(args.serialized_rows);
      }
      if (args.execution_finished !== undefined && args.execution_finished !== null) {
        this.execution_finished = args.execution_finished;
      }
      if (args.merge_type !== undefined && args.merge_type !== null) {
        this.merge_type = args.merge_type;
      }
      if (args.sharded !== undefined && args.sharded !== null) {
        this.sharded = args.sharded;
      }
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.node_id !== undefined && args.node_id !== null) {
        this.node_id = args.node_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.serialized_rows = new serialized_result_set_ttypes.TSerializedRows();
          this.serialized_rows.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.execution_finished = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.merge_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.sharded = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp341 = input.readListBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            let elem43 = null;
            elem43 = new ttypes.TColumnType();
            elem43.read(input);
            this.row_desc.push(elem43);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.node_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TStepResult');
    if (this.serialized_rows !== null && this.serialized_rows !== undefined) {
      output.writeFieldBegin('serialized_rows', Thrift.Type.STRUCT, 1);
      this.serialized_rows.write(output);
      output.writeFieldEnd();
    }
    if (this.execution_finished !== null && this.execution_finished !== undefined) {
      output.writeFieldBegin('execution_finished', Thrift.Type.BOOL, 2);
      output.writeBool(this.execution_finished);
      output.writeFieldEnd();
    }
    if (this.merge_type !== null && this.merge_type !== undefined) {
      output.writeFieldBegin('merge_type', Thrift.Type.I32, 3);
      output.writeI32(this.merge_type);
      output.writeFieldEnd();
    }
    if (this.sharded !== null && this.sharded !== undefined) {
      output.writeFieldBegin('sharded', Thrift.Type.BOOL, 4);
      output.writeBool(this.sharded);
      output.writeFieldEnd();
    }
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter44 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter44)) {
          iter44 = this.row_desc[iter44];
          iter44.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.node_id !== null && this.node_id !== undefined) {
      output.writeFieldBegin('node_id', Thrift.Type.I32, 6);
      output.writeI32(this.node_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRowSet = module.exports.TRowSet = class {
  constructor(args) {
    this.row_desc = null;
    this.rows = null;
    this.columns = null;
    this.is_columnar = null;
    if (args) {
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.rows !== undefined && args.rows !== null) {
        this.rows = Thrift.copyList(args.rows, [ttypes.TRow]);
      }
      if (args.columns !== undefined && args.columns !== null) {
        this.columns = Thrift.copyList(args.columns, [ttypes.TColumn]);
      }
      if (args.is_columnar !== undefined && args.is_columnar !== null) {
        this.is_columnar = args.is_columnar;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp346 = input.readListBegin();
          const _size45 = _rtmp346.size || 0;
          for (let _i47 = 0; _i47 < _size45; ++_i47) {
            let elem48 = null;
            elem48 = new ttypes.TColumnType();
            elem48.read(input);
            this.row_desc.push(elem48);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.rows = [];
          const _rtmp350 = input.readListBegin();
          const _size49 = _rtmp350.size || 0;
          for (let _i51 = 0; _i51 < _size49; ++_i51) {
            let elem52 = null;
            elem52 = new ttypes.TRow();
            elem52.read(input);
            this.rows.push(elem52);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.columns = [];
          const _rtmp354 = input.readListBegin();
          const _size53 = _rtmp354.size || 0;
          for (let _i55 = 0; _i55 < _size53; ++_i55) {
            let elem56 = null;
            elem56 = new ttypes.TColumn();
            elem56.read(input);
            this.columns.push(elem56);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.is_columnar = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRowSet');
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter57 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter57)) {
          iter57 = this.row_desc[iter57];
          iter57.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.rows !== null && this.rows !== undefined) {
      output.writeFieldBegin('rows', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.rows.length);
      for (let iter58 in this.rows) {
        if (this.rows.hasOwnProperty(iter58)) {
          iter58 = this.rows[iter58];
          iter58.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.columns !== null && this.columns !== undefined) {
      output.writeFieldBegin('columns', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
      for (let iter59 in this.columns) {
        if (this.columns.hasOwnProperty(iter59)) {
          iter59 = this.columns[iter59];
          iter59.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.is_columnar !== null && this.is_columnar !== undefined) {
      output.writeFieldBegin('is_columnar', Thrift.Type.BOOL, 4);
      output.writeBool(this.is_columnar);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TQueryResult = module.exports.TQueryResult = class {
  constructor(args) {
    this.row_set = null;
    this.execution_time_ms = null;
    this.total_time_ms = null;
    this.nonce = null;
    this.debug = null;
    this.success = true;
    this.query_type = 0;
    if (args) {
      if (args.row_set !== undefined && args.row_set !== null) {
        this.row_set = new ttypes.TRowSet(args.row_set);
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.total_time_ms !== undefined && args.total_time_ms !== null) {
        this.total_time_ms = args.total_time_ms;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
      if (args.debug !== undefined && args.debug !== null) {
        this.debug = args.debug;
      }
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.query_type !== undefined && args.query_type !== null) {
        this.query_type = args.query_type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.row_set = new ttypes.TRowSet();
          this.row_set.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.total_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.debug = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.query_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TQueryResult');
    if (this.row_set !== null && this.row_set !== undefined) {
      output.writeFieldBegin('row_set', Thrift.Type.STRUCT, 1);
      this.row_set.write(output);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 2);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.total_time_ms !== null && this.total_time_ms !== undefined) {
      output.writeFieldBegin('total_time_ms', Thrift.Type.I64, 3);
      output.writeI64(this.total_time_ms);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 4);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    if (this.debug !== null && this.debug !== undefined) {
      output.writeFieldBegin('debug', Thrift.Type.STRING, 5);
      output.writeString(this.debug);
      output.writeFieldEnd();
    }
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 6);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.query_type !== null && this.query_type !== undefined) {
      output.writeFieldBegin('query_type', Thrift.Type.I32, 7);
      output.writeI32(this.query_type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDataFrame = module.exports.TDataFrame = class {
  constructor(args) {
    this.sm_handle = null;
    this.sm_size = null;
    this.df_handle = null;
    this.df_size = null;
    this.execution_time_ms = null;
    this.arrow_conversion_time_ms = null;
    this.df_buffer = null;
    if (args) {
      if (args.sm_handle !== undefined && args.sm_handle !== null) {
        this.sm_handle = args.sm_handle;
      }
      if (args.sm_size !== undefined && args.sm_size !== null) {
        this.sm_size = args.sm_size;
      }
      if (args.df_handle !== undefined && args.df_handle !== null) {
        this.df_handle = args.df_handle;
      }
      if (args.df_size !== undefined && args.df_size !== null) {
        this.df_size = args.df_size;
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.arrow_conversion_time_ms !== undefined && args.arrow_conversion_time_ms !== null) {
        this.arrow_conversion_time_ms = args.arrow_conversion_time_ms;
      }
      if (args.df_buffer !== undefined && args.df_buffer !== null) {
        this.df_buffer = args.df_buffer;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sm_handle = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.sm_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.df_handle = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.df_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.arrow_conversion_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.df_buffer = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDataFrame');
    if (this.sm_handle !== null && this.sm_handle !== undefined) {
      output.writeFieldBegin('sm_handle', Thrift.Type.STRING, 1);
      output.writeBinary(this.sm_handle);
      output.writeFieldEnd();
    }
    if (this.sm_size !== null && this.sm_size !== undefined) {
      output.writeFieldBegin('sm_size', Thrift.Type.I64, 2);
      output.writeI64(this.sm_size);
      output.writeFieldEnd();
    }
    if (this.df_handle !== null && this.df_handle !== undefined) {
      output.writeFieldBegin('df_handle', Thrift.Type.STRING, 3);
      output.writeBinary(this.df_handle);
      output.writeFieldEnd();
    }
    if (this.df_size !== null && this.df_size !== undefined) {
      output.writeFieldBegin('df_size', Thrift.Type.I64, 4);
      output.writeI64(this.df_size);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 5);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.arrow_conversion_time_ms !== null && this.arrow_conversion_time_ms !== undefined) {
      output.writeFieldBegin('arrow_conversion_time_ms', Thrift.Type.I64, 6);
      output.writeI64(this.arrow_conversion_time_ms);
      output.writeFieldEnd();
    }
    if (this.df_buffer !== null && this.df_buffer !== undefined) {
      output.writeFieldBegin('df_buffer', Thrift.Type.STRING, 7);
      output.writeBinary(this.df_buffer);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDBInfo = module.exports.TDBInfo = class {
  constructor(args) {
    this.db_name = null;
    this.db_owner = null;
    if (args) {
      if (args.db_name !== undefined && args.db_name !== null) {
        this.db_name = args.db_name;
      }
      if (args.db_owner !== undefined && args.db_owner !== null) {
        this.db_owner = args.db_owner;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.db_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.db_owner = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDBInfo');
    if (this.db_name !== null && this.db_name !== undefined) {
      output.writeFieldBegin('db_name', Thrift.Type.STRING, 1);
      output.writeString(this.db_name);
      output.writeFieldEnd();
    }
    if (this.db_owner !== null && this.db_owner !== undefined) {
      output.writeFieldBegin('db_owner', Thrift.Type.STRING, 2);
      output.writeString(this.db_owner);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDBException = module.exports.TDBException = class extends Thrift.TException {
  constructor(args) {
    super(args);
    this.name = "TDBException";
    this.error_msg = null;
    if (args) {
      if (args.error_msg !== undefined && args.error_msg !== null) {
        this.error_msg = args.error_msg;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.error_msg = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDBException');
    if (this.error_msg !== null && this.error_msg !== undefined) {
      output.writeFieldBegin('error_msg', Thrift.Type.STRING, 1);
      output.writeString(this.error_msg);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCopyParams = module.exports.TCopyParams = class {
  constructor(args) {
    this.delimiter = null;
    this.null_str = null;
    this.has_header = 0;
    this.quoted = null;
    this.quote = null;
    this.escape = null;
    this.line_delim = null;
    this.array_delim = null;
    this.array_begin = null;
    this.array_end = null;
    this.threads = null;
    this.source_type = 0;
    this.s3_access_key = null;
    this.s3_secret_key = null;
    this.s3_region = null;
    this.geo_coords_encoding = 6;
    this.geo_coords_comp_param = 32;
    this.geo_coords_type = 18;
    this.geo_coords_srid = 4326;
    this.sanitize_column_names = true;
    this.geo_layer_name = null;
    this.s3_endpoint = null;
    this.geo_assign_render_groups = false;
    this.geo_explode_collections = false;
    this.source_srid = 0;
    this.s3_session_token = null;
    this.raster_point_type = 1;
    this.raster_import_bands = null;
    this.raster_scanlines_per_thread = null;
    this.raster_point_transform = 1;
    this.raster_point_compute_angle = false;
    this.raster_import_dimensions = null;
    this.odbc_dsn = null;
    this.odbc_connection_string = null;
    this.odbc_sql_select = null;
    this.odbc_sql_order_by = null;
    this.odbc_username = null;
    this.odbc_password = null;
    this.odbc_credential_string = null;
    this.add_metadata_columns = null;
    this.trim_spaces = null;
    if (args) {
      if (args.delimiter !== undefined && args.delimiter !== null) {
        this.delimiter = args.delimiter;
      }
      if (args.null_str !== undefined && args.null_str !== null) {
        this.null_str = args.null_str;
      }
      if (args.has_header !== undefined && args.has_header !== null) {
        this.has_header = args.has_header;
      }
      if (args.quoted !== undefined && args.quoted !== null) {
        this.quoted = args.quoted;
      }
      if (args.quote !== undefined && args.quote !== null) {
        this.quote = args.quote;
      }
      if (args.escape !== undefined && args.escape !== null) {
        this.escape = args.escape;
      }
      if (args.line_delim !== undefined && args.line_delim !== null) {
        this.line_delim = args.line_delim;
      }
      if (args.array_delim !== undefined && args.array_delim !== null) {
        this.array_delim = args.array_delim;
      }
      if (args.array_begin !== undefined && args.array_begin !== null) {
        this.array_begin = args.array_begin;
      }
      if (args.array_end !== undefined && args.array_end !== null) {
        this.array_end = args.array_end;
      }
      if (args.threads !== undefined && args.threads !== null) {
        this.threads = args.threads;
      }
      if (args.source_type !== undefined && args.source_type !== null) {
        this.source_type = args.source_type;
      }
      if (args.s3_access_key !== undefined && args.s3_access_key !== null) {
        this.s3_access_key = args.s3_access_key;
      }
      if (args.s3_secret_key !== undefined && args.s3_secret_key !== null) {
        this.s3_secret_key = args.s3_secret_key;
      }
      if (args.s3_region !== undefined && args.s3_region !== null) {
        this.s3_region = args.s3_region;
      }
      if (args.geo_coords_encoding !== undefined && args.geo_coords_encoding !== null) {
        this.geo_coords_encoding = args.geo_coords_encoding;
      }
      if (args.geo_coords_comp_param !== undefined && args.geo_coords_comp_param !== null) {
        this.geo_coords_comp_param = args.geo_coords_comp_param;
      }
      if (args.geo_coords_type !== undefined && args.geo_coords_type !== null) {
        this.geo_coords_type = args.geo_coords_type;
      }
      if (args.geo_coords_srid !== undefined && args.geo_coords_srid !== null) {
        this.geo_coords_srid = args.geo_coords_srid;
      }
      if (args.sanitize_column_names !== undefined && args.sanitize_column_names !== null) {
        this.sanitize_column_names = args.sanitize_column_names;
      }
      if (args.geo_layer_name !== undefined && args.geo_layer_name !== null) {
        this.geo_layer_name = args.geo_layer_name;
      }
      if (args.s3_endpoint !== undefined && args.s3_endpoint !== null) {
        this.s3_endpoint = args.s3_endpoint;
      }
      if (args.geo_assign_render_groups !== undefined && args.geo_assign_render_groups !== null) {
        this.geo_assign_render_groups = args.geo_assign_render_groups;
      }
      if (args.geo_explode_collections !== undefined && args.geo_explode_collections !== null) {
        this.geo_explode_collections = args.geo_explode_collections;
      }
      if (args.source_srid !== undefined && args.source_srid !== null) {
        this.source_srid = args.source_srid;
      }
      if (args.s3_session_token !== undefined && args.s3_session_token !== null) {
        this.s3_session_token = args.s3_session_token;
      }
      if (args.raster_point_type !== undefined && args.raster_point_type !== null) {
        this.raster_point_type = args.raster_point_type;
      }
      if (args.raster_import_bands !== undefined && args.raster_import_bands !== null) {
        this.raster_import_bands = args.raster_import_bands;
      }
      if (args.raster_scanlines_per_thread !== undefined && args.raster_scanlines_per_thread !== null) {
        this.raster_scanlines_per_thread = args.raster_scanlines_per_thread;
      }
      if (args.raster_point_transform !== undefined && args.raster_point_transform !== null) {
        this.raster_point_transform = args.raster_point_transform;
      }
      if (args.raster_point_compute_angle !== undefined && args.raster_point_compute_angle !== null) {
        this.raster_point_compute_angle = args.raster_point_compute_angle;
      }
      if (args.raster_import_dimensions !== undefined && args.raster_import_dimensions !== null) {
        this.raster_import_dimensions = args.raster_import_dimensions;
      }
      if (args.odbc_dsn !== undefined && args.odbc_dsn !== null) {
        this.odbc_dsn = args.odbc_dsn;
      }
      if (args.odbc_connection_string !== undefined && args.odbc_connection_string !== null) {
        this.odbc_connection_string = args.odbc_connection_string;
      }
      if (args.odbc_sql_select !== undefined && args.odbc_sql_select !== null) {
        this.odbc_sql_select = args.odbc_sql_select;
      }
      if (args.odbc_sql_order_by !== undefined && args.odbc_sql_order_by !== null) {
        this.odbc_sql_order_by = args.odbc_sql_order_by;
      }
      if (args.odbc_username !== undefined && args.odbc_username !== null) {
        this.odbc_username = args.odbc_username;
      }
      if (args.odbc_password !== undefined && args.odbc_password !== null) {
        this.odbc_password = args.odbc_password;
      }
      if (args.odbc_credential_string !== undefined && args.odbc_credential_string !== null) {
        this.odbc_credential_string = args.odbc_credential_string;
      }
      if (args.add_metadata_columns !== undefined && args.add_metadata_columns !== null) {
        this.add_metadata_columns = args.add_metadata_columns;
      }
      if (args.trim_spaces !== undefined && args.trim_spaces !== null) {
        this.trim_spaces = args.trim_spaces;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.delimiter = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.null_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.has_header = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.quoted = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.quote = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.escape = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.line_delim = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.array_delim = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.array_begin = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.array_end = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.threads = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.source_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.s3_access_key = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.s3_secret_key = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.s3_region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.I32) {
          this.geo_coords_encoding = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.I32) {
          this.geo_coords_comp_param = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.geo_coords_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.I32) {
          this.geo_coords_srid = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.BOOL) {
          this.sanitize_column_names = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.geo_layer_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRING) {
          this.s3_endpoint = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.geo_assign_render_groups = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.BOOL) {
          this.geo_explode_collections = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I32) {
          this.source_srid = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRING) {
          this.s3_session_token = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.I32) {
          this.raster_point_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRING) {
          this.raster_import_bands = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.I32) {
          this.raster_scanlines_per_thread = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.I32) {
          this.raster_point_transform = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.BOOL) {
          this.raster_point_compute_angle = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.STRING) {
          this.raster_import_dimensions = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_dsn = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_connection_string = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_sql_select = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_sql_order_by = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 37:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_username = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 38:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_password = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 39:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_credential_string = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 40:
        if (ftype == Thrift.Type.STRING) {
          this.add_metadata_columns = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 41:
        if (ftype == Thrift.Type.BOOL) {
          this.trim_spaces = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCopyParams');
    if (this.delimiter !== null && this.delimiter !== undefined) {
      output.writeFieldBegin('delimiter', Thrift.Type.STRING, 1);
      output.writeString(this.delimiter);
      output.writeFieldEnd();
    }
    if (this.null_str !== null && this.null_str !== undefined) {
      output.writeFieldBegin('null_str', Thrift.Type.STRING, 2);
      output.writeString(this.null_str);
      output.writeFieldEnd();
    }
    if (this.has_header !== null && this.has_header !== undefined) {
      output.writeFieldBegin('has_header', Thrift.Type.I32, 3);
      output.writeI32(this.has_header);
      output.writeFieldEnd();
    }
    if (this.quoted !== null && this.quoted !== undefined) {
      output.writeFieldBegin('quoted', Thrift.Type.BOOL, 4);
      output.writeBool(this.quoted);
      output.writeFieldEnd();
    }
    if (this.quote !== null && this.quote !== undefined) {
      output.writeFieldBegin('quote', Thrift.Type.STRING, 5);
      output.writeString(this.quote);
      output.writeFieldEnd();
    }
    if (this.escape !== null && this.escape !== undefined) {
      output.writeFieldBegin('escape', Thrift.Type.STRING, 6);
      output.writeString(this.escape);
      output.writeFieldEnd();
    }
    if (this.line_delim !== null && this.line_delim !== undefined) {
      output.writeFieldBegin('line_delim', Thrift.Type.STRING, 7);
      output.writeString(this.line_delim);
      output.writeFieldEnd();
    }
    if (this.array_delim !== null && this.array_delim !== undefined) {
      output.writeFieldBegin('array_delim', Thrift.Type.STRING, 8);
      output.writeString(this.array_delim);
      output.writeFieldEnd();
    }
    if (this.array_begin !== null && this.array_begin !== undefined) {
      output.writeFieldBegin('array_begin', Thrift.Type.STRING, 9);
      output.writeString(this.array_begin);
      output.writeFieldEnd();
    }
    if (this.array_end !== null && this.array_end !== undefined) {
      output.writeFieldBegin('array_end', Thrift.Type.STRING, 10);
      output.writeString(this.array_end);
      output.writeFieldEnd();
    }
    if (this.threads !== null && this.threads !== undefined) {
      output.writeFieldBegin('threads', Thrift.Type.I32, 11);
      output.writeI32(this.threads);
      output.writeFieldEnd();
    }
    if (this.source_type !== null && this.source_type !== undefined) {
      output.writeFieldBegin('source_type', Thrift.Type.I32, 12);
      output.writeI32(this.source_type);
      output.writeFieldEnd();
    }
    if (this.s3_access_key !== null && this.s3_access_key !== undefined) {
      output.writeFieldBegin('s3_access_key', Thrift.Type.STRING, 13);
      output.writeString(this.s3_access_key);
      output.writeFieldEnd();
    }
    if (this.s3_secret_key !== null && this.s3_secret_key !== undefined) {
      output.writeFieldBegin('s3_secret_key', Thrift.Type.STRING, 14);
      output.writeString(this.s3_secret_key);
      output.writeFieldEnd();
    }
    if (this.s3_region !== null && this.s3_region !== undefined) {
      output.writeFieldBegin('s3_region', Thrift.Type.STRING, 15);
      output.writeString(this.s3_region);
      output.writeFieldEnd();
    }
    if (this.geo_coords_encoding !== null && this.geo_coords_encoding !== undefined) {
      output.writeFieldBegin('geo_coords_encoding', Thrift.Type.I32, 16);
      output.writeI32(this.geo_coords_encoding);
      output.writeFieldEnd();
    }
    if (this.geo_coords_comp_param !== null && this.geo_coords_comp_param !== undefined) {
      output.writeFieldBegin('geo_coords_comp_param', Thrift.Type.I32, 17);
      output.writeI32(this.geo_coords_comp_param);
      output.writeFieldEnd();
    }
    if (this.geo_coords_type !== null && this.geo_coords_type !== undefined) {
      output.writeFieldBegin('geo_coords_type', Thrift.Type.I32, 18);
      output.writeI32(this.geo_coords_type);
      output.writeFieldEnd();
    }
    if (this.geo_coords_srid !== null && this.geo_coords_srid !== undefined) {
      output.writeFieldBegin('geo_coords_srid', Thrift.Type.I32, 19);
      output.writeI32(this.geo_coords_srid);
      output.writeFieldEnd();
    }
    if (this.sanitize_column_names !== null && this.sanitize_column_names !== undefined) {
      output.writeFieldBegin('sanitize_column_names', Thrift.Type.BOOL, 20);
      output.writeBool(this.sanitize_column_names);
      output.writeFieldEnd();
    }
    if (this.geo_layer_name !== null && this.geo_layer_name !== undefined) {
      output.writeFieldBegin('geo_layer_name', Thrift.Type.STRING, 21);
      output.writeString(this.geo_layer_name);
      output.writeFieldEnd();
    }
    if (this.s3_endpoint !== null && this.s3_endpoint !== undefined) {
      output.writeFieldBegin('s3_endpoint', Thrift.Type.STRING, 22);
      output.writeString(this.s3_endpoint);
      output.writeFieldEnd();
    }
    if (this.geo_assign_render_groups !== null && this.geo_assign_render_groups !== undefined) {
      output.writeFieldBegin('geo_assign_render_groups', Thrift.Type.BOOL, 23);
      output.writeBool(this.geo_assign_render_groups);
      output.writeFieldEnd();
    }
    if (this.geo_explode_collections !== null && this.geo_explode_collections !== undefined) {
      output.writeFieldBegin('geo_explode_collections', Thrift.Type.BOOL, 24);
      output.writeBool(this.geo_explode_collections);
      output.writeFieldEnd();
    }
    if (this.source_srid !== null && this.source_srid !== undefined) {
      output.writeFieldBegin('source_srid', Thrift.Type.I32, 25);
      output.writeI32(this.source_srid);
      output.writeFieldEnd();
    }
    if (this.s3_session_token !== null && this.s3_session_token !== undefined) {
      output.writeFieldBegin('s3_session_token', Thrift.Type.STRING, 26);
      output.writeString(this.s3_session_token);
      output.writeFieldEnd();
    }
    if (this.raster_point_type !== null && this.raster_point_type !== undefined) {
      output.writeFieldBegin('raster_point_type', Thrift.Type.I32, 27);
      output.writeI32(this.raster_point_type);
      output.writeFieldEnd();
    }
    if (this.raster_import_bands !== null && this.raster_import_bands !== undefined) {
      output.writeFieldBegin('raster_import_bands', Thrift.Type.STRING, 28);
      output.writeString(this.raster_import_bands);
      output.writeFieldEnd();
    }
    if (this.raster_scanlines_per_thread !== null && this.raster_scanlines_per_thread !== undefined) {
      output.writeFieldBegin('raster_scanlines_per_thread', Thrift.Type.I32, 29);
      output.writeI32(this.raster_scanlines_per_thread);
      output.writeFieldEnd();
    }
    if (this.raster_point_transform !== null && this.raster_point_transform !== undefined) {
      output.writeFieldBegin('raster_point_transform', Thrift.Type.I32, 30);
      output.writeI32(this.raster_point_transform);
      output.writeFieldEnd();
    }
    if (this.raster_point_compute_angle !== null && this.raster_point_compute_angle !== undefined) {
      output.writeFieldBegin('raster_point_compute_angle', Thrift.Type.BOOL, 31);
      output.writeBool(this.raster_point_compute_angle);
      output.writeFieldEnd();
    }
    if (this.raster_import_dimensions !== null && this.raster_import_dimensions !== undefined) {
      output.writeFieldBegin('raster_import_dimensions', Thrift.Type.STRING, 32);
      output.writeString(this.raster_import_dimensions);
      output.writeFieldEnd();
    }
    if (this.odbc_dsn !== null && this.odbc_dsn !== undefined) {
      output.writeFieldBegin('odbc_dsn', Thrift.Type.STRING, 33);
      output.writeString(this.odbc_dsn);
      output.writeFieldEnd();
    }
    if (this.odbc_connection_string !== null && this.odbc_connection_string !== undefined) {
      output.writeFieldBegin('odbc_connection_string', Thrift.Type.STRING, 34);
      output.writeString(this.odbc_connection_string);
      output.writeFieldEnd();
    }
    if (this.odbc_sql_select !== null && this.odbc_sql_select !== undefined) {
      output.writeFieldBegin('odbc_sql_select', Thrift.Type.STRING, 35);
      output.writeString(this.odbc_sql_select);
      output.writeFieldEnd();
    }
    if (this.odbc_sql_order_by !== null && this.odbc_sql_order_by !== undefined) {
      output.writeFieldBegin('odbc_sql_order_by', Thrift.Type.STRING, 36);
      output.writeString(this.odbc_sql_order_by);
      output.writeFieldEnd();
    }
    if (this.odbc_username !== null && this.odbc_username !== undefined) {
      output.writeFieldBegin('odbc_username', Thrift.Type.STRING, 37);
      output.writeString(this.odbc_username);
      output.writeFieldEnd();
    }
    if (this.odbc_password !== null && this.odbc_password !== undefined) {
      output.writeFieldBegin('odbc_password', Thrift.Type.STRING, 38);
      output.writeString(this.odbc_password);
      output.writeFieldEnd();
    }
    if (this.odbc_credential_string !== null && this.odbc_credential_string !== undefined) {
      output.writeFieldBegin('odbc_credential_string', Thrift.Type.STRING, 39);
      output.writeString(this.odbc_credential_string);
      output.writeFieldEnd();
    }
    if (this.add_metadata_columns !== null && this.add_metadata_columns !== undefined) {
      output.writeFieldBegin('add_metadata_columns', Thrift.Type.STRING, 40);
      output.writeString(this.add_metadata_columns);
      output.writeFieldEnd();
    }
    if (this.trim_spaces !== null && this.trim_spaces !== undefined) {
      output.writeFieldBegin('trim_spaces', Thrift.Type.BOOL, 41);
      output.writeBool(this.trim_spaces);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCreateParams = module.exports.TCreateParams = class {
  constructor(args) {
    this.is_replicated = null;
    if (args) {
      if (args.is_replicated !== undefined && args.is_replicated !== null) {
        this.is_replicated = args.is_replicated;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.is_replicated = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCreateParams');
    if (this.is_replicated !== null && this.is_replicated !== undefined) {
      output.writeFieldBegin('is_replicated', Thrift.Type.BOOL, 1);
      output.writeBool(this.is_replicated);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDetectResult = module.exports.TDetectResult = class {
  constructor(args) {
    this.row_set = null;
    this.copy_params = null;
    if (args) {
      if (args.row_set !== undefined && args.row_set !== null) {
        this.row_set = new ttypes.TRowSet(args.row_set);
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.row_set = new ttypes.TRowSet();
          this.row_set.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDetectResult');
    if (this.row_set !== null && this.row_set !== undefined) {
      output.writeFieldBegin('row_set', Thrift.Type.STRUCT, 1);
      this.row_set.write(output);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 2);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TImportStatus = module.exports.TImportStatus = class {
  constructor(args) {
    this.elapsed = null;
    this.rows_completed = null;
    this.rows_estimated = null;
    this.rows_rejected = null;
    if (args) {
      if (args.elapsed !== undefined && args.elapsed !== null) {
        this.elapsed = args.elapsed;
      }
      if (args.rows_completed !== undefined && args.rows_completed !== null) {
        this.rows_completed = args.rows_completed;
      }
      if (args.rows_estimated !== undefined && args.rows_estimated !== null) {
        this.rows_estimated = args.rows_estimated;
      }
      if (args.rows_rejected !== undefined && args.rows_rejected !== null) {
        this.rows_rejected = args.rows_rejected;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.elapsed = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.rows_completed = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.rows_estimated = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.rows_rejected = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TImportStatus');
    if (this.elapsed !== null && this.elapsed !== undefined) {
      output.writeFieldBegin('elapsed', Thrift.Type.I64, 1);
      output.writeI64(this.elapsed);
      output.writeFieldEnd();
    }
    if (this.rows_completed !== null && this.rows_completed !== undefined) {
      output.writeFieldBegin('rows_completed', Thrift.Type.I64, 2);
      output.writeI64(this.rows_completed);
      output.writeFieldEnd();
    }
    if (this.rows_estimated !== null && this.rows_estimated !== undefined) {
      output.writeFieldBegin('rows_estimated', Thrift.Type.I64, 3);
      output.writeI64(this.rows_estimated);
      output.writeFieldEnd();
    }
    if (this.rows_rejected !== null && this.rows_rejected !== undefined) {
      output.writeFieldBegin('rows_rejected', Thrift.Type.I64, 4);
      output.writeI64(this.rows_rejected);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TFrontendView = module.exports.TFrontendView = class {
  constructor(args) {
    this.view_name = null;
    this.view_state = null;
    this.image_hash = null;
    this.update_time = null;
    this.view_metadata = null;
    if (args) {
      if (args.view_name !== undefined && args.view_name !== null) {
        this.view_name = args.view_name;
      }
      if (args.view_state !== undefined && args.view_state !== null) {
        this.view_state = args.view_state;
      }
      if (args.image_hash !== undefined && args.image_hash !== null) {
        this.image_hash = args.image_hash;
      }
      if (args.update_time !== undefined && args.update_time !== null) {
        this.update_time = args.update_time;
      }
      if (args.view_metadata !== undefined && args.view_metadata !== null) {
        this.view_metadata = args.view_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.view_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.view_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.image_hash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.update_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.view_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TFrontendView');
    if (this.view_name !== null && this.view_name !== undefined) {
      output.writeFieldBegin('view_name', Thrift.Type.STRING, 1);
      output.writeString(this.view_name);
      output.writeFieldEnd();
    }
    if (this.view_state !== null && this.view_state !== undefined) {
      output.writeFieldBegin('view_state', Thrift.Type.STRING, 2);
      output.writeString(this.view_state);
      output.writeFieldEnd();
    }
    if (this.image_hash !== null && this.image_hash !== undefined) {
      output.writeFieldBegin('image_hash', Thrift.Type.STRING, 3);
      output.writeString(this.image_hash);
      output.writeFieldEnd();
    }
    if (this.update_time !== null && this.update_time !== undefined) {
      output.writeFieldBegin('update_time', Thrift.Type.STRING, 4);
      output.writeString(this.update_time);
      output.writeFieldEnd();
    }
    if (this.view_metadata !== null && this.view_metadata !== undefined) {
      output.writeFieldBegin('view_metadata', Thrift.Type.STRING, 5);
      output.writeString(this.view_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TServerStatus = module.exports.TServerStatus = class {
  constructor(args) {
    this.read_only = null;
    this.version = null;
    this.rendering_enabled = null;
    this.start_time = null;
    this.edition = null;
    this.host_name = null;
    this.poly_rendering_enabled = null;
    this.role = null;
    this.renderer_status_json = null;
    if (args) {
      if (args.read_only !== undefined && args.read_only !== null) {
        this.read_only = args.read_only;
      }
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      }
      if (args.rendering_enabled !== undefined && args.rendering_enabled !== null) {
        this.rendering_enabled = args.rendering_enabled;
      }
      if (args.start_time !== undefined && args.start_time !== null) {
        this.start_time = args.start_time;
      }
      if (args.edition !== undefined && args.edition !== null) {
        this.edition = args.edition;
      }
      if (args.host_name !== undefined && args.host_name !== null) {
        this.host_name = args.host_name;
      }
      if (args.poly_rendering_enabled !== undefined && args.poly_rendering_enabled !== null) {
        this.poly_rendering_enabled = args.poly_rendering_enabled;
      }
      if (args.role !== undefined && args.role !== null) {
        this.role = args.role;
      }
      if (args.renderer_status_json !== undefined && args.renderer_status_json !== null) {
        this.renderer_status_json = args.renderer_status_json;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.read_only = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.version = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.rendering_enabled = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.start_time = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.edition = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.host_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.poly_rendering_enabled = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.role = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.renderer_status_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TServerStatus');
    if (this.read_only !== null && this.read_only !== undefined) {
      output.writeFieldBegin('read_only', Thrift.Type.BOOL, 1);
      output.writeBool(this.read_only);
      output.writeFieldEnd();
    }
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.STRING, 2);
      output.writeString(this.version);
      output.writeFieldEnd();
    }
    if (this.rendering_enabled !== null && this.rendering_enabled !== undefined) {
      output.writeFieldBegin('rendering_enabled', Thrift.Type.BOOL, 3);
      output.writeBool(this.rendering_enabled);
      output.writeFieldEnd();
    }
    if (this.start_time !== null && this.start_time !== undefined) {
      output.writeFieldBegin('start_time', Thrift.Type.I64, 4);
      output.writeI64(this.start_time);
      output.writeFieldEnd();
    }
    if (this.edition !== null && this.edition !== undefined) {
      output.writeFieldBegin('edition', Thrift.Type.STRING, 5);
      output.writeString(this.edition);
      output.writeFieldEnd();
    }
    if (this.host_name !== null && this.host_name !== undefined) {
      output.writeFieldBegin('host_name', Thrift.Type.STRING, 6);
      output.writeString(this.host_name);
      output.writeFieldEnd();
    }
    if (this.poly_rendering_enabled !== null && this.poly_rendering_enabled !== undefined) {
      output.writeFieldBegin('poly_rendering_enabled', Thrift.Type.BOOL, 7);
      output.writeBool(this.poly_rendering_enabled);
      output.writeFieldEnd();
    }
    if (this.role !== null && this.role !== undefined) {
      output.writeFieldBegin('role', Thrift.Type.I32, 8);
      output.writeI32(this.role);
      output.writeFieldEnd();
    }
    if (this.renderer_status_json !== null && this.renderer_status_json !== undefined) {
      output.writeFieldBegin('renderer_status_json', Thrift.Type.STRING, 9);
      output.writeString(this.renderer_status_json);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TPixel = module.exports.TPixel = class {
  constructor(args) {
    this.x = null;
    this.y = null;
    if (args) {
      if (args.x !== undefined && args.x !== null) {
        this.x = args.x;
      }
      if (args.y !== undefined && args.y !== null) {
        this.y = args.y;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.x = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.y = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TPixel');
    if (this.x !== null && this.x !== undefined) {
      output.writeFieldBegin('x', Thrift.Type.I64, 1);
      output.writeI64(this.x);
      output.writeFieldEnd();
    }
    if (this.y !== null && this.y !== undefined) {
      output.writeFieldBegin('y', Thrift.Type.I64, 2);
      output.writeI64(this.y);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TPixelTableRowResult = module.exports.TPixelTableRowResult = class {
  constructor(args) {
    this.pixel = null;
    this.vega_table_name = null;
    this.table_id = null;
    this.row_id = null;
    this.row_set = null;
    this.nonce = null;
    if (args) {
      if (args.pixel !== undefined && args.pixel !== null) {
        this.pixel = new ttypes.TPixel(args.pixel);
      }
      if (args.vega_table_name !== undefined && args.vega_table_name !== null) {
        this.vega_table_name = args.vega_table_name;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = Thrift.copyList(args.table_id, [null]);
      }
      if (args.row_id !== undefined && args.row_id !== null) {
        this.row_id = Thrift.copyList(args.row_id, [null]);
      }
      if (args.row_set !== undefined && args.row_set !== null) {
        this.row_set = new ttypes.TRowSet(args.row_set);
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.pixel = new ttypes.TPixel();
          this.pixel.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.vega_table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.table_id = [];
          const _rtmp361 = input.readListBegin();
          const _size60 = _rtmp361.size || 0;
          for (let _i62 = 0; _i62 < _size60; ++_i62) {
            let elem63 = null;
            elem63 = input.readI64();
            this.table_id.push(elem63);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.row_id = [];
          const _rtmp365 = input.readListBegin();
          const _size64 = _rtmp365.size || 0;
          for (let _i66 = 0; _i66 < _size64; ++_i66) {
            let elem67 = null;
            elem67 = input.readI64();
            this.row_id.push(elem67);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.row_set = new ttypes.TRowSet();
          this.row_set.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TPixelTableRowResult');
    if (this.pixel !== null && this.pixel !== undefined) {
      output.writeFieldBegin('pixel', Thrift.Type.STRUCT, 1);
      this.pixel.write(output);
      output.writeFieldEnd();
    }
    if (this.vega_table_name !== null && this.vega_table_name !== undefined) {
      output.writeFieldBegin('vega_table_name', Thrift.Type.STRING, 2);
      output.writeString(this.vega_table_name);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.I64, this.table_id.length);
      for (let iter68 in this.table_id) {
        if (this.table_id.hasOwnProperty(iter68)) {
          iter68 = this.table_id[iter68];
          output.writeI64(iter68);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.row_id !== null && this.row_id !== undefined) {
      output.writeFieldBegin('row_id', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.I64, this.row_id.length);
      for (let iter69 in this.row_id) {
        if (this.row_id.hasOwnProperty(iter69)) {
          iter69 = this.row_id[iter69];
          output.writeI64(iter69);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.row_set !== null && this.row_set !== undefined) {
      output.writeFieldBegin('row_set', Thrift.Type.STRUCT, 5);
      this.row_set.write(output);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 6);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRenderResult = module.exports.TRenderResult = class {
  constructor(args) {
    this.image = null;
    this.nonce = null;
    this.execution_time_ms = null;
    this.render_time_ms = null;
    this.total_time_ms = null;
    this.vega_metadata = null;
    if (args) {
      if (args.image !== undefined && args.image !== null) {
        this.image = args.image;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.render_time_ms !== undefined && args.render_time_ms !== null) {
        this.render_time_ms = args.render_time_ms;
      }
      if (args.total_time_ms !== undefined && args.total_time_ms !== null) {
        this.total_time_ms = args.total_time_ms;
      }
      if (args.vega_metadata !== undefined && args.vega_metadata !== null) {
        this.vega_metadata = args.vega_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.image = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.render_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.total_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.vega_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRenderResult');
    if (this.image !== null && this.image !== undefined) {
      output.writeFieldBegin('image', Thrift.Type.STRING, 1);
      output.writeBinary(this.image);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 2);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 3);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.render_time_ms !== null && this.render_time_ms !== undefined) {
      output.writeFieldBegin('render_time_ms', Thrift.Type.I64, 4);
      output.writeI64(this.render_time_ms);
      output.writeFieldEnd();
    }
    if (this.total_time_ms !== null && this.total_time_ms !== undefined) {
      output.writeFieldBegin('total_time_ms', Thrift.Type.I64, 5);
      output.writeI64(this.total_time_ms);
      output.writeFieldEnd();
    }
    if (this.vega_metadata !== null && this.vega_metadata !== undefined) {
      output.writeFieldBegin('vega_metadata', Thrift.Type.STRING, 6);
      output.writeString(this.vega_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TGpuSpecification = module.exports.TGpuSpecification = class {
  constructor(args) {
    this.num_sm = null;
    this.clock_frequency_kHz = null;
    this.memory = null;
    this.compute_capability_major = null;
    this.compute_capability_minor = null;
    if (args) {
      if (args.num_sm !== undefined && args.num_sm !== null) {
        this.num_sm = args.num_sm;
      }
      if (args.clock_frequency_kHz !== undefined && args.clock_frequency_kHz !== null) {
        this.clock_frequency_kHz = args.clock_frequency_kHz;
      }
      if (args.memory !== undefined && args.memory !== null) {
        this.memory = args.memory;
      }
      if (args.compute_capability_major !== undefined && args.compute_capability_major !== null) {
        this.compute_capability_major = args.compute_capability_major;
      }
      if (args.compute_capability_minor !== undefined && args.compute_capability_minor !== null) {
        this.compute_capability_minor = args.compute_capability_minor;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.num_sm = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.clock_frequency_kHz = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.memory = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I16) {
          this.compute_capability_major = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I16) {
          this.compute_capability_minor = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TGpuSpecification');
    if (this.num_sm !== null && this.num_sm !== undefined) {
      output.writeFieldBegin('num_sm', Thrift.Type.I32, 1);
      output.writeI32(this.num_sm);
      output.writeFieldEnd();
    }
    if (this.clock_frequency_kHz !== null && this.clock_frequency_kHz !== undefined) {
      output.writeFieldBegin('clock_frequency_kHz', Thrift.Type.I64, 2);
      output.writeI64(this.clock_frequency_kHz);
      output.writeFieldEnd();
    }
    if (this.memory !== null && this.memory !== undefined) {
      output.writeFieldBegin('memory', Thrift.Type.I64, 3);
      output.writeI64(this.memory);
      output.writeFieldEnd();
    }
    if (this.compute_capability_major !== null && this.compute_capability_major !== undefined) {
      output.writeFieldBegin('compute_capability_major', Thrift.Type.I16, 4);
      output.writeI16(this.compute_capability_major);
      output.writeFieldEnd();
    }
    if (this.compute_capability_minor !== null && this.compute_capability_minor !== undefined) {
      output.writeFieldBegin('compute_capability_minor', Thrift.Type.I16, 5);
      output.writeI16(this.compute_capability_minor);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const THardwareInfo = module.exports.THardwareInfo = class {
  constructor(args) {
    this.num_gpu_hw = null;
    this.num_cpu_hw = null;
    this.num_gpu_allocated = null;
    this.start_gpu = null;
    this.host_name = null;
    this.gpu_info = null;
    if (args) {
      if (args.num_gpu_hw !== undefined && args.num_gpu_hw !== null) {
        this.num_gpu_hw = args.num_gpu_hw;
      }
      if (args.num_cpu_hw !== undefined && args.num_cpu_hw !== null) {
        this.num_cpu_hw = args.num_cpu_hw;
      }
      if (args.num_gpu_allocated !== undefined && args.num_gpu_allocated !== null) {
        this.num_gpu_allocated = args.num_gpu_allocated;
      }
      if (args.start_gpu !== undefined && args.start_gpu !== null) {
        this.start_gpu = args.start_gpu;
      }
      if (args.host_name !== undefined && args.host_name !== null) {
        this.host_name = args.host_name;
      }
      if (args.gpu_info !== undefined && args.gpu_info !== null) {
        this.gpu_info = Thrift.copyList(args.gpu_info, [ttypes.TGpuSpecification]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I16) {
          this.num_gpu_hw = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I16) {
          this.num_cpu_hw = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I16) {
          this.num_gpu_allocated = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I16) {
          this.start_gpu = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.host_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.gpu_info = [];
          const _rtmp371 = input.readListBegin();
          const _size70 = _rtmp371.size || 0;
          for (let _i72 = 0; _i72 < _size70; ++_i72) {
            let elem73 = null;
            elem73 = new ttypes.TGpuSpecification();
            elem73.read(input);
            this.gpu_info.push(elem73);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('THardwareInfo');
    if (this.num_gpu_hw !== null && this.num_gpu_hw !== undefined) {
      output.writeFieldBegin('num_gpu_hw', Thrift.Type.I16, 1);
      output.writeI16(this.num_gpu_hw);
      output.writeFieldEnd();
    }
    if (this.num_cpu_hw !== null && this.num_cpu_hw !== undefined) {
      output.writeFieldBegin('num_cpu_hw', Thrift.Type.I16, 2);
      output.writeI16(this.num_cpu_hw);
      output.writeFieldEnd();
    }
    if (this.num_gpu_allocated !== null && this.num_gpu_allocated !== undefined) {
      output.writeFieldBegin('num_gpu_allocated', Thrift.Type.I16, 3);
      output.writeI16(this.num_gpu_allocated);
      output.writeFieldEnd();
    }
    if (this.start_gpu !== null && this.start_gpu !== undefined) {
      output.writeFieldBegin('start_gpu', Thrift.Type.I16, 4);
      output.writeI16(this.start_gpu);
      output.writeFieldEnd();
    }
    if (this.host_name !== null && this.host_name !== undefined) {
      output.writeFieldBegin('host_name', Thrift.Type.STRING, 5);
      output.writeString(this.host_name);
      output.writeFieldEnd();
    }
    if (this.gpu_info !== null && this.gpu_info !== undefined) {
      output.writeFieldBegin('gpu_info', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.gpu_info.length);
      for (let iter74 in this.gpu_info) {
        if (this.gpu_info.hasOwnProperty(iter74)) {
          iter74 = this.gpu_info[iter74];
          iter74.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TClusterHardwareInfo = module.exports.TClusterHardwareInfo = class {
  constructor(args) {
    this.hardware_info = null;
    if (args) {
      if (args.hardware_info !== undefined && args.hardware_info !== null) {
        this.hardware_info = Thrift.copyList(args.hardware_info, [ttypes.THardwareInfo]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.hardware_info = [];
          const _rtmp376 = input.readListBegin();
          const _size75 = _rtmp376.size || 0;
          for (let _i77 = 0; _i77 < _size75; ++_i77) {
            let elem78 = null;
            elem78 = new ttypes.THardwareInfo();
            elem78.read(input);
            this.hardware_info.push(elem78);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TClusterHardwareInfo');
    if (this.hardware_info !== null && this.hardware_info !== undefined) {
      output.writeFieldBegin('hardware_info', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.hardware_info.length);
      for (let iter79 in this.hardware_info) {
        if (this.hardware_info.hasOwnProperty(iter79)) {
          iter79 = this.hardware_info[iter79];
          iter79.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TMemoryData = module.exports.TMemoryData = class {
  constructor(args) {
    this.slab = null;
    this.start_page = null;
    this.num_pages = null;
    this.touch = null;
    this.chunk_key = null;
    this.buffer_epoch = null;
    this.is_free = null;
    if (args) {
      if (args.slab !== undefined && args.slab !== null) {
        this.slab = args.slab;
      }
      if (args.start_page !== undefined && args.start_page !== null) {
        this.start_page = args.start_page;
      }
      if (args.num_pages !== undefined && args.num_pages !== null) {
        this.num_pages = args.num_pages;
      }
      if (args.touch !== undefined && args.touch !== null) {
        this.touch = args.touch;
      }
      if (args.chunk_key !== undefined && args.chunk_key !== null) {
        this.chunk_key = Thrift.copyList(args.chunk_key, [null]);
      }
      if (args.buffer_epoch !== undefined && args.buffer_epoch !== null) {
        this.buffer_epoch = args.buffer_epoch;
      }
      if (args.is_free !== undefined && args.is_free !== null) {
        this.is_free = args.is_free;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.slab = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.start_page = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.num_pages = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.touch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.chunk_key = [];
          const _rtmp381 = input.readListBegin();
          const _size80 = _rtmp381.size || 0;
          for (let _i82 = 0; _i82 < _size80; ++_i82) {
            let elem83 = null;
            elem83 = input.readI64();
            this.chunk_key.push(elem83);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.buffer_epoch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.is_free = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TMemoryData');
    if (this.slab !== null && this.slab !== undefined) {
      output.writeFieldBegin('slab', Thrift.Type.I64, 1);
      output.writeI64(this.slab);
      output.writeFieldEnd();
    }
    if (this.start_page !== null && this.start_page !== undefined) {
      output.writeFieldBegin('start_page', Thrift.Type.I32, 2);
      output.writeI32(this.start_page);
      output.writeFieldEnd();
    }
    if (this.num_pages !== null && this.num_pages !== undefined) {
      output.writeFieldBegin('num_pages', Thrift.Type.I64, 3);
      output.writeI64(this.num_pages);
      output.writeFieldEnd();
    }
    if (this.touch !== null && this.touch !== undefined) {
      output.writeFieldBegin('touch', Thrift.Type.I32, 4);
      output.writeI32(this.touch);
      output.writeFieldEnd();
    }
    if (this.chunk_key !== null && this.chunk_key !== undefined) {
      output.writeFieldBegin('chunk_key', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.I64, this.chunk_key.length);
      for (let iter84 in this.chunk_key) {
        if (this.chunk_key.hasOwnProperty(iter84)) {
          iter84 = this.chunk_key[iter84];
          output.writeI64(iter84);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.buffer_epoch !== null && this.buffer_epoch !== undefined) {
      output.writeFieldBegin('buffer_epoch', Thrift.Type.I32, 6);
      output.writeI32(this.buffer_epoch);
      output.writeFieldEnd();
    }
    if (this.is_free !== null && this.is_free !== undefined) {
      output.writeFieldBegin('is_free', Thrift.Type.BOOL, 7);
      output.writeBool(this.is_free);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TNodeMemoryInfo = module.exports.TNodeMemoryInfo = class {
  constructor(args) {
    this.host_name = null;
    this.page_size = null;
    this.max_num_pages = null;
    this.num_pages_allocated = null;
    this.is_allocation_capped = null;
    this.node_memory_data = null;
    if (args) {
      if (args.host_name !== undefined && args.host_name !== null) {
        this.host_name = args.host_name;
      }
      if (args.page_size !== undefined && args.page_size !== null) {
        this.page_size = args.page_size;
      }
      if (args.max_num_pages !== undefined && args.max_num_pages !== null) {
        this.max_num_pages = args.max_num_pages;
      }
      if (args.num_pages_allocated !== undefined && args.num_pages_allocated !== null) {
        this.num_pages_allocated = args.num_pages_allocated;
      }
      if (args.is_allocation_capped !== undefined && args.is_allocation_capped !== null) {
        this.is_allocation_capped = args.is_allocation_capped;
      }
      if (args.node_memory_data !== undefined && args.node_memory_data !== null) {
        this.node_memory_data = Thrift.copyList(args.node_memory_data, [ttypes.TMemoryData]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.host_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.page_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.max_num_pages = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.num_pages_allocated = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.is_allocation_capped = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.node_memory_data = [];
          const _rtmp386 = input.readListBegin();
          const _size85 = _rtmp386.size || 0;
          for (let _i87 = 0; _i87 < _size85; ++_i87) {
            let elem88 = null;
            elem88 = new ttypes.TMemoryData();
            elem88.read(input);
            this.node_memory_data.push(elem88);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TNodeMemoryInfo');
    if (this.host_name !== null && this.host_name !== undefined) {
      output.writeFieldBegin('host_name', Thrift.Type.STRING, 1);
      output.writeString(this.host_name);
      output.writeFieldEnd();
    }
    if (this.page_size !== null && this.page_size !== undefined) {
      output.writeFieldBegin('page_size', Thrift.Type.I64, 2);
      output.writeI64(this.page_size);
      output.writeFieldEnd();
    }
    if (this.max_num_pages !== null && this.max_num_pages !== undefined) {
      output.writeFieldBegin('max_num_pages', Thrift.Type.I64, 3);
      output.writeI64(this.max_num_pages);
      output.writeFieldEnd();
    }
    if (this.num_pages_allocated !== null && this.num_pages_allocated !== undefined) {
      output.writeFieldBegin('num_pages_allocated', Thrift.Type.I64, 4);
      output.writeI64(this.num_pages_allocated);
      output.writeFieldEnd();
    }
    if (this.is_allocation_capped !== null && this.is_allocation_capped !== undefined) {
      output.writeFieldBegin('is_allocation_capped', Thrift.Type.BOOL, 5);
      output.writeBool(this.is_allocation_capped);
      output.writeFieldEnd();
    }
    if (this.node_memory_data !== null && this.node_memory_data !== undefined) {
      output.writeFieldBegin('node_memory_data', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.node_memory_data.length);
      for (let iter89 in this.node_memory_data) {
        if (this.node_memory_data.hasOwnProperty(iter89)) {
          iter89 = this.node_memory_data[iter89];
          iter89.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableMeta = module.exports.TTableMeta = class {
  constructor(args) {
    this.table_name = null;
    this.num_cols = null;
    this.is_view = null;
    this.is_replicated = null;
    this.shard_count = null;
    this.max_rows = null;
    this.table_id = null;
    this.max_table_id = null;
    this.col_types = null;
    this.col_names = null;
    if (args) {
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.num_cols !== undefined && args.num_cols !== null) {
        this.num_cols = args.num_cols;
      }
      if (args.is_view !== undefined && args.is_view !== null) {
        this.is_view = args.is_view;
      }
      if (args.is_replicated !== undefined && args.is_replicated !== null) {
        this.is_replicated = args.is_replicated;
      }
      if (args.shard_count !== undefined && args.shard_count !== null) {
        this.shard_count = args.shard_count;
      }
      if (args.max_rows !== undefined && args.max_rows !== null) {
        this.max_rows = args.max_rows;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.max_table_id !== undefined && args.max_table_id !== null) {
        this.max_table_id = args.max_table_id;
      }
      if (args.col_types !== undefined && args.col_types !== null) {
        this.col_types = Thrift.copyList(args.col_types, [common_ttypes.TTypeInfo]);
      }
      if (args.col_names !== undefined && args.col_names !== null) {
        this.col_names = Thrift.copyList(args.col_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.num_cols = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.is_view = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.is_replicated = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.shard_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.max_rows = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.table_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.max_table_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.col_types = [];
          const _rtmp391 = input.readListBegin();
          const _size90 = _rtmp391.size || 0;
          for (let _i92 = 0; _i92 < _size90; ++_i92) {
            let elem93 = null;
            elem93 = new common_ttypes.TTypeInfo();
            elem93.read(input);
            this.col_types.push(elem93);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.LIST) {
          this.col_names = [];
          const _rtmp395 = input.readListBegin();
          const _size94 = _rtmp395.size || 0;
          for (let _i96 = 0; _i96 < _size94; ++_i96) {
            let elem97 = null;
            elem97 = input.readString();
            this.col_names.push(elem97);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableMeta');
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 1);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.num_cols !== null && this.num_cols !== undefined) {
      output.writeFieldBegin('num_cols', Thrift.Type.I64, 2);
      output.writeI64(this.num_cols);
      output.writeFieldEnd();
    }
    if (this.is_view !== null && this.is_view !== undefined) {
      output.writeFieldBegin('is_view', Thrift.Type.BOOL, 4);
      output.writeBool(this.is_view);
      output.writeFieldEnd();
    }
    if (this.is_replicated !== null && this.is_replicated !== undefined) {
      output.writeFieldBegin('is_replicated', Thrift.Type.BOOL, 5);
      output.writeBool(this.is_replicated);
      output.writeFieldEnd();
    }
    if (this.shard_count !== null && this.shard_count !== undefined) {
      output.writeFieldBegin('shard_count', Thrift.Type.I64, 6);
      output.writeI64(this.shard_count);
      output.writeFieldEnd();
    }
    if (this.max_rows !== null && this.max_rows !== undefined) {
      output.writeFieldBegin('max_rows', Thrift.Type.I64, 7);
      output.writeI64(this.max_rows);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I64, 8);
      output.writeI64(this.table_id);
      output.writeFieldEnd();
    }
    if (this.max_table_id !== null && this.max_table_id !== undefined) {
      output.writeFieldBegin('max_table_id', Thrift.Type.I64, 9);
      output.writeI64(this.max_table_id);
      output.writeFieldEnd();
    }
    if (this.col_types !== null && this.col_types !== undefined) {
      output.writeFieldBegin('col_types', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.col_types.length);
      for (let iter98 in this.col_types) {
        if (this.col_types.hasOwnProperty(iter98)) {
          iter98 = this.col_types[iter98];
          iter98.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.col_names !== null && this.col_names !== undefined) {
      output.writeFieldBegin('col_names', Thrift.Type.LIST, 11);
      output.writeListBegin(Thrift.Type.STRING, this.col_names.length);
      for (let iter99 in this.col_names) {
        if (this.col_names.hasOwnProperty(iter99)) {
          iter99 = this.col_names[iter99];
          output.writeString(iter99);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableRefreshInfo = module.exports.TTableRefreshInfo = class {
  constructor(args) {
    this.update_type = null;
    this.timing_type = null;
    this.start_date_time = null;
    this.interval_type = null;
    this.interval_count = null;
    this.last_refresh_time = null;
    this.next_refresh_time = null;
    if (args) {
      if (args.update_type !== undefined && args.update_type !== null) {
        this.update_type = args.update_type;
      }
      if (args.timing_type !== undefined && args.timing_type !== null) {
        this.timing_type = args.timing_type;
      }
      if (args.start_date_time !== undefined && args.start_date_time !== null) {
        this.start_date_time = args.start_date_time;
      }
      if (args.interval_type !== undefined && args.interval_type !== null) {
        this.interval_type = args.interval_type;
      }
      if (args.interval_count !== undefined && args.interval_count !== null) {
        this.interval_count = args.interval_count;
      }
      if (args.last_refresh_time !== undefined && args.last_refresh_time !== null) {
        this.last_refresh_time = args.last_refresh_time;
      }
      if (args.next_refresh_time !== undefined && args.next_refresh_time !== null) {
        this.next_refresh_time = args.next_refresh_time;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.update_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.timing_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.start_date_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.interval_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.interval_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.last_refresh_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.next_refresh_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableRefreshInfo');
    if (this.update_type !== null && this.update_type !== undefined) {
      output.writeFieldBegin('update_type', Thrift.Type.I32, 1);
      output.writeI32(this.update_type);
      output.writeFieldEnd();
    }
    if (this.timing_type !== null && this.timing_type !== undefined) {
      output.writeFieldBegin('timing_type', Thrift.Type.I32, 2);
      output.writeI32(this.timing_type);
      output.writeFieldEnd();
    }
    if (this.start_date_time !== null && this.start_date_time !== undefined) {
      output.writeFieldBegin('start_date_time', Thrift.Type.STRING, 3);
      output.writeString(this.start_date_time);
      output.writeFieldEnd();
    }
    if (this.interval_type !== null && this.interval_type !== undefined) {
      output.writeFieldBegin('interval_type', Thrift.Type.I32, 4);
      output.writeI32(this.interval_type);
      output.writeFieldEnd();
    }
    if (this.interval_count !== null && this.interval_count !== undefined) {
      output.writeFieldBegin('interval_count', Thrift.Type.I64, 5);
      output.writeI64(this.interval_count);
      output.writeFieldEnd();
    }
    if (this.last_refresh_time !== null && this.last_refresh_time !== undefined) {
      output.writeFieldBegin('last_refresh_time', Thrift.Type.STRING, 6);
      output.writeString(this.last_refresh_time);
      output.writeFieldEnd();
    }
    if (this.next_refresh_time !== null && this.next_refresh_time !== undefined) {
      output.writeFieldBegin('next_refresh_time', Thrift.Type.STRING, 7);
      output.writeString(this.next_refresh_time);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableDetails = module.exports.TTableDetails = class {
  constructor(args) {
    this.row_desc = null;
    this.fragment_size = null;
    this.page_size = null;
    this.max_rows = null;
    this.view_sql = null;
    this.shard_count = null;
    this.key_metainfo = null;
    this.is_temporary = null;
    this.partition_detail = null;
    this.table_type = null;
    this.refresh_info = null;
    if (args) {
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.fragment_size !== undefined && args.fragment_size !== null) {
        this.fragment_size = args.fragment_size;
      }
      if (args.page_size !== undefined && args.page_size !== null) {
        this.page_size = args.page_size;
      }
      if (args.max_rows !== undefined && args.max_rows !== null) {
        this.max_rows = args.max_rows;
      }
      if (args.view_sql !== undefined && args.view_sql !== null) {
        this.view_sql = args.view_sql;
      }
      if (args.shard_count !== undefined && args.shard_count !== null) {
        this.shard_count = args.shard_count;
      }
      if (args.key_metainfo !== undefined && args.key_metainfo !== null) {
        this.key_metainfo = args.key_metainfo;
      }
      if (args.is_temporary !== undefined && args.is_temporary !== null) {
        this.is_temporary = args.is_temporary;
      }
      if (args.partition_detail !== undefined && args.partition_detail !== null) {
        this.partition_detail = args.partition_detail;
      }
      if (args.table_type !== undefined && args.table_type !== null) {
        this.table_type = args.table_type;
      }
      if (args.refresh_info !== undefined && args.refresh_info !== null) {
        this.refresh_info = new ttypes.TTableRefreshInfo(args.refresh_info);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp3101 = input.readListBegin();
          const _size100 = _rtmp3101.size || 0;
          for (let _i102 = 0; _i102 < _size100; ++_i102) {
            let elem103 = null;
            elem103 = new ttypes.TColumnType();
            elem103.read(input);
            this.row_desc.push(elem103);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.fragment_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.page_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.max_rows = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.view_sql = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.shard_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.key_metainfo = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.is_temporary = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.partition_detail = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.table_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.refresh_info = new ttypes.TTableRefreshInfo();
          this.refresh_info.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableDetails');
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter104 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter104)) {
          iter104 = this.row_desc[iter104];
          iter104.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.fragment_size !== null && this.fragment_size !== undefined) {
      output.writeFieldBegin('fragment_size', Thrift.Type.I64, 2);
      output.writeI64(this.fragment_size);
      output.writeFieldEnd();
    }
    if (this.page_size !== null && this.page_size !== undefined) {
      output.writeFieldBegin('page_size', Thrift.Type.I64, 3);
      output.writeI64(this.page_size);
      output.writeFieldEnd();
    }
    if (this.max_rows !== null && this.max_rows !== undefined) {
      output.writeFieldBegin('max_rows', Thrift.Type.I64, 4);
      output.writeI64(this.max_rows);
      output.writeFieldEnd();
    }
    if (this.view_sql !== null && this.view_sql !== undefined) {
      output.writeFieldBegin('view_sql', Thrift.Type.STRING, 5);
      output.writeString(this.view_sql);
      output.writeFieldEnd();
    }
    if (this.shard_count !== null && this.shard_count !== undefined) {
      output.writeFieldBegin('shard_count', Thrift.Type.I64, 6);
      output.writeI64(this.shard_count);
      output.writeFieldEnd();
    }
    if (this.key_metainfo !== null && this.key_metainfo !== undefined) {
      output.writeFieldBegin('key_metainfo', Thrift.Type.STRING, 7);
      output.writeString(this.key_metainfo);
      output.writeFieldEnd();
    }
    if (this.is_temporary !== null && this.is_temporary !== undefined) {
      output.writeFieldBegin('is_temporary', Thrift.Type.BOOL, 8);
      output.writeBool(this.is_temporary);
      output.writeFieldEnd();
    }
    if (this.partition_detail !== null && this.partition_detail !== undefined) {
      output.writeFieldBegin('partition_detail', Thrift.Type.I32, 9);
      output.writeI32(this.partition_detail);
      output.writeFieldEnd();
    }
    if (this.table_type !== null && this.table_type !== undefined) {
      output.writeFieldBegin('table_type', Thrift.Type.I32, 10);
      output.writeI32(this.table_type);
      output.writeFieldEnd();
    }
    if (this.refresh_info !== null && this.refresh_info !== undefined) {
      output.writeFieldBegin('refresh_info', Thrift.Type.STRUCT, 11);
      this.refresh_info.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColumnRange = module.exports.TColumnRange = class {
  constructor(args) {
    this.type = null;
    this.col_id = null;
    this.table_id = null;
    this.has_nulls = null;
    this.int_min = null;
    this.int_max = null;
    this.bucket = null;
    this.fp_min = null;
    this.fp_max = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.col_id !== undefined && args.col_id !== null) {
        this.col_id = args.col_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.has_nulls !== undefined && args.has_nulls !== null) {
        this.has_nulls = args.has_nulls;
      }
      if (args.int_min !== undefined && args.int_min !== null) {
        this.int_min = args.int_min;
      }
      if (args.int_max !== undefined && args.int_max !== null) {
        this.int_max = args.int_max;
      }
      if (args.bucket !== undefined && args.bucket !== null) {
        this.bucket = args.bucket;
      }
      if (args.fp_min !== undefined && args.fp_min !== null) {
        this.fp_min = args.fp_min;
      }
      if (args.fp_max !== undefined && args.fp_max !== null) {
        this.fp_max = args.fp_max;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.col_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.has_nulls = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.int_min = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.int_max = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.bucket = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.DOUBLE) {
          this.fp_min = input.readDouble();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.DOUBLE) {
          this.fp_max = input.readDouble();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColumnRange');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.col_id !== null && this.col_id !== undefined) {
      output.writeFieldBegin('col_id', Thrift.Type.I32, 2);
      output.writeI32(this.col_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 3);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.has_nulls !== null && this.has_nulls !== undefined) {
      output.writeFieldBegin('has_nulls', Thrift.Type.BOOL, 4);
      output.writeBool(this.has_nulls);
      output.writeFieldEnd();
    }
    if (this.int_min !== null && this.int_min !== undefined) {
      output.writeFieldBegin('int_min', Thrift.Type.I64, 5);
      output.writeI64(this.int_min);
      output.writeFieldEnd();
    }
    if (this.int_max !== null && this.int_max !== undefined) {
      output.writeFieldBegin('int_max', Thrift.Type.I64, 6);
      output.writeI64(this.int_max);
      output.writeFieldEnd();
    }
    if (this.bucket !== null && this.bucket !== undefined) {
      output.writeFieldBegin('bucket', Thrift.Type.I64, 7);
      output.writeI64(this.bucket);
      output.writeFieldEnd();
    }
    if (this.fp_min !== null && this.fp_min !== undefined) {
      output.writeFieldBegin('fp_min', Thrift.Type.DOUBLE, 8);
      output.writeDouble(this.fp_min);
      output.writeFieldEnd();
    }
    if (this.fp_max !== null && this.fp_max !== undefined) {
      output.writeFieldBegin('fp_max', Thrift.Type.DOUBLE, 9);
      output.writeDouble(this.fp_max);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDictionaryGeneration = module.exports.TDictionaryGeneration = class {
  constructor(args) {
    this.dict_id = null;
    this.entry_count = null;
    if (args) {
      if (args.dict_id !== undefined && args.dict_id !== null) {
        this.dict_id = args.dict_id;
      }
      if (args.entry_count !== undefined && args.entry_count !== null) {
        this.entry_count = args.entry_count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.dict_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.entry_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDictionaryGeneration');
    if (this.dict_id !== null && this.dict_id !== undefined) {
      output.writeFieldBegin('dict_id', Thrift.Type.I32, 1);
      output.writeI32(this.dict_id);
      output.writeFieldEnd();
    }
    if (this.entry_count !== null && this.entry_count !== undefined) {
      output.writeFieldBegin('entry_count', Thrift.Type.I64, 2);
      output.writeI64(this.entry_count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableGeneration = module.exports.TTableGeneration = class {
  constructor(args) {
    this.table_id = null;
    this.tuple_count = null;
    this.start_rowid = null;
    if (args) {
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.tuple_count !== undefined && args.tuple_count !== null) {
        this.tuple_count = args.tuple_count;
      }
      if (args.start_rowid !== undefined && args.start_rowid !== null) {
        this.start_rowid = args.start_rowid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.tuple_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.start_rowid = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableGeneration');
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 1);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.tuple_count !== null && this.tuple_count !== undefined) {
      output.writeFieldBegin('tuple_count', Thrift.Type.I64, 2);
      output.writeI64(this.tuple_count);
      output.writeFieldEnd();
    }
    if (this.start_rowid !== null && this.start_rowid !== undefined) {
      output.writeFieldBegin('start_rowid', Thrift.Type.I64, 3);
      output.writeI64(this.start_rowid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TPendingQuery = module.exports.TPendingQuery = class {
  constructor(args) {
    this.id = null;
    this.column_ranges = null;
    this.dictionary_generations = null;
    this.table_generations = null;
    this.parent_session_id = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.column_ranges !== undefined && args.column_ranges !== null) {
        this.column_ranges = Thrift.copyList(args.column_ranges, [ttypes.TColumnRange]);
      }
      if (args.dictionary_generations !== undefined && args.dictionary_generations !== null) {
        this.dictionary_generations = Thrift.copyList(args.dictionary_generations, [ttypes.TDictionaryGeneration]);
      }
      if (args.table_generations !== undefined && args.table_generations !== null) {
        this.table_generations = Thrift.copyList(args.table_generations, [ttypes.TTableGeneration]);
      }
      if (args.parent_session_id !== undefined && args.parent_session_id !== null) {
        this.parent_session_id = args.parent_session_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.column_ranges = [];
          const _rtmp3106 = input.readListBegin();
          const _size105 = _rtmp3106.size || 0;
          for (let _i107 = 0; _i107 < _size105; ++_i107) {
            let elem108 = null;
            elem108 = new ttypes.TColumnRange();
            elem108.read(input);
            this.column_ranges.push(elem108);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.dictionary_generations = [];
          const _rtmp3110 = input.readListBegin();
          const _size109 = _rtmp3110.size || 0;
          for (let _i111 = 0; _i111 < _size109; ++_i111) {
            let elem112 = null;
            elem112 = new ttypes.TDictionaryGeneration();
            elem112.read(input);
            this.dictionary_generations.push(elem112);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.table_generations = [];
          const _rtmp3114 = input.readListBegin();
          const _size113 = _rtmp3114.size || 0;
          for (let _i115 = 0; _i115 < _size113; ++_i115) {
            let elem116 = null;
            elem116 = new ttypes.TTableGeneration();
            elem116.read(input);
            this.table_generations.push(elem116);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.parent_session_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TPendingQuery');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.I64, 1);
      output.writeI64(this.id);
      output.writeFieldEnd();
    }
    if (this.column_ranges !== null && this.column_ranges !== undefined) {
      output.writeFieldBegin('column_ranges', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.column_ranges.length);
      for (let iter117 in this.column_ranges) {
        if (this.column_ranges.hasOwnProperty(iter117)) {
          iter117 = this.column_ranges[iter117];
          iter117.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.dictionary_generations !== null && this.dictionary_generations !== undefined) {
      output.writeFieldBegin('dictionary_generations', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.dictionary_generations.length);
      for (let iter118 in this.dictionary_generations) {
        if (this.dictionary_generations.hasOwnProperty(iter118)) {
          iter118 = this.dictionary_generations[iter118];
          iter118.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.table_generations !== null && this.table_generations !== undefined) {
      output.writeFieldBegin('table_generations', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.table_generations.length);
      for (let iter119 in this.table_generations) {
        if (this.table_generations.hasOwnProperty(iter119)) {
          iter119 = this.table_generations[iter119];
          iter119.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.parent_session_id !== null && this.parent_session_id !== undefined) {
      output.writeFieldBegin('parent_session_id', Thrift.Type.STRING, 5);
      output.writeString(this.parent_session_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TVarLen = module.exports.TVarLen = class {
  constructor(args) {
    this.payload = null;
    this.is_null = null;
    if (args) {
      if (args.payload !== undefined && args.payload !== null) {
        this.payload = args.payload;
      }
      if (args.is_null !== undefined && args.is_null !== null) {
        this.is_null = args.is_null;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.payload = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.is_null = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TVarLen');
    if (this.payload !== null && this.payload !== undefined) {
      output.writeFieldBegin('payload', Thrift.Type.STRING, 1);
      output.writeBinary(this.payload);
      output.writeFieldEnd();
    }
    if (this.is_null !== null && this.is_null !== undefined) {
      output.writeFieldBegin('is_null', Thrift.Type.BOOL, 2);
      output.writeBool(this.is_null);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDataBlockPtr = module.exports.TDataBlockPtr = class {
  constructor(args) {
    this.fixed_len_data = null;
    this.var_len_data = null;
    if (args) {
      if (args.fixed_len_data !== undefined && args.fixed_len_data !== null) {
        this.fixed_len_data = args.fixed_len_data;
      }
      if (args.var_len_data !== undefined && args.var_len_data !== null) {
        this.var_len_data = Thrift.copyList(args.var_len_data, [ttypes.TVarLen]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.fixed_len_data = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.var_len_data = [];
          const _rtmp3121 = input.readListBegin();
          const _size120 = _rtmp3121.size || 0;
          for (let _i122 = 0; _i122 < _size120; ++_i122) {
            let elem123 = null;
            elem123 = new ttypes.TVarLen();
            elem123.read(input);
            this.var_len_data.push(elem123);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDataBlockPtr');
    if (this.fixed_len_data !== null && this.fixed_len_data !== undefined) {
      output.writeFieldBegin('fixed_len_data', Thrift.Type.STRING, 1);
      output.writeBinary(this.fixed_len_data);
      output.writeFieldEnd();
    }
    if (this.var_len_data !== null && this.var_len_data !== undefined) {
      output.writeFieldBegin('var_len_data', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.var_len_data.length);
      for (let iter124 in this.var_len_data) {
        if (this.var_len_data.hasOwnProperty(iter124)) {
          iter124 = this.var_len_data[iter124];
          iter124.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TInsertData = module.exports.TInsertData = class {
  constructor(args) {
    this.db_id = null;
    this.table_id = null;
    this.column_ids = null;
    this.data = null;
    this.num_rows = null;
    this.is_default = null;
    if (args) {
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.column_ids !== undefined && args.column_ids !== null) {
        this.column_ids = Thrift.copyList(args.column_ids, [null]);
      }
      if (args.data !== undefined && args.data !== null) {
        this.data = Thrift.copyList(args.data, [ttypes.TDataBlockPtr]);
      }
      if (args.num_rows !== undefined && args.num_rows !== null) {
        this.num_rows = args.num_rows;
      }
      if (args.is_default !== undefined && args.is_default !== null) {
        this.is_default = Thrift.copyList(args.is_default, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.column_ids = [];
          const _rtmp3126 = input.readListBegin();
          const _size125 = _rtmp3126.size || 0;
          for (let _i127 = 0; _i127 < _size125; ++_i127) {
            let elem128 = null;
            elem128 = input.readI32();
            this.column_ids.push(elem128);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.data = [];
          const _rtmp3130 = input.readListBegin();
          const _size129 = _rtmp3130.size || 0;
          for (let _i131 = 0; _i131 < _size129; ++_i131) {
            let elem132 = null;
            elem132 = new ttypes.TDataBlockPtr();
            elem132.read(input);
            this.data.push(elem132);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.num_rows = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.is_default = [];
          const _rtmp3134 = input.readListBegin();
          const _size133 = _rtmp3134.size || 0;
          for (let _i135 = 0; _i135 < _size133; ++_i135) {
            let elem136 = null;
            elem136 = input.readBool();
            this.is_default.push(elem136);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TInsertData');
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 1);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 2);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.column_ids !== null && this.column_ids !== undefined) {
      output.writeFieldBegin('column_ids', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.I32, this.column_ids.length);
      for (let iter137 in this.column_ids) {
        if (this.column_ids.hasOwnProperty(iter137)) {
          iter137 = this.column_ids[iter137];
          output.writeI32(iter137);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.data !== null && this.data !== undefined) {
      output.writeFieldBegin('data', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.data.length);
      for (let iter138 in this.data) {
        if (this.data.hasOwnProperty(iter138)) {
          iter138 = this.data[iter138];
          iter138.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
      output.writeFieldBegin('num_rows', Thrift.Type.I64, 5);
      output.writeI64(this.num_rows);
      output.writeFieldEnd();
    }
    if (this.is_default !== null && this.is_default !== undefined) {
      output.writeFieldBegin('is_default', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.BOOL, this.is_default.length);
      for (let iter139 in this.is_default) {
        if (this.is_default.hasOwnProperty(iter139)) {
          iter139 = this.is_default[iter139];
          output.writeBool(iter139);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TChunkData = module.exports.TChunkData = class {
  constructor(args) {
    this.data_buffer = null;
    this.index_buffer = null;
    if (args) {
      if (args.data_buffer !== undefined && args.data_buffer !== null) {
        this.data_buffer = args.data_buffer;
      }
      if (args.index_buffer !== undefined && args.index_buffer !== null) {
        this.index_buffer = args.index_buffer;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.data_buffer = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.index_buffer = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TChunkData');
    if (this.data_buffer !== null && this.data_buffer !== undefined) {
      output.writeFieldBegin('data_buffer', Thrift.Type.STRING, 1);
      output.writeBinary(this.data_buffer);
      output.writeFieldEnd();
    }
    if (this.index_buffer !== null && this.index_buffer !== undefined) {
      output.writeFieldBegin('index_buffer', Thrift.Type.STRING, 2);
      output.writeBinary(this.index_buffer);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TInsertChunks = module.exports.TInsertChunks = class {
  constructor(args) {
    this.db_id = null;
    this.table_id = null;
    this.data = null;
    this.valid_indices = null;
    this.num_rows = null;
    if (args) {
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.data !== undefined && args.data !== null) {
        this.data = Thrift.copyList(args.data, [ttypes.TChunkData]);
      }
      if (args.valid_indices !== undefined && args.valid_indices !== null) {
        this.valid_indices = Thrift.copyList(args.valid_indices, [null]);
      }
      if (args.num_rows !== undefined && args.num_rows !== null) {
        this.num_rows = args.num_rows;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.data = [];
          const _rtmp3141 = input.readListBegin();
          const _size140 = _rtmp3141.size || 0;
          for (let _i142 = 0; _i142 < _size140; ++_i142) {
            let elem143 = null;
            elem143 = new ttypes.TChunkData();
            elem143.read(input);
            this.data.push(elem143);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.valid_indices = [];
          const _rtmp3145 = input.readListBegin();
          const _size144 = _rtmp3145.size || 0;
          for (let _i146 = 0; _i146 < _size144; ++_i146) {
            let elem147 = null;
            elem147 = input.readI64();
            this.valid_indices.push(elem147);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.num_rows = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TInsertChunks');
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 1);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 2);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.data !== null && this.data !== undefined) {
      output.writeFieldBegin('data', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.data.length);
      for (let iter148 in this.data) {
        if (this.data.hasOwnProperty(iter148)) {
          iter148 = this.data[iter148];
          iter148.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.valid_indices !== null && this.valid_indices !== undefined) {
      output.writeFieldBegin('valid_indices', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.I64, this.valid_indices.length);
      for (let iter149 in this.valid_indices) {
        if (this.valid_indices.hasOwnProperty(iter149)) {
          iter149 = this.valid_indices[iter149];
          output.writeI64(iter149);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
      output.writeFieldBegin('num_rows', Thrift.Type.I64, 5);
      output.writeI64(this.num_rows);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TPendingRenderQuery = module.exports.TPendingRenderQuery = class {
  constructor(args) {
    this.id = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TPendingRenderQuery');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.I64, 1);
      output.writeI64(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRenderParseResult = module.exports.TRenderParseResult = class {
  constructor(args) {
    this.merge_type = null;
    this.node_id = null;
    this.execution_time_ms = null;
    this.render_time_ms = null;
    this.total_time_ms = null;
    if (args) {
      if (args.merge_type !== undefined && args.merge_type !== null) {
        this.merge_type = args.merge_type;
      }
      if (args.node_id !== undefined && args.node_id !== null) {
        this.node_id = args.node_id;
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.render_time_ms !== undefined && args.render_time_ms !== null) {
        this.render_time_ms = args.render_time_ms;
      }
      if (args.total_time_ms !== undefined && args.total_time_ms !== null) {
        this.total_time_ms = args.total_time_ms;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.merge_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.node_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.render_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.total_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRenderParseResult');
    if (this.merge_type !== null && this.merge_type !== undefined) {
      output.writeFieldBegin('merge_type', Thrift.Type.I32, 1);
      output.writeI32(this.merge_type);
      output.writeFieldEnd();
    }
    if (this.node_id !== null && this.node_id !== undefined) {
      output.writeFieldBegin('node_id', Thrift.Type.I32, 2);
      output.writeI32(this.node_id);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 3);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.render_time_ms !== null && this.render_time_ms !== undefined) {
      output.writeFieldBegin('render_time_ms', Thrift.Type.I64, 4);
      output.writeI64(this.render_time_ms);
      output.writeFieldEnd();
    }
    if (this.total_time_ms !== null && this.total_time_ms !== undefined) {
      output.writeFieldBegin('total_time_ms', Thrift.Type.I64, 5);
      output.writeI64(this.total_time_ms);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRawRenderPassDataResult = module.exports.TRawRenderPassDataResult = class {
  constructor(args) {
    this.num_pixel_channels = null;
    this.num_pixel_samples = null;
    this.pixels = null;
    this.row_ids_A = null;
    this.row_ids_B = null;
    this.table_ids = null;
    this.accum_data = null;
    this.accum_depth = null;
    if (args) {
      if (args.num_pixel_channels !== undefined && args.num_pixel_channels !== null) {
        this.num_pixel_channels = args.num_pixel_channels;
      }
      if (args.num_pixel_samples !== undefined && args.num_pixel_samples !== null) {
        this.num_pixel_samples = args.num_pixel_samples;
      }
      if (args.pixels !== undefined && args.pixels !== null) {
        this.pixels = args.pixels;
      }
      if (args.row_ids_A !== undefined && args.row_ids_A !== null) {
        this.row_ids_A = args.row_ids_A;
      }
      if (args.row_ids_B !== undefined && args.row_ids_B !== null) {
        this.row_ids_B = args.row_ids_B;
      }
      if (args.table_ids !== undefined && args.table_ids !== null) {
        this.table_ids = args.table_ids;
      }
      if (args.accum_data !== undefined && args.accum_data !== null) {
        this.accum_data = args.accum_data;
      }
      if (args.accum_depth !== undefined && args.accum_depth !== null) {
        this.accum_depth = args.accum_depth;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.num_pixel_channels = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.num_pixel_samples = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pixels = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.row_ids_A = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.row_ids_B = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.table_ids = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.accum_data = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.accum_depth = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRawRenderPassDataResult');
    if (this.num_pixel_channels !== null && this.num_pixel_channels !== undefined) {
      output.writeFieldBegin('num_pixel_channels', Thrift.Type.I32, 1);
      output.writeI32(this.num_pixel_channels);
      output.writeFieldEnd();
    }
    if (this.num_pixel_samples !== null && this.num_pixel_samples !== undefined) {
      output.writeFieldBegin('num_pixel_samples', Thrift.Type.I32, 2);
      output.writeI32(this.num_pixel_samples);
      output.writeFieldEnd();
    }
    if (this.pixels !== null && this.pixels !== undefined) {
      output.writeFieldBegin('pixels', Thrift.Type.STRING, 3);
      output.writeBinary(this.pixels);
      output.writeFieldEnd();
    }
    if (this.row_ids_A !== null && this.row_ids_A !== undefined) {
      output.writeFieldBegin('row_ids_A', Thrift.Type.STRING, 4);
      output.writeBinary(this.row_ids_A);
      output.writeFieldEnd();
    }
    if (this.row_ids_B !== null && this.row_ids_B !== undefined) {
      output.writeFieldBegin('row_ids_B', Thrift.Type.STRING, 5);
      output.writeBinary(this.row_ids_B);
      output.writeFieldEnd();
    }
    if (this.table_ids !== null && this.table_ids !== undefined) {
      output.writeFieldBegin('table_ids', Thrift.Type.STRING, 6);
      output.writeBinary(this.table_ids);
      output.writeFieldEnd();
    }
    if (this.accum_data !== null && this.accum_data !== undefined) {
      output.writeFieldBegin('accum_data', Thrift.Type.STRING, 7);
      output.writeBinary(this.accum_data);
      output.writeFieldEnd();
    }
    if (this.accum_depth !== null && this.accum_depth !== undefined) {
      output.writeFieldBegin('accum_depth', Thrift.Type.I32, 8);
      output.writeI32(this.accum_depth);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRawPixelData = module.exports.TRawPixelData = class {
  constructor(args) {
    this.width = null;
    this.height = null;
    this.render_pass_map = null;
    if (args) {
      if (args.width !== undefined && args.width !== null) {
        this.width = args.width;
      }
      if (args.height !== undefined && args.height !== null) {
        this.height = args.height;
      }
      if (args.render_pass_map !== undefined && args.render_pass_map !== null) {
        this.render_pass_map = Thrift.copyMap(args.render_pass_map, [ttypes.TRawRenderPassDataResult]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.width = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.height = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.render_pass_map = {};
          const _rtmp3151 = input.readMapBegin();
          const _size150 = _rtmp3151.size || 0;
          for (let _i152 = 0; _i152 < _size150; ++_i152) {
            let key153 = null;
            let val154 = null;
            key153 = input.readI32();
            val154 = new ttypes.TRawRenderPassDataResult();
            val154.read(input);
            this.render_pass_map[key153] = val154;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRawPixelData');
    if (this.width !== null && this.width !== undefined) {
      output.writeFieldBegin('width', Thrift.Type.I32, 1);
      output.writeI32(this.width);
      output.writeFieldEnd();
    }
    if (this.height !== null && this.height !== undefined) {
      output.writeFieldBegin('height', Thrift.Type.I32, 2);
      output.writeI32(this.height);
      output.writeFieldEnd();
    }
    if (this.render_pass_map !== null && this.render_pass_map !== undefined) {
      output.writeFieldBegin('render_pass_map', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRUCT, Thrift.objectLength(this.render_pass_map));
      for (let kiter155 in this.render_pass_map) {
        if (this.render_pass_map.hasOwnProperty(kiter155)) {
          let viter156 = this.render_pass_map[kiter155];
          output.writeI32(kiter155);
          viter156.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRenderDatum = module.exports.TRenderDatum = class {
  constructor(args) {
    this.type = null;
    this.cnt = null;
    this.value = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.cnt !== undefined && args.cnt !== null) {
        this.cnt = args.cnt;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.cnt = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRenderDatum');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.cnt !== null && this.cnt !== undefined) {
      output.writeFieldBegin('cnt', Thrift.Type.I32, 2);
      output.writeI32(this.cnt);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeBinary(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRenderStepResult = module.exports.TRenderStepResult = class {
  constructor(args) {
    this.merge_data = null;
    this.raw_pixel_data = null;
    this.execution_time_ms = null;
    this.render_time_ms = null;
    this.total_time_ms = null;
    if (args) {
      if (args.merge_data !== undefined && args.merge_data !== null) {
        this.merge_data = Thrift.copyMap(args.merge_data, [Thrift.copyMap, Thrift.copyMap, Thrift.copyMap, Thrift.copyList, ttypes.TRenderDatum]);
      }
      if (args.raw_pixel_data !== undefined && args.raw_pixel_data !== null) {
        this.raw_pixel_data = new ttypes.TRawPixelData(args.raw_pixel_data);
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.render_time_ms !== undefined && args.render_time_ms !== null) {
        this.render_time_ms = args.render_time_ms;
      }
      if (args.total_time_ms !== undefined && args.total_time_ms !== null) {
        this.total_time_ms = args.total_time_ms;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.MAP) {
          this.merge_data = {};
          const _rtmp3158 = input.readMapBegin();
          const _size157 = _rtmp3158.size || 0;
          for (let _i159 = 0; _i159 < _size157; ++_i159) {
            let key160 = null;
            let val161 = null;
            key160 = input.readString();
            val161 = {};
            const _rtmp3163 = input.readMapBegin();
            const _size162 = _rtmp3163.size || 0;
            for (let _i164 = 0; _i164 < _size162; ++_i164) {
              let key165 = null;
              let val166 = null;
              key165 = input.readString();
              val166 = {};
              const _rtmp3168 = input.readMapBegin();
              const _size167 = _rtmp3168.size || 0;
              for (let _i169 = 0; _i169 < _size167; ++_i169) {
                let key170 = null;
                let val171 = null;
                key170 = input.readString();
                val171 = {};
                const _rtmp3173 = input.readMapBegin();
                const _size172 = _rtmp3173.size || 0;
                for (let _i174 = 0; _i174 < _size172; ++_i174) {
                  let key175 = null;
                  let val176 = null;
                  key175 = input.readString();
                  val176 = [];
                  const _rtmp3178 = input.readListBegin();
                  const _size177 = _rtmp3178.size || 0;
                  for (let _i179 = 0; _i179 < _size177; ++_i179) {
                    let elem180 = null;
                    elem180 = new ttypes.TRenderDatum();
                    elem180.read(input);
                    val176.push(elem180);
                  }
                  input.readListEnd();
                  val171[key175] = val176;
                }
                input.readMapEnd();
                val166[key170] = val171;
              }
              input.readMapEnd();
              val161[key165] = val166;
            }
            input.readMapEnd();
            this.merge_data[key160] = val161;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.raw_pixel_data = new ttypes.TRawPixelData();
          this.raw_pixel_data.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.render_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.total_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRenderStepResult');
    if (this.merge_data !== null && this.merge_data !== undefined) {
      output.writeFieldBegin('merge_data', Thrift.Type.MAP, 1);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.merge_data));
      for (let kiter181 in this.merge_data) {
        if (this.merge_data.hasOwnProperty(kiter181)) {
          let viter182 = this.merge_data[kiter181];
          output.writeString(kiter181);
          output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(viter182));
          for (let kiter183 in viter182) {
            if (viter182.hasOwnProperty(kiter183)) {
              let viter184 = viter182[kiter183];
              output.writeString(kiter183);
              output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(viter184));
              for (let kiter185 in viter184) {
                if (viter184.hasOwnProperty(kiter185)) {
                  let viter186 = viter184[kiter185];
                  output.writeString(kiter185);
                  output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter186));
                  for (let kiter187 in viter186) {
                    if (viter186.hasOwnProperty(kiter187)) {
                      let viter188 = viter186[kiter187];
                      output.writeString(kiter187);
                      output.writeListBegin(Thrift.Type.STRUCT, viter188.length);
                      for (let iter189 in viter188) {
                        if (viter188.hasOwnProperty(iter189)) {
                          iter189 = viter188[iter189];
                          iter189.write(output);
                        }
                      }
                      output.writeListEnd();
                    }
                  }
                  output.writeMapEnd();
                }
              }
              output.writeMapEnd();
            }
          }
          output.writeMapEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.raw_pixel_data !== null && this.raw_pixel_data !== undefined) {
      output.writeFieldBegin('raw_pixel_data', Thrift.Type.STRUCT, 2);
      this.raw_pixel_data.write(output);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 3);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.render_time_ms !== null && this.render_time_ms !== undefined) {
      output.writeFieldBegin('render_time_ms', Thrift.Type.I64, 4);
      output.writeI64(this.render_time_ms);
      output.writeFieldEnd();
    }
    if (this.total_time_ms !== null && this.total_time_ms !== undefined) {
      output.writeFieldBegin('total_time_ms', Thrift.Type.I64, 5);
      output.writeI64(this.total_time_ms);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDatabasePermissions = module.exports.TDatabasePermissions = class {
  constructor(args) {
    this.create_ = null;
    this.delete_ = null;
    this.view_sql_editor_ = null;
    this.access_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.delete_ !== undefined && args.delete_ !== null) {
        this.delete_ = args.delete_;
      }
      if (args.view_sql_editor_ !== undefined && args.view_sql_editor_ !== null) {
        this.view_sql_editor_ = args.view_sql_editor_;
      }
      if (args.access_ !== undefined && args.access_ !== null) {
        this.access_ = args.access_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.delete_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.view_sql_editor_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.access_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDatabasePermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.delete_ !== null && this.delete_ !== undefined) {
      output.writeFieldBegin('delete_', Thrift.Type.BOOL, 2);
      output.writeBool(this.delete_);
      output.writeFieldEnd();
    }
    if (this.view_sql_editor_ !== null && this.view_sql_editor_ !== undefined) {
      output.writeFieldBegin('view_sql_editor_', Thrift.Type.BOOL, 3);
      output.writeBool(this.view_sql_editor_);
      output.writeFieldEnd();
    }
    if (this.access_ !== null && this.access_ !== undefined) {
      output.writeFieldBegin('access_', Thrift.Type.BOOL, 4);
      output.writeBool(this.access_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTablePermissions = module.exports.TTablePermissions = class {
  constructor(args) {
    this.create_ = null;
    this.drop_ = null;
    this.select_ = null;
    this.insert_ = null;
    this.update_ = null;
    this.delete_ = null;
    this.truncate_ = null;
    this.alter_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.drop_ !== undefined && args.drop_ !== null) {
        this.drop_ = args.drop_;
      }
      if (args.select_ !== undefined && args.select_ !== null) {
        this.select_ = args.select_;
      }
      if (args.insert_ !== undefined && args.insert_ !== null) {
        this.insert_ = args.insert_;
      }
      if (args.update_ !== undefined && args.update_ !== null) {
        this.update_ = args.update_;
      }
      if (args.delete_ !== undefined && args.delete_ !== null) {
        this.delete_ = args.delete_;
      }
      if (args.truncate_ !== undefined && args.truncate_ !== null) {
        this.truncate_ = args.truncate_;
      }
      if (args.alter_ !== undefined && args.alter_ !== null) {
        this.alter_ = args.alter_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.drop_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.select_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.insert_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.update_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.delete_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.truncate_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.alter_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTablePermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.drop_ !== null && this.drop_ !== undefined) {
      output.writeFieldBegin('drop_', Thrift.Type.BOOL, 2);
      output.writeBool(this.drop_);
      output.writeFieldEnd();
    }
    if (this.select_ !== null && this.select_ !== undefined) {
      output.writeFieldBegin('select_', Thrift.Type.BOOL, 3);
      output.writeBool(this.select_);
      output.writeFieldEnd();
    }
    if (this.insert_ !== null && this.insert_ !== undefined) {
      output.writeFieldBegin('insert_', Thrift.Type.BOOL, 4);
      output.writeBool(this.insert_);
      output.writeFieldEnd();
    }
    if (this.update_ !== null && this.update_ !== undefined) {
      output.writeFieldBegin('update_', Thrift.Type.BOOL, 5);
      output.writeBool(this.update_);
      output.writeFieldEnd();
    }
    if (this.delete_ !== null && this.delete_ !== undefined) {
      output.writeFieldBegin('delete_', Thrift.Type.BOOL, 6);
      output.writeBool(this.delete_);
      output.writeFieldEnd();
    }
    if (this.truncate_ !== null && this.truncate_ !== undefined) {
      output.writeFieldBegin('truncate_', Thrift.Type.BOOL, 7);
      output.writeBool(this.truncate_);
      output.writeFieldEnd();
    }
    if (this.alter_ !== null && this.alter_ !== undefined) {
      output.writeFieldBegin('alter_', Thrift.Type.BOOL, 8);
      output.writeBool(this.alter_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDashboardPermissions = module.exports.TDashboardPermissions = class {
  constructor(args) {
    this.create_ = null;
    this.delete_ = null;
    this.view_ = null;
    this.edit_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.delete_ !== undefined && args.delete_ !== null) {
        this.delete_ = args.delete_;
      }
      if (args.view_ !== undefined && args.view_ !== null) {
        this.view_ = args.view_;
      }
      if (args.edit_ !== undefined && args.edit_ !== null) {
        this.edit_ = args.edit_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.delete_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.view_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.edit_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDashboardPermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.delete_ !== null && this.delete_ !== undefined) {
      output.writeFieldBegin('delete_', Thrift.Type.BOOL, 2);
      output.writeBool(this.delete_);
      output.writeFieldEnd();
    }
    if (this.view_ !== null && this.view_ !== undefined) {
      output.writeFieldBegin('view_', Thrift.Type.BOOL, 3);
      output.writeBool(this.view_);
      output.writeFieldEnd();
    }
    if (this.edit_ !== null && this.edit_ !== undefined) {
      output.writeFieldBegin('edit_', Thrift.Type.BOOL, 4);
      output.writeBool(this.edit_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TViewPermissions = module.exports.TViewPermissions = class {
  constructor(args) {
    this.create_ = null;
    this.drop_ = null;
    this.select_ = null;
    this.insert_ = null;
    this.update_ = null;
    this.delete_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.drop_ !== undefined && args.drop_ !== null) {
        this.drop_ = args.drop_;
      }
      if (args.select_ !== undefined && args.select_ !== null) {
        this.select_ = args.select_;
      }
      if (args.insert_ !== undefined && args.insert_ !== null) {
        this.insert_ = args.insert_;
      }
      if (args.update_ !== undefined && args.update_ !== null) {
        this.update_ = args.update_;
      }
      if (args.delete_ !== undefined && args.delete_ !== null) {
        this.delete_ = args.delete_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.drop_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.select_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.insert_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.update_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.delete_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TViewPermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.drop_ !== null && this.drop_ !== undefined) {
      output.writeFieldBegin('drop_', Thrift.Type.BOOL, 2);
      output.writeBool(this.drop_);
      output.writeFieldEnd();
    }
    if (this.select_ !== null && this.select_ !== undefined) {
      output.writeFieldBegin('select_', Thrift.Type.BOOL, 3);
      output.writeBool(this.select_);
      output.writeFieldEnd();
    }
    if (this.insert_ !== null && this.insert_ !== undefined) {
      output.writeFieldBegin('insert_', Thrift.Type.BOOL, 4);
      output.writeBool(this.insert_);
      output.writeFieldEnd();
    }
    if (this.update_ !== null && this.update_ !== undefined) {
      output.writeFieldBegin('update_', Thrift.Type.BOOL, 5);
      output.writeBool(this.update_);
      output.writeFieldEnd();
    }
    if (this.delete_ !== null && this.delete_ !== undefined) {
      output.writeFieldBegin('delete_', Thrift.Type.BOOL, 6);
      output.writeBool(this.delete_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TServerPermissions = module.exports.TServerPermissions = class {
  constructor(args) {
    this.create_ = null;
    this.drop_ = null;
    this.alter_ = null;
    this.usage_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.drop_ !== undefined && args.drop_ !== null) {
        this.drop_ = args.drop_;
      }
      if (args.alter_ !== undefined && args.alter_ !== null) {
        this.alter_ = args.alter_;
      }
      if (args.usage_ !== undefined && args.usage_ !== null) {
        this.usage_ = args.usage_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.drop_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.alter_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.usage_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TServerPermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.drop_ !== null && this.drop_ !== undefined) {
      output.writeFieldBegin('drop_', Thrift.Type.BOOL, 2);
      output.writeBool(this.drop_);
      output.writeFieldEnd();
    }
    if (this.alter_ !== null && this.alter_ !== undefined) {
      output.writeFieldBegin('alter_', Thrift.Type.BOOL, 3);
      output.writeBool(this.alter_);
      output.writeFieldEnd();
    }
    if (this.usage_ !== null && this.usage_ !== undefined) {
      output.writeFieldBegin('usage_', Thrift.Type.BOOL, 4);
      output.writeBool(this.usage_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDBObjectPermissions = module.exports.TDBObjectPermissions = class {
  constructor(args) {
    this.database_permissions_ = null;
    this.table_permissions_ = null;
    this.dashboard_permissions_ = null;
    this.view_permissions_ = null;
    this.server_permissions_ = null;
    if (args) {
      if (args.database_permissions_ !== undefined && args.database_permissions_ !== null) {
        this.database_permissions_ = new ttypes.TDatabasePermissions(args.database_permissions_);
      }
      if (args.table_permissions_ !== undefined && args.table_permissions_ !== null) {
        this.table_permissions_ = new ttypes.TTablePermissions(args.table_permissions_);
      }
      if (args.dashboard_permissions_ !== undefined && args.dashboard_permissions_ !== null) {
        this.dashboard_permissions_ = new ttypes.TDashboardPermissions(args.dashboard_permissions_);
      }
      if (args.view_permissions_ !== undefined && args.view_permissions_ !== null) {
        this.view_permissions_ = new ttypes.TViewPermissions(args.view_permissions_);
      }
      if (args.server_permissions_ !== undefined && args.server_permissions_ !== null) {
        this.server_permissions_ = new ttypes.TServerPermissions(args.server_permissions_);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.database_permissions_ = new ttypes.TDatabasePermissions();
          this.database_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.table_permissions_ = new ttypes.TTablePermissions();
          this.table_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.dashboard_permissions_ = new ttypes.TDashboardPermissions();
          this.dashboard_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.view_permissions_ = new ttypes.TViewPermissions();
          this.view_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.server_permissions_ = new ttypes.TServerPermissions();
          this.server_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDBObjectPermissions');
    if (this.database_permissions_ !== null && this.database_permissions_ !== undefined) {
      output.writeFieldBegin('database_permissions_', Thrift.Type.STRUCT, 1);
      this.database_permissions_.write(output);
      output.writeFieldEnd();
    }
    if (this.table_permissions_ !== null && this.table_permissions_ !== undefined) {
      output.writeFieldBegin('table_permissions_', Thrift.Type.STRUCT, 2);
      this.table_permissions_.write(output);
      output.writeFieldEnd();
    }
    if (this.dashboard_permissions_ !== null && this.dashboard_permissions_ !== undefined) {
      output.writeFieldBegin('dashboard_permissions_', Thrift.Type.STRUCT, 3);
      this.dashboard_permissions_.write(output);
      output.writeFieldEnd();
    }
    if (this.view_permissions_ !== null && this.view_permissions_ !== undefined) {
      output.writeFieldBegin('view_permissions_', Thrift.Type.STRUCT, 4);
      this.view_permissions_.write(output);
      output.writeFieldEnd();
    }
    if (this.server_permissions_ !== null && this.server_permissions_ !== undefined) {
      output.writeFieldBegin('server_permissions_', Thrift.Type.STRUCT, 5);
      this.server_permissions_.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDBObject = module.exports.TDBObject = class {
  constructor(args) {
    this.objectName = null;
    this.objectType = null;
    this.privs = null;
    this.grantee = null;
    this.privilegeObjectType = null;
    this.objectId = null;
    if (args) {
      if (args.objectName !== undefined && args.objectName !== null) {
        this.objectName = args.objectName;
      }
      if (args.objectType !== undefined && args.objectType !== null) {
        this.objectType = args.objectType;
      }
      if (args.privs !== undefined && args.privs !== null) {
        this.privs = Thrift.copyList(args.privs, [null]);
      }
      if (args.grantee !== undefined && args.grantee !== null) {
        this.grantee = args.grantee;
      }
      if (args.privilegeObjectType !== undefined && args.privilegeObjectType !== null) {
        this.privilegeObjectType = args.privilegeObjectType;
      }
      if (args.objectId !== undefined && args.objectId !== null) {
        this.objectId = args.objectId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.objectName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.objectType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.privs = [];
          const _rtmp3191 = input.readListBegin();
          const _size190 = _rtmp3191.size || 0;
          for (let _i192 = 0; _i192 < _size190; ++_i192) {
            let elem193 = null;
            elem193 = input.readBool();
            this.privs.push(elem193);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.grantee = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.privilegeObjectType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.objectId = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDBObject');
    if (this.objectName !== null && this.objectName !== undefined) {
      output.writeFieldBegin('objectName', Thrift.Type.STRING, 1);
      output.writeString(this.objectName);
      output.writeFieldEnd();
    }
    if (this.objectType !== null && this.objectType !== undefined) {
      output.writeFieldBegin('objectType', Thrift.Type.I32, 2);
      output.writeI32(this.objectType);
      output.writeFieldEnd();
    }
    if (this.privs !== null && this.privs !== undefined) {
      output.writeFieldBegin('privs', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.BOOL, this.privs.length);
      for (let iter194 in this.privs) {
        if (this.privs.hasOwnProperty(iter194)) {
          iter194 = this.privs[iter194];
          output.writeBool(iter194);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.grantee !== null && this.grantee !== undefined) {
      output.writeFieldBegin('grantee', Thrift.Type.STRING, 4);
      output.writeString(this.grantee);
      output.writeFieldEnd();
    }
    if (this.privilegeObjectType !== null && this.privilegeObjectType !== undefined) {
      output.writeFieldBegin('privilegeObjectType', Thrift.Type.I32, 5);
      output.writeI32(this.privilegeObjectType);
      output.writeFieldEnd();
    }
    if (this.objectId !== null && this.objectId !== undefined) {
      output.writeFieldBegin('objectId', Thrift.Type.I32, 6);
      output.writeI32(this.objectId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDashboardGrantees = module.exports.TDashboardGrantees = class {
  constructor(args) {
    this.name = null;
    this.is_user = null;
    this.permissions = null;
    if (args) {
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.is_user !== undefined && args.is_user !== null) {
        this.is_user = args.is_user;
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.is_user = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDashboardGrantees');
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 1);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.is_user !== null && this.is_user !== undefined) {
      output.writeFieldBegin('is_user', Thrift.Type.BOOL, 2);
      output.writeBool(this.is_user);
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 3);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDashboard = module.exports.TDashboard = class {
  constructor(args) {
    this.dashboard_name = null;
    this.dashboard_state = null;
    this.image_hash = null;
    this.update_time = null;
    this.dashboard_metadata = null;
    this.dashboard_id = null;
    this.dashboard_owner = null;
    this.is_dash_shared = null;
    this.dashboard_permissions = null;
    if (args) {
      if (args.dashboard_name !== undefined && args.dashboard_name !== null) {
        this.dashboard_name = args.dashboard_name;
      }
      if (args.dashboard_state !== undefined && args.dashboard_state !== null) {
        this.dashboard_state = args.dashboard_state;
      }
      if (args.image_hash !== undefined && args.image_hash !== null) {
        this.image_hash = args.image_hash;
      }
      if (args.update_time !== undefined && args.update_time !== null) {
        this.update_time = args.update_time;
      }
      if (args.dashboard_metadata !== undefined && args.dashboard_metadata !== null) {
        this.dashboard_metadata = args.dashboard_metadata;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
      if (args.dashboard_owner !== undefined && args.dashboard_owner !== null) {
        this.dashboard_owner = args.dashboard_owner;
      }
      if (args.is_dash_shared !== undefined && args.is_dash_shared !== null) {
        this.is_dash_shared = args.is_dash_shared;
      }
      if (args.dashboard_permissions !== undefined && args.dashboard_permissions !== null) {
        this.dashboard_permissions = new ttypes.TDashboardPermissions(args.dashboard_permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.image_hash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.update_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_owner = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.is_dash_shared = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.dashboard_permissions = new ttypes.TDashboardPermissions();
          this.dashboard_permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDashboard');
    if (this.dashboard_name !== null && this.dashboard_name !== undefined) {
      output.writeFieldBegin('dashboard_name', Thrift.Type.STRING, 1);
      output.writeString(this.dashboard_name);
      output.writeFieldEnd();
    }
    if (this.dashboard_state !== null && this.dashboard_state !== undefined) {
      output.writeFieldBegin('dashboard_state', Thrift.Type.STRING, 2);
      output.writeString(this.dashboard_state);
      output.writeFieldEnd();
    }
    if (this.image_hash !== null && this.image_hash !== undefined) {
      output.writeFieldBegin('image_hash', Thrift.Type.STRING, 3);
      output.writeString(this.image_hash);
      output.writeFieldEnd();
    }
    if (this.update_time !== null && this.update_time !== undefined) {
      output.writeFieldBegin('update_time', Thrift.Type.STRING, 4);
      output.writeString(this.update_time);
      output.writeFieldEnd();
    }
    if (this.dashboard_metadata !== null && this.dashboard_metadata !== undefined) {
      output.writeFieldBegin('dashboard_metadata', Thrift.Type.STRING, 5);
      output.writeString(this.dashboard_metadata);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 6);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    if (this.dashboard_owner !== null && this.dashboard_owner !== undefined) {
      output.writeFieldBegin('dashboard_owner', Thrift.Type.STRING, 7);
      output.writeString(this.dashboard_owner);
      output.writeFieldEnd();
    }
    if (this.is_dash_shared !== null && this.is_dash_shared !== undefined) {
      output.writeFieldBegin('is_dash_shared', Thrift.Type.BOOL, 8);
      output.writeBool(this.is_dash_shared);
      output.writeFieldEnd();
    }
    if (this.dashboard_permissions !== null && this.dashboard_permissions !== undefined) {
      output.writeFieldBegin('dashboard_permissions', Thrift.Type.STRUCT, 9);
      this.dashboard_permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TLicenseInfo = module.exports.TLicenseInfo = class {
  constructor(args) {
    this.claims = null;
    if (args) {
      if (args.claims !== undefined && args.claims !== null) {
        this.claims = Thrift.copyList(args.claims, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.claims = [];
          const _rtmp3196 = input.readListBegin();
          const _size195 = _rtmp3196.size || 0;
          for (let _i197 = 0; _i197 < _size195; ++_i197) {
            let elem198 = null;
            elem198 = input.readString();
            this.claims.push(elem198);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TLicenseInfo');
    if (this.claims !== null && this.claims !== undefined) {
      output.writeFieldBegin('claims', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRING, this.claims.length);
      for (let iter199 in this.claims) {
        if (this.claims.hasOwnProperty(iter199)) {
          iter199 = this.claims[iter199];
          output.writeString(iter199);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TSessionInfo = module.exports.TSessionInfo = class {
  constructor(args) {
    this.user = null;
    this.database = null;
    this.start_time = null;
    this.is_super = null;
    if (args) {
      if (args.user !== undefined && args.user !== null) {
        this.user = args.user;
      }
      if (args.database !== undefined && args.database !== null) {
        this.database = args.database;
      }
      if (args.start_time !== undefined && args.start_time !== null) {
        this.start_time = args.start_time;
      }
      if (args.is_super !== undefined && args.is_super !== null) {
        this.is_super = args.is_super;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.user = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.database = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.start_time = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.is_super = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TSessionInfo');
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRING, 1);
      output.writeString(this.user);
      output.writeFieldEnd();
    }
    if (this.database !== null && this.database !== undefined) {
      output.writeFieldBegin('database', Thrift.Type.STRING, 2);
      output.writeString(this.database);
      output.writeFieldEnd();
    }
    if (this.start_time !== null && this.start_time !== undefined) {
      output.writeFieldBegin('start_time', Thrift.Type.I64, 3);
      output.writeI64(this.start_time);
      output.writeFieldEnd();
    }
    if (this.is_super !== null && this.is_super !== undefined) {
      output.writeFieldBegin('is_super', Thrift.Type.BOOL, 4);
      output.writeBool(this.is_super);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TGeoFileLayerInfo = module.exports.TGeoFileLayerInfo = class {
  constructor(args) {
    this.name = null;
    this.contents = null;
    if (args) {
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.contents !== undefined && args.contents !== null) {
        this.contents = args.contents;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.contents = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TGeoFileLayerInfo');
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 1);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.contents !== null && this.contents !== undefined) {
      output.writeFieldBegin('contents', Thrift.Type.I32, 2);
      output.writeI32(this.contents);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableEpochInfo = module.exports.TTableEpochInfo = class {
  constructor(args) {
    this.table_id = null;
    this.table_epoch = null;
    this.leaf_index = null;
    if (args) {
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.table_epoch !== undefined && args.table_epoch !== null) {
        this.table_epoch = args.table_epoch;
      }
      if (args.leaf_index !== undefined && args.leaf_index !== null) {
        this.leaf_index = args.leaf_index;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_epoch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.leaf_index = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableEpochInfo');
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 1);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.table_epoch !== null && this.table_epoch !== undefined) {
      output.writeFieldBegin('table_epoch', Thrift.Type.I32, 2);
      output.writeI32(this.table_epoch);
      output.writeFieldEnd();
    }
    if (this.leaf_index !== null && this.leaf_index !== undefined) {
      output.writeFieldBegin('leaf_index', Thrift.Type.I32, 3);
      output.writeI32(this.leaf_index);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCustomExpression = module.exports.TCustomExpression = class {
  constructor(args) {
    this.id = null;
    this.name = null;
    this.expression_json = null;
    this.data_source_type = null;
    this.data_source_id = null;
    this.is_deleted = null;
    this.data_source_name = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.expression_json !== undefined && args.expression_json !== null) {
        this.expression_json = args.expression_json;
      }
      if (args.data_source_type !== undefined && args.data_source_type !== null) {
        this.data_source_type = args.data_source_type;
      }
      if (args.data_source_id !== undefined && args.data_source_id !== null) {
        this.data_source_id = args.data_source_id;
      }
      if (args.is_deleted !== undefined && args.is_deleted !== null) {
        this.is_deleted = args.is_deleted;
      }
      if (args.data_source_name !== undefined && args.data_source_name !== null) {
        this.data_source_name = args.data_source_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.expression_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.data_source_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.data_source_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.is_deleted = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.data_source_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCustomExpression');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.I32, 1);
      output.writeI32(this.id);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 2);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.expression_json !== null && this.expression_json !== undefined) {
      output.writeFieldBegin('expression_json', Thrift.Type.STRING, 4);
      output.writeString(this.expression_json);
      output.writeFieldEnd();
    }
    if (this.data_source_type !== null && this.data_source_type !== undefined) {
      output.writeFieldBegin('data_source_type', Thrift.Type.I32, 5);
      output.writeI32(this.data_source_type);
      output.writeFieldEnd();
    }
    if (this.data_source_id !== null && this.data_source_id !== undefined) {
      output.writeFieldBegin('data_source_id', Thrift.Type.I32, 6);
      output.writeI32(this.data_source_id);
      output.writeFieldEnd();
    }
    if (this.is_deleted !== null && this.is_deleted !== undefined) {
      output.writeFieldBegin('is_deleted', Thrift.Type.BOOL, 7);
      output.writeBool(this.is_deleted);
      output.writeFieldEnd();
    }
    if (this.data_source_name !== null && this.data_source_name !== undefined) {
      output.writeFieldBegin('data_source_name', Thrift.Type.STRING, 8);
      output.writeString(this.data_source_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TQueryInfo = module.exports.TQueryInfo = class {
  constructor(args) {
    this.query_session_id = null;
    this.query_public_session_id = null;
    this.current_status = null;
    this.executor_id = null;
    this.submitted = null;
    this.query_str = null;
    this.login_name = null;
    this.client_address = null;
    this.db_name = null;
    this.exec_device_type = null;
    if (args) {
      if (args.query_session_id !== undefined && args.query_session_id !== null) {
        this.query_session_id = args.query_session_id;
      }
      if (args.query_public_session_id !== undefined && args.query_public_session_id !== null) {
        this.query_public_session_id = args.query_public_session_id;
      }
      if (args.current_status !== undefined && args.current_status !== null) {
        this.current_status = args.current_status;
      }
      if (args.executor_id !== undefined && args.executor_id !== null) {
        this.executor_id = args.executor_id;
      }
      if (args.submitted !== undefined && args.submitted !== null) {
        this.submitted = args.submitted;
      }
      if (args.query_str !== undefined && args.query_str !== null) {
        this.query_str = args.query_str;
      }
      if (args.login_name !== undefined && args.login_name !== null) {
        this.login_name = args.login_name;
      }
      if (args.client_address !== undefined && args.client_address !== null) {
        this.client_address = args.client_address;
      }
      if (args.db_name !== undefined && args.db_name !== null) {
        this.db_name = args.db_name;
      }
      if (args.exec_device_type !== undefined && args.exec_device_type !== null) {
        this.exec_device_type = args.exec_device_type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.query_session_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query_public_session_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.current_status = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.executor_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.submitted = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.query_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.login_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.client_address = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.db_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.exec_device_type = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TQueryInfo');
    if (this.query_session_id !== null && this.query_session_id !== undefined) {
      output.writeFieldBegin('query_session_id', Thrift.Type.STRING, 1);
      output.writeString(this.query_session_id);
      output.writeFieldEnd();
    }
    if (this.query_public_session_id !== null && this.query_public_session_id !== undefined) {
      output.writeFieldBegin('query_public_session_id', Thrift.Type.STRING, 2);
      output.writeString(this.query_public_session_id);
      output.writeFieldEnd();
    }
    if (this.current_status !== null && this.current_status !== undefined) {
      output.writeFieldBegin('current_status', Thrift.Type.STRING, 3);
      output.writeString(this.current_status);
      output.writeFieldEnd();
    }
    if (this.executor_id !== null && this.executor_id !== undefined) {
      output.writeFieldBegin('executor_id', Thrift.Type.I32, 4);
      output.writeI32(this.executor_id);
      output.writeFieldEnd();
    }
    if (this.submitted !== null && this.submitted !== undefined) {
      output.writeFieldBegin('submitted', Thrift.Type.STRING, 5);
      output.writeString(this.submitted);
      output.writeFieldEnd();
    }
    if (this.query_str !== null && this.query_str !== undefined) {
      output.writeFieldBegin('query_str', Thrift.Type.STRING, 6);
      output.writeString(this.query_str);
      output.writeFieldEnd();
    }
    if (this.login_name !== null && this.login_name !== undefined) {
      output.writeFieldBegin('login_name', Thrift.Type.STRING, 7);
      output.writeString(this.login_name);
      output.writeFieldEnd();
    }
    if (this.client_address !== null && this.client_address !== undefined) {
      output.writeFieldBegin('client_address', Thrift.Type.STRING, 8);
      output.writeString(this.client_address);
      output.writeFieldEnd();
    }
    if (this.db_name !== null && this.db_name !== undefined) {
      output.writeFieldBegin('db_name', Thrift.Type.STRING, 9);
      output.writeString(this.db_name);
      output.writeFieldEnd();
    }
    if (this.exec_device_type !== null && this.exec_device_type !== undefined) {
      output.writeFieldBegin('exec_device_type', Thrift.Type.STRING, 10);
      output.writeString(this.exec_device_type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TLeafInfo = module.exports.TLeafInfo = class {
  constructor(args) {
    this.leaf_id = null;
    this.num_leaves = null;
    if (args) {
      if (args.leaf_id !== undefined && args.leaf_id !== null) {
        this.leaf_id = args.leaf_id;
      }
      if (args.num_leaves !== undefined && args.num_leaves !== null) {
        this.num_leaves = args.num_leaves;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.leaf_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.num_leaves = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TLeafInfo');
    if (this.leaf_id !== null && this.leaf_id !== undefined) {
      output.writeFieldBegin('leaf_id', Thrift.Type.I32, 1);
      output.writeI32(this.leaf_id);
      output.writeFieldEnd();
    }
    if (this.num_leaves !== null && this.num_leaves !== undefined) {
      output.writeFieldBegin('num_leaves', Thrift.Type.I32, 2);
      output.writeI32(this.num_leaves);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 3962:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(9262);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);

const common_ttypes = __webpack_require__(2818);


const ttypes = module.exports = {};
ttypes.TResultSetLayout = {
  'GroupByPerfectHash' : 0,
  'GroupByBaselineHash' : 1,
  'Projection' : 2,
  'NonGroupedAggregate' : 3
};
ttypes.TCountDistinctImplType = {
  'Invalid' : 0,
  'Bitmap' : 1,
  'UnorderedSet' : 2
};
ttypes.TAggKind = {
  'AVG' : 0,
  'MIN' : 1,
  'MAX' : 2,
  'SUM' : 3,
  'COUNT' : 4,
  'APPROX_COUNT_DISTINCT' : 5,
  'SAMPLE' : 6,
  'SINGLE_VALUE' : 7
};
const TSlotSize = module.exports.TSlotSize = class {
  constructor(args) {
    this.padded = null;
    this.logical = null;
    if (args) {
      if (args.padded !== undefined && args.padded !== null) {
        this.padded = args.padded;
      }
      if (args.logical !== undefined && args.logical !== null) {
        this.logical = args.logical;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I16) {
          this.padded = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I16) {
          this.logical = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TSlotSize');
    if (this.padded !== null && this.padded !== undefined) {
      output.writeFieldBegin('padded', Thrift.Type.I16, 1);
      output.writeI16(this.padded);
      output.writeFieldEnd();
    }
    if (this.logical !== null && this.logical !== undefined) {
      output.writeFieldBegin('logical', Thrift.Type.I16, 2);
      output.writeI16(this.logical);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColSlotContext = module.exports.TColSlotContext = class {
  constructor(args) {
    this.slot_sizes = null;
    this.col_to_slot_map = null;
    if (args) {
      if (args.slot_sizes !== undefined && args.slot_sizes !== null) {
        this.slot_sizes = Thrift.copyList(args.slot_sizes, [ttypes.TSlotSize]);
      }
      if (args.col_to_slot_map !== undefined && args.col_to_slot_map !== null) {
        this.col_to_slot_map = Thrift.copyList(args.col_to_slot_map, [Thrift.copyList, null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.slot_sizes = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new ttypes.TSlotSize();
            elem3.read(input);
            this.slot_sizes.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.col_to_slot_map = [];
          const _rtmp35 = input.readListBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = [];
            const _rtmp39 = input.readListBegin();
            const _size8 = _rtmp39.size || 0;
            for (let _i10 = 0; _i10 < _size8; ++_i10) {
              let elem11 = null;
              elem11 = input.readI32();
              elem7.push(elem11);
            }
            input.readListEnd();
            this.col_to_slot_map.push(elem7);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColSlotContext');
    if (this.slot_sizes !== null && this.slot_sizes !== undefined) {
      output.writeFieldBegin('slot_sizes', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.slot_sizes.length);
      for (let iter12 in this.slot_sizes) {
        if (this.slot_sizes.hasOwnProperty(iter12)) {
          iter12 = this.slot_sizes[iter12];
          iter12.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.col_to_slot_map !== null && this.col_to_slot_map !== undefined) {
      output.writeFieldBegin('col_to_slot_map', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.LIST, this.col_to_slot_map.length);
      for (let iter13 in this.col_to_slot_map) {
        if (this.col_to_slot_map.hasOwnProperty(iter13)) {
          iter13 = this.col_to_slot_map[iter13];
          output.writeListBegin(Thrift.Type.I32, iter13.length);
          for (let iter14 in iter13) {
            if (iter13.hasOwnProperty(iter14)) {
              iter14 = iter13[iter14];
              output.writeI32(iter14);
            }
          }
          output.writeListEnd();
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCountDistinctDescriptor = module.exports.TCountDistinctDescriptor = class {
  constructor(args) {
    this.impl_type = null;
    this.min_val = null;
    this.bitmap_sz_bits = null;
    this.approximate = null;
    this.device_type = null;
    this.sub_bitmap_count = null;
    if (args) {
      if (args.impl_type !== undefined && args.impl_type !== null) {
        this.impl_type = args.impl_type;
      }
      if (args.min_val !== undefined && args.min_val !== null) {
        this.min_val = args.min_val;
      }
      if (args.bitmap_sz_bits !== undefined && args.bitmap_sz_bits !== null) {
        this.bitmap_sz_bits = args.bitmap_sz_bits;
      }
      if (args.approximate !== undefined && args.approximate !== null) {
        this.approximate = args.approximate;
      }
      if (args.device_type !== undefined && args.device_type !== null) {
        this.device_type = args.device_type;
      }
      if (args.sub_bitmap_count !== undefined && args.sub_bitmap_count !== null) {
        this.sub_bitmap_count = args.sub_bitmap_count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.impl_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.min_val = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.bitmap_sz_bits = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.approximate = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.device_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.sub_bitmap_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCountDistinctDescriptor');
    if (this.impl_type !== null && this.impl_type !== undefined) {
      output.writeFieldBegin('impl_type', Thrift.Type.I32, 1);
      output.writeI32(this.impl_type);
      output.writeFieldEnd();
    }
    if (this.min_val !== null && this.min_val !== undefined) {
      output.writeFieldBegin('min_val', Thrift.Type.I64, 2);
      output.writeI64(this.min_val);
      output.writeFieldEnd();
    }
    if (this.bitmap_sz_bits !== null && this.bitmap_sz_bits !== undefined) {
      output.writeFieldBegin('bitmap_sz_bits', Thrift.Type.I64, 3);
      output.writeI64(this.bitmap_sz_bits);
      output.writeFieldEnd();
    }
    if (this.approximate !== null && this.approximate !== undefined) {
      output.writeFieldBegin('approximate', Thrift.Type.BOOL, 4);
      output.writeBool(this.approximate);
      output.writeFieldEnd();
    }
    if (this.device_type !== null && this.device_type !== undefined) {
      output.writeFieldBegin('device_type', Thrift.Type.I32, 5);
      output.writeI32(this.device_type);
      output.writeFieldEnd();
    }
    if (this.sub_bitmap_count !== null && this.sub_bitmap_count !== undefined) {
      output.writeFieldBegin('sub_bitmap_count', Thrift.Type.I64, 6);
      output.writeI64(this.sub_bitmap_count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TResultSetBufferDescriptor = module.exports.TResultSetBufferDescriptor = class {
  constructor(args) {
    this.layout = null;
    this.keyless = null;
    this.entry_count = null;
    this.idx_target_as_key = null;
    this.min_val = null;
    this.max_val = null;
    this.bucket = null;
    this.group_col_widths = null;
    this.key_bytewidth = null;
    this.col_slot_context = null;
    this.target_groupby_indices = null;
    this.count_distinct_descriptors = null;
    this.force_4byte_float = null;
    if (args) {
      if (args.layout !== undefined && args.layout !== null) {
        this.layout = args.layout;
      }
      if (args.keyless !== undefined && args.keyless !== null) {
        this.keyless = args.keyless;
      }
      if (args.entry_count !== undefined && args.entry_count !== null) {
        this.entry_count = args.entry_count;
      }
      if (args.idx_target_as_key !== undefined && args.idx_target_as_key !== null) {
        this.idx_target_as_key = args.idx_target_as_key;
      }
      if (args.min_val !== undefined && args.min_val !== null) {
        this.min_val = args.min_val;
      }
      if (args.max_val !== undefined && args.max_val !== null) {
        this.max_val = args.max_val;
      }
      if (args.bucket !== undefined && args.bucket !== null) {
        this.bucket = args.bucket;
      }
      if (args.group_col_widths !== undefined && args.group_col_widths !== null) {
        this.group_col_widths = Thrift.copyList(args.group_col_widths, [null]);
      }
      if (args.key_bytewidth !== undefined && args.key_bytewidth !== null) {
        this.key_bytewidth = args.key_bytewidth;
      }
      if (args.col_slot_context !== undefined && args.col_slot_context !== null) {
        this.col_slot_context = new ttypes.TColSlotContext(args.col_slot_context);
      }
      if (args.target_groupby_indices !== undefined && args.target_groupby_indices !== null) {
        this.target_groupby_indices = Thrift.copyList(args.target_groupby_indices, [null]);
      }
      if (args.count_distinct_descriptors !== undefined && args.count_distinct_descriptors !== null) {
        this.count_distinct_descriptors = Thrift.copyList(args.count_distinct_descriptors, [ttypes.TCountDistinctDescriptor]);
      }
      if (args.force_4byte_float !== undefined && args.force_4byte_float !== null) {
        this.force_4byte_float = args.force_4byte_float;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.layout = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.keyless = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.entry_count = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.idx_target_as_key = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.min_val = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.max_val = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.bucket = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.group_col_widths = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = input.readI16();
            this.group_col_widths.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I16) {
          this.key_bytewidth = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRUCT) {
          this.col_slot_context = new ttypes.TColSlotContext();
          this.col_slot_context.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.LIST) {
          this.target_groupby_indices = [];
          const _rtmp320 = input.readListBegin();
          const _size19 = _rtmp320.size || 0;
          for (let _i21 = 0; _i21 < _size19; ++_i21) {
            let elem22 = null;
            elem22 = input.readI32();
            this.target_groupby_indices.push(elem22);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.LIST) {
          this.count_distinct_descriptors = [];
          const _rtmp324 = input.readListBegin();
          const _size23 = _rtmp324.size || 0;
          for (let _i25 = 0; _i25 < _size23; ++_i25) {
            let elem26 = null;
            elem26 = new ttypes.TCountDistinctDescriptor();
            elem26.read(input);
            this.count_distinct_descriptors.push(elem26);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.force_4byte_float = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TResultSetBufferDescriptor');
    if (this.layout !== null && this.layout !== undefined) {
      output.writeFieldBegin('layout', Thrift.Type.I32, 1);
      output.writeI32(this.layout);
      output.writeFieldEnd();
    }
    if (this.keyless !== null && this.keyless !== undefined) {
      output.writeFieldBegin('keyless', Thrift.Type.BOOL, 2);
      output.writeBool(this.keyless);
      output.writeFieldEnd();
    }
    if (this.entry_count !== null && this.entry_count !== undefined) {
      output.writeFieldBegin('entry_count', Thrift.Type.I32, 3);
      output.writeI32(this.entry_count);
      output.writeFieldEnd();
    }
    if (this.idx_target_as_key !== null && this.idx_target_as_key !== undefined) {
      output.writeFieldBegin('idx_target_as_key', Thrift.Type.I32, 4);
      output.writeI32(this.idx_target_as_key);
      output.writeFieldEnd();
    }
    if (this.min_val !== null && this.min_val !== undefined) {
      output.writeFieldBegin('min_val', Thrift.Type.I64, 5);
      output.writeI64(this.min_val);
      output.writeFieldEnd();
    }
    if (this.max_val !== null && this.max_val !== undefined) {
      output.writeFieldBegin('max_val', Thrift.Type.I64, 6);
      output.writeI64(this.max_val);
      output.writeFieldEnd();
    }
    if (this.bucket !== null && this.bucket !== undefined) {
      output.writeFieldBegin('bucket', Thrift.Type.I64, 7);
      output.writeI64(this.bucket);
      output.writeFieldEnd();
    }
    if (this.group_col_widths !== null && this.group_col_widths !== undefined) {
      output.writeFieldBegin('group_col_widths', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.I16, this.group_col_widths.length);
      for (let iter27 in this.group_col_widths) {
        if (this.group_col_widths.hasOwnProperty(iter27)) {
          iter27 = this.group_col_widths[iter27];
          output.writeI16(iter27);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.key_bytewidth !== null && this.key_bytewidth !== undefined) {
      output.writeFieldBegin('key_bytewidth', Thrift.Type.I16, 9);
      output.writeI16(this.key_bytewidth);
      output.writeFieldEnd();
    }
    if (this.col_slot_context !== null && this.col_slot_context !== undefined) {
      output.writeFieldBegin('col_slot_context', Thrift.Type.STRUCT, 10);
      this.col_slot_context.write(output);
      output.writeFieldEnd();
    }
    if (this.target_groupby_indices !== null && this.target_groupby_indices !== undefined) {
      output.writeFieldBegin('target_groupby_indices', Thrift.Type.LIST, 11);
      output.writeListBegin(Thrift.Type.I32, this.target_groupby_indices.length);
      for (let iter28 in this.target_groupby_indices) {
        if (this.target_groupby_indices.hasOwnProperty(iter28)) {
          iter28 = this.target_groupby_indices[iter28];
          output.writeI32(iter28);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.count_distinct_descriptors !== null && this.count_distinct_descriptors !== undefined) {
      output.writeFieldBegin('count_distinct_descriptors', Thrift.Type.LIST, 12);
      output.writeListBegin(Thrift.Type.STRUCT, this.count_distinct_descriptors.length);
      for (let iter29 in this.count_distinct_descriptors) {
        if (this.count_distinct_descriptors.hasOwnProperty(iter29)) {
          iter29 = this.count_distinct_descriptors[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.force_4byte_float !== null && this.force_4byte_float !== undefined) {
      output.writeFieldBegin('force_4byte_float', Thrift.Type.BOOL, 13);
      output.writeBool(this.force_4byte_float);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTargetInfo = module.exports.TTargetInfo = class {
  constructor(args) {
    this.is_agg = null;
    this.kind = null;
    this.type = null;
    this.arg_type = null;
    this.skip_nulls = null;
    this.is_distinct = null;
    if (args) {
      if (args.is_agg !== undefined && args.is_agg !== null) {
        this.is_agg = args.is_agg;
      }
      if (args.kind !== undefined && args.kind !== null) {
        this.kind = args.kind;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = new common_ttypes.TTypeInfo(args.type);
      }
      if (args.arg_type !== undefined && args.arg_type !== null) {
        this.arg_type = new common_ttypes.TTypeInfo(args.arg_type);
      }
      if (args.skip_nulls !== undefined && args.skip_nulls !== null) {
        this.skip_nulls = args.skip_nulls;
      }
      if (args.is_distinct !== undefined && args.is_distinct !== null) {
        this.is_distinct = args.is_distinct;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.is_agg = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.kind = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.type = new common_ttypes.TTypeInfo();
          this.type.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.arg_type = new common_ttypes.TTypeInfo();
          this.arg_type.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.skip_nulls = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.is_distinct = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTargetInfo');
    if (this.is_agg !== null && this.is_agg !== undefined) {
      output.writeFieldBegin('is_agg', Thrift.Type.BOOL, 1);
      output.writeBool(this.is_agg);
      output.writeFieldEnd();
    }
    if (this.kind !== null && this.kind !== undefined) {
      output.writeFieldBegin('kind', Thrift.Type.I32, 2);
      output.writeI32(this.kind);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.STRUCT, 3);
      this.type.write(output);
      output.writeFieldEnd();
    }
    if (this.arg_type !== null && this.arg_type !== undefined) {
      output.writeFieldBegin('arg_type', Thrift.Type.STRUCT, 4);
      this.arg_type.write(output);
      output.writeFieldEnd();
    }
    if (this.skip_nulls !== null && this.skip_nulls !== undefined) {
      output.writeFieldBegin('skip_nulls', Thrift.Type.BOOL, 5);
      output.writeBool(this.skip_nulls);
      output.writeFieldEnd();
    }
    if (this.is_distinct !== null && this.is_distinct !== undefined) {
      output.writeFieldBegin('is_distinct', Thrift.Type.BOOL, 6);
      output.writeBool(this.is_distinct);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCountDistinctSetStorage = module.exports.TCountDistinctSetStorage = class {
  constructor(args) {
    this.bitmap = null;
    this.sparse_set = null;
    if (args) {
      if (args.bitmap !== undefined && args.bitmap !== null) {
        this.bitmap = args.bitmap;
      }
      if (args.sparse_set !== undefined && args.sparse_set !== null) {
        this.sparse_set = Thrift.copyList(args.sparse_set, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.bitmap = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.SET) {
          this.sparse_set = [];
          const _rtmp331 = input.readSetBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = input.readI64();
            this.sparse_set.push(elem33);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCountDistinctSetStorage');
    if (this.bitmap !== null && this.bitmap !== undefined) {
      output.writeFieldBegin('bitmap', Thrift.Type.STRING, 1);
      output.writeBinary(this.bitmap);
      output.writeFieldEnd();
    }
    if (this.sparse_set !== null && this.sparse_set !== undefined) {
      output.writeFieldBegin('sparse_set', Thrift.Type.SET, 2);
      output.writeSetBegin(Thrift.Type.I64, this.sparse_set.length);
      for (let iter34 in this.sparse_set) {
        if (this.sparse_set.hasOwnProperty(iter34)) {
          iter34 = this.sparse_set[iter34];
          output.writeI64(iter34);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCountDistinctSet = module.exports.TCountDistinctSet = class {
  constructor(args) {
    this.type = null;
    this.storage = null;
    this.remote_ptr = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.storage !== undefined && args.storage !== null) {
        this.storage = new ttypes.TCountDistinctSetStorage(args.storage);
      }
      if (args.remote_ptr !== undefined && args.remote_ptr !== null) {
        this.remote_ptr = args.remote_ptr;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.storage = new ttypes.TCountDistinctSetStorage();
          this.storage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.remote_ptr = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCountDistinctSet');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.storage !== null && this.storage !== undefined) {
      output.writeFieldBegin('storage', Thrift.Type.STRUCT, 2);
      this.storage.write(output);
      output.writeFieldEnd();
    }
    if (this.remote_ptr !== null && this.remote_ptr !== undefined) {
      output.writeFieldBegin('remote_ptr', Thrift.Type.I64, 3);
      output.writeI64(this.remote_ptr);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TSerializedRows = module.exports.TSerializedRows = class {
  constructor(args) {
    this.buffers = null;
    this.buffer_lengths = null;
    this.buffers_total_size = null;
    this.total_compression_time_ms = null;
    this.descriptor = null;
    this.targets = null;
    this.target_init_vals = null;
    this.varlen_buffer = null;
    this.count_distinct_sets = null;
    this.explanation = null;
    if (args) {
      if (args.buffers !== undefined && args.buffers !== null) {
        this.buffers = Thrift.copyList(args.buffers, [null]);
      }
      if (args.buffer_lengths !== undefined && args.buffer_lengths !== null) {
        this.buffer_lengths = Thrift.copyList(args.buffer_lengths, [null]);
      }
      if (args.buffers_total_size !== undefined && args.buffers_total_size !== null) {
        this.buffers_total_size = args.buffers_total_size;
      }
      if (args.total_compression_time_ms !== undefined && args.total_compression_time_ms !== null) {
        this.total_compression_time_ms = args.total_compression_time_ms;
      }
      if (args.descriptor !== undefined && args.descriptor !== null) {
        this.descriptor = new ttypes.TResultSetBufferDescriptor(args.descriptor);
      }
      if (args.targets !== undefined && args.targets !== null) {
        this.targets = Thrift.copyList(args.targets, [ttypes.TTargetInfo]);
      }
      if (args.target_init_vals !== undefined && args.target_init_vals !== null) {
        this.target_init_vals = Thrift.copyList(args.target_init_vals, [null]);
      }
      if (args.varlen_buffer !== undefined && args.varlen_buffer !== null) {
        this.varlen_buffer = Thrift.copyList(args.varlen_buffer, [null]);
      }
      if (args.count_distinct_sets !== undefined && args.count_distinct_sets !== null) {
        this.count_distinct_sets = Thrift.copyList(args.count_distinct_sets, [ttypes.TCountDistinctSet]);
      }
      if (args.explanation !== undefined && args.explanation !== null) {
        this.explanation = args.explanation;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.buffers = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = input.readBinary();
            this.buffers.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.buffer_lengths = [];
          const _rtmp340 = input.readListBegin();
          const _size39 = _rtmp340.size || 0;
          for (let _i41 = 0; _i41 < _size39; ++_i41) {
            let elem42 = null;
            elem42 = input.readI64();
            this.buffer_lengths.push(elem42);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.buffers_total_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.total_compression_time_ms = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.descriptor = new ttypes.TResultSetBufferDescriptor();
          this.descriptor.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.targets = [];
          const _rtmp344 = input.readListBegin();
          const _size43 = _rtmp344.size || 0;
          for (let _i45 = 0; _i45 < _size43; ++_i45) {
            let elem46 = null;
            elem46 = new ttypes.TTargetInfo();
            elem46.read(input);
            this.targets.push(elem46);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.target_init_vals = [];
          const _rtmp348 = input.readListBegin();
          const _size47 = _rtmp348.size || 0;
          for (let _i49 = 0; _i49 < _size47; ++_i49) {
            let elem50 = null;
            elem50 = input.readI64();
            this.target_init_vals.push(elem50);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.varlen_buffer = [];
          const _rtmp352 = input.readListBegin();
          const _size51 = _rtmp352.size || 0;
          for (let _i53 = 0; _i53 < _size51; ++_i53) {
            let elem54 = null;
            elem54 = input.readBinary();
            this.varlen_buffer.push(elem54);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.count_distinct_sets = [];
          const _rtmp356 = input.readListBegin();
          const _size55 = _rtmp356.size || 0;
          for (let _i57 = 0; _i57 < _size55; ++_i57) {
            let elem58 = null;
            elem58 = new ttypes.TCountDistinctSet();
            elem58.read(input);
            this.count_distinct_sets.push(elem58);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.explanation = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TSerializedRows');
    if (this.buffers !== null && this.buffers !== undefined) {
      output.writeFieldBegin('buffers', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRING, this.buffers.length);
      for (let iter59 in this.buffers) {
        if (this.buffers.hasOwnProperty(iter59)) {
          iter59 = this.buffers[iter59];
          output.writeBinary(iter59);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.buffer_lengths !== null && this.buffer_lengths !== undefined) {
      output.writeFieldBegin('buffer_lengths', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I64, this.buffer_lengths.length);
      for (let iter60 in this.buffer_lengths) {
        if (this.buffer_lengths.hasOwnProperty(iter60)) {
          iter60 = this.buffer_lengths[iter60];
          output.writeI64(iter60);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.buffers_total_size !== null && this.buffers_total_size !== undefined) {
      output.writeFieldBegin('buffers_total_size', Thrift.Type.I64, 3);
      output.writeI64(this.buffers_total_size);
      output.writeFieldEnd();
    }
    if (this.total_compression_time_ms !== null && this.total_compression_time_ms !== undefined) {
      output.writeFieldBegin('total_compression_time_ms', Thrift.Type.I32, 4);
      output.writeI32(this.total_compression_time_ms);
      output.writeFieldEnd();
    }
    if (this.descriptor !== null && this.descriptor !== undefined) {
      output.writeFieldBegin('descriptor', Thrift.Type.STRUCT, 5);
      this.descriptor.write(output);
      output.writeFieldEnd();
    }
    if (this.targets !== null && this.targets !== undefined) {
      output.writeFieldBegin('targets', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.targets.length);
      for (let iter61 in this.targets) {
        if (this.targets.hasOwnProperty(iter61)) {
          iter61 = this.targets[iter61];
          iter61.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.target_init_vals !== null && this.target_init_vals !== undefined) {
      output.writeFieldBegin('target_init_vals', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.I64, this.target_init_vals.length);
      for (let iter62 in this.target_init_vals) {
        if (this.target_init_vals.hasOwnProperty(iter62)) {
          iter62 = this.target_init_vals[iter62];
          output.writeI64(iter62);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.varlen_buffer !== null && this.varlen_buffer !== undefined) {
      output.writeFieldBegin('varlen_buffer', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRING, this.varlen_buffer.length);
      for (let iter63 in this.varlen_buffer) {
        if (this.varlen_buffer.hasOwnProperty(iter63)) {
          iter63 = this.varlen_buffer[iter63];
          output.writeBinary(iter63);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.count_distinct_sets !== null && this.count_distinct_sets !== undefined) {
      output.writeFieldBegin('count_distinct_sets', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.count_distinct_sets.length);
      for (let iter64 in this.count_distinct_sets) {
        if (this.count_distinct_sets.hasOwnProperty(iter64)) {
          iter64 = this.count_distinct_sets[iter64];
          iter64.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.explanation !== null && this.explanation !== undefined) {
      output.writeFieldBegin('explanation', Thrift.Type.STRING, 10);
      output.writeString(this.explanation);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 2003:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__2003__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(7123);
/******/ })()
;
});