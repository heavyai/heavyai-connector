module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3009:
/***/ ((module) => {

"use strict";


function Queue(options) {
  if (!(this instanceof Queue)) {
    return new Queue(options);
  }

  options = options || {};
  this.concurrency = options.concurrency || Infinity;
  this.pending = 0;
  this.jobs = [];
  this.cbs = [];
  this._done = done.bind(this);
}

var arrayAddMethods = [
  'push',
  'unshift',
  'splice'
];

arrayAddMethods.forEach(function(method) {
  Queue.prototype[method] = function() {
    var methodResult = Array.prototype[method].apply(this.jobs, arguments);
    this._run();
    return methodResult;
  };
});

Object.defineProperty(Queue.prototype, 'length', {
  get: function() {
    return this.pending + this.jobs.length;
  }
});

Queue.prototype._run = function() {
  if (this.pending === this.concurrency) {
    return;
  }
  if (this.jobs.length) {
    var job = this.jobs.shift();
    this.pending++;
    job(this._done);
    this._run();
  }

  if (this.pending === 0) {
    while (this.cbs.length !== 0) {
      var cb = this.cbs.pop();
      process.nextTick(cb);
    }
  }
};

Queue.prototype.onDone = function(cb) {
  if (typeof cb === 'function') {
    this.cbs.push(cb);
    this._run();
  }
};

function done() {
  this.pending--;
  this._run();
}

module.exports = Queue;


/***/ }),

/***/ 7123:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DbCon": () => /* binding */ DbCon,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__,
/* harmony export */   "Client": () => /* reexport safe */ _thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__.Client,
/* harmony export */   "Processor": () => /* reexport safe */ _thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__.Processor
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6729);
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var apache_arrow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3521);
/* harmony import */ var apache_arrow__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(apache_arrow__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1669);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2818);
/* harmony import */ var _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2607);
/* harmony import */ var _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4221);
/* harmony import */ var thrift__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7392);
/* harmony import */ var _process_query_results__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5141);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2033);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4494);
/* harmony import */ var _thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_completion_hints_types__WEBPACK_IMPORTED_MODULE_9__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1396);
/* harmony import */ var _thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_extension_functions_types__WEBPACK_IMPORTED_MODULE_10__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3962);
/* harmony import */ var _thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11__) if(["default","DbCon","Client","Processor"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _thrift_serialized_result_set_types__WEBPACK_IMPORTED_MODULE_11__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var COMPRESSION_LEVEL_DEFAULT = 3;

function arrayify(maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
} // custom version of XHRConnection which can set `withCredentials` for CORS


function CustomXHRConnection(host, port, opts) {
  var _this = this;

  thrift__WEBPACK_IMPORTED_MODULE_6__.XHRConnection.call(this, host, port, opts);

  if (opts.headers["Content-Type"] === "application/vnd.apache.thrift.binary") {
    // this is copy/paste from thrift with the noted changes below
    this.flush = function () {
      if (_this.url === undefined || _this.url === "") {
        return _this.send_buf;
      }

      var xreq = _this.getXmlHttpRequestObject(); // removed overrideMimeType since we're expecting binary data
      // added responseType


      xreq.responseType = "arraybuffer";

      xreq.onreadystatechange = function () {
        if (xreq.readyState === 4 && xreq.status === 200) {
          // changed responseText -> response
          _this.setRecvBuffer(xreq.response);
        }
      };

      xreq.open("POST", _this.url, true);
      Object.keys(_this.headers).forEach(function (headerKey) {
        xreq.setRequestHeader(headerKey, _this.headers[headerKey]);
      });
      xreq.send(_this.send_buf);
    };
  }
}

util__WEBPACK_IMPORTED_MODULE_2___default().inherits(CustomXHRConnection, thrift__WEBPACK_IMPORTED_MODULE_6__.XHRConnection);

CustomXHRConnection.prototype.getXmlHttpRequestObject = function () {
  var obj = thrift__WEBPACK_IMPORTED_MODULE_6__.XHRConnection.prototype.getXmlHttpRequestObject.call(this);
  obj.withCredentials = CustomXHRConnection.withCredentials;
  return obj;
}; // Custom version of TJSONProtocol - thrift 0.14.0 throws an exception if
// anything other than a string or Buffer is passed to writeString. For
// example: we use a number for a nonce that is defined as a string type. So,
// let's just coerce things to a string.


function CustomTJSONProtocol() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol.apply(this, args);
}

util__WEBPACK_IMPORTED_MODULE_2___default().inherits(CustomTJSONProtocol, thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol);

CustomTJSONProtocol.prototype.writeString = function (arg) {
  if (!(arg instanceof Buffer)) {
    arg = String(arg);
  }

  return thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol.prototype.writeString.call(this, arg);
}; // Additionally, the browser version of connector relied on thrift's old
// behavior of returning a Number for a 64-bit int. Technically, javascript
// does not have 64-bits of precision in a Number, so this can end up giving
// incorrect results.
//
// Lastly, the browser version relied on thrift returning a string from a
// binary type.


if (process.env.BROWSER) {
  CustomTJSONProtocol.prototype.readI64 = function () {
    var n = thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol.prototype.readI64.call(this);
    return n.toNumber(true);
  };

  CustomTJSONProtocol.prototype.readBinary = function () {
    return thrift__WEBPACK_IMPORTED_MODULE_6__.TJSONProtocol.prototype.readString.call(this);
  };
} // Custom version of the binary protocol to override writeString, readI64, and
// readBinary as above.


function CustomBinaryProtocol() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol.apply(this, args);
}

util__WEBPACK_IMPORTED_MODULE_2___default().inherits(CustomBinaryProtocol, thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol);

CustomBinaryProtocol.prototype.writeString = function (arg) {
  if (!(arg instanceof Buffer)) {
    arg = String(arg);
  }

  return thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol.prototype.writeString.call(this, arg);
};

if (process.env.BROWSER) {
  CustomBinaryProtocol.prototype.readI64 = function () {
    var n = thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol.prototype.readI64.call(this);
    return n.toNumber(true);
  };

  CustomBinaryProtocol.prototype.readBinary = function () {
    return thrift__WEBPACK_IMPORTED_MODULE_6__.TBinaryProtocol.prototype.readBinary.call(this).toString("base64");
  };
}

function buildClient(url, useBinaryProtocol) {
  var urlObj = new URL(url);
  var protocol = urlObj.protocol;
  var hostname = urlObj.hostname;
  var port = urlObj.port;

  if (port === "") {
    port = protocol === "https:" ? "443" : "80";
  }

  var client = null;

  if (!process.env.BROWSER) {
    var connection = (0,thrift__WEBPACK_IMPORTED_MODULE_6__.createHttpConnection)(hostname, port, {
      transport: thrift__WEBPACK_IMPORTED_MODULE_6__.TBufferedTransport,
      protocol: useBinaryProtocol ? CustomBinaryProtocol : CustomTJSONProtocol,
      path: "/",
      headers: {
        Connection: "close",
        "Content-Type": "application/vnd.apache.thrift.".concat(useBinaryProtocol ? "binary" : "json")
      },
      https: protocol === "https:"
    });
    connection.on("error", console.error); // eslint-disable-line no-console

    client = (0,thrift__WEBPACK_IMPORTED_MODULE_6__.createClient)(_thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__, connection);
  } else {
    var _connection = new CustomXHRConnection(hostname, port, {
      transport: thrift__WEBPACK_IMPORTED_MODULE_6__.TBufferedTransport,
      protocol: useBinaryProtocol ? CustomBinaryProtocol : CustomTJSONProtocol,
      path: "/",
      headers: {
        "Content-Type": "application/vnd.apache.thrift.".concat(useBinaryProtocol ? "binary" : "json")
      },
      https: protocol === "https:"
    });

    _connection.on("error", console.error); // eslint-disable-line no-console


    client = (0,thrift__WEBPACK_IMPORTED_MODULE_6__.createXHRClient)(_thrift_Heavy_js__WEBPACK_IMPORTED_MODULE_5__, _connection);
  }

  return client;
}

var DbCon = /*#__PURE__*/function () {
  function DbCon() {
    var _this2 = this;

    _classCallCheck(this, DbCon);

    _defineProperty(this, "updateQueryTimes", function (conId, queryId, estimatedQueryTime, execution_time_ms) {
      _this2.queryTimes[queryId] = execution_time_ms;
    });

    _defineProperty(this, "events", new (eventemitter3__WEBPACK_IMPORTED_MODULE_0___default())());

    _defineProperty(this, "EVENT_NAMES", {
      ERROR: "error",
      METHOD_CALLED: "method-called"
    });

    _defineProperty(this, "handleErrors", function (method) {
      return function () {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return method.apply(_this2, args)["catch"](function (error) {
          _this2.events.emit(_this2.EVENT_NAMES.ERROR, error);

          throw error;
        });
      };
    });

    _defineProperty(this, "callbackify", function (method, arity) {
      return function () {
        var callback = null;

        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        if (args.length === arity + 1) {
          callback = args.pop();
        }

        var promise = _this2[method].apply(_this2, args);

        if (callback) {
          promise["catch"](function (err) {
            return callback(err);
          }).then(function (res) {
            return callback(null, res);
          });
        }

        return promise;
      };
    });

    _defineProperty(this, "overSingleClient", "SINGLE_CLIENT");

    _defineProperty(this, "overAllClients", "ALL_CLIENTS");

    _defineProperty(this, "wrapThrift", function (methodName, overClients, processArgs) {
      return function () {
        if (_this2._sessionId) {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }

          var processedArgs = processArgs(args);

          if (process.env.BROWSER) {
            _this2.events.emit(_this2.EVENT_NAMES.METHOD_CALLED, methodName);
          }

          if (overClients === _this2.overSingleClient) {
            return _this2._client[0][methodName].apply(_this2._client[0], [_this2._sessionId[0]].concat(processedArgs));
          } else {
            return Promise.all(_this2._client.map(function (client, index) {
              return client[methodName].apply(client, [_this2._sessionId[index]].concat(processedArgs));
            }));
          }
        } else {
          return Promise.reject(new Error("You are not connected to a server. Try running the connect method first."));
        }
      };
    });

    _defineProperty(this, "connect", this.callbackify("connectAsync", 0));

    _defineProperty(this, "disconnectAsync", this.handleErrors(function () {
      return Promise.all(_this2._client.map(function (client, c) {
        return client.disconnect(_this2._sessionId[c])["catch"](function (error) {
          // ignore timeout errors
          if (error && !_this2.isTimeoutError(error)) {
            throw error;
          }
        });
      })).then(function () {
        _this2._sessionId = null;
        _this2._client = null;
        _this2._numConnections = 0;
        _this2.serverPingTimes = null;
        return _this2;
      });
    }));

    _defineProperty(this, "disconnect", this.callbackify("disconnectAsync", 0));

    _defineProperty(this, "getStatusAsync", this.handleErrors(this.wrapThrift("get_status", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getStatus", this.callbackify("getStatusAsync", 0));

    _defineProperty(this, "getHardwareInfoAsync", this.handleErrors(this.wrapThrift("get_hardware_info", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getHardwareInfo", this.callbackify("getHardwareInfoAsync", 0));

    _defineProperty(this, "getFirstGeoFileInArchiveAsync", this.handleErrors(this.wrapThrift("get_first_geo_file_in_archive", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getFilesInArchiveAsync", this.handleErrors(this.wrapThrift("get_all_files_in_archive", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getUsersAsync", this.handleErrors(this.wrapThrift("get_users", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "importTableStatusAsync", this.handleErrors(this.wrapThrift("import_table_status", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getRolesAsync", this.handleErrors(this.wrapThrift("get_roles", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getDashboardsAsync", this.handleErrors(this.wrapThrift("get_dashboards", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getDashboardAsync", this.handleErrors(this.wrapThrift("get_dashboard", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "createDashboardAsync", this.handleErrors(this.wrapThrift("create_dashboard", this.overAllClients, function (args) {
      return args;
    })));

    _defineProperty(this, "replaceDashboardAsync", this.handleErrors(this.wrapThrift("replace_dashboard", this.overAllClients, function (args) {
      return args;
    })));

    _defineProperty(this, "deleteDashboardAsync", this.handleErrors(this.wrapThrift("delete_dashboard", this.overAllClients, function (args) {
      return args;
    })));

    _defineProperty(this, "deleteDashboardsAsync", this.handleErrors(this.wrapThrift("delete_dashboards", this.overAllClients, function (args) {
      return args;
    })));

    _defineProperty(this, "shareDashboardAsync", this.handleErrors(this.wrapThrift("share_dashboard", this.overAllClients, function (_ref) {
      var _ref2 = _slicedToArray(_ref, 4),
          dashboardId = _ref2[0],
          groups = _ref2[1],
          objects = _ref2[2],
          permissions = _ref2[3];

      return [dashboardId, groups, objects, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDashboardPermissions(permissions)];
    })));

    _defineProperty(this, "shareDashboardsAsync", this.handleErrors(this.wrapThrift("share_dashboards", this.overAllClients, function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 3),
          dashboardIds = _ref4[0],
          groups = _ref4[1],
          permissions = _ref4[2];

      return [dashboardIds, groups, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDashboardPermissions(permissions)];
    })));

    _defineProperty(this, "unshareDashboardAsync", this.handleErrors(this.wrapThrift("unshare_dashboard", this.overAllClients, function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 4),
          dashboardId = _ref6[0],
          groups = _ref6[1],
          objects = _ref6[2],
          permissions = _ref6[3];

      return [dashboardId, groups, objects, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDashboardPermissions(permissions)];
    })));

    _defineProperty(this, "unshareDashboardsAsync", this.handleErrors(this.wrapThrift("unshare_dashboards", this.overAllClients, function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 3),
          dashboardIds = _ref8[0],
          groups = _ref8[1],
          permissions = _ref8[2];

      return [dashboardIds, groups, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDashboardPermissions(permissions)];
    })));

    _defineProperty(this, "getDashboardGranteesAsync", this.handleErrors(this.wrapThrift("get_dashboard_grantees", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getDbObjectsForGranteeAsync", this.handleErrors(this.wrapThrift("get_db_objects_for_grantee", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getDbObjectPrivsAsync", this.handleErrors(this.wrapThrift("get_db_object_privs", this.overSingleClient, function (_ref9) {
      var _ref10 = _slicedToArray(_ref9, 2),
          objectName = _ref10[0],
          type = _ref10[1];

      return [objectName, _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDBObjectType[type]];
    })));

    _defineProperty(this, "getAllRolesForUserAsync", this.handleErrors(this.wrapThrift("get_all_roles_for_user", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getAllEffectiveRolesForUserAsync", this.handleErrors(this.wrapThrift("get_all_effective_roles_for_user", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "hasObjectPrivilegesAsync", this.handleErrors(this.wrapThrift("has_object_privilege", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "hasDbPrivilegesAsync", function (granteeName, dbName, dbPrivs) {
      return _this2.hasObjectPrivilegesAsync(granteeName, dbName, _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDBObjectType.DatabaseDBObjectType, new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDBObjectPermissions({
        database_permissions_: new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDatabasePermissions(dbPrivs)
      }));
    });

    _defineProperty(this, "getSessionInfoAsync", this.handleErrors(this.wrapThrift("get_session_info", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "createCustomExpressionAsync", this.handleErrors(this.wrapThrift("create_custom_expression", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getCustomExpressionsAsync", this.handleErrors(this.wrapThrift("get_custom_expressions", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "updateCustomExpressionAsync", this.handleErrors(this.wrapThrift("update_custom_expression", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "deleteCustomExpressionsAsync", this.handleErrors(this.wrapThrift("delete_custom_expressions", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "detectColumnTypesAsync", this.handleErrors(function (filename, copyParams) {
      var detectColumnTypes = _this2.wrapThrift("detect_column_types", _this2.overSingleClient, function () {
        return [filename, _helpers__WEBPACK_IMPORTED_MODULE_8__/* .convertObjectToThriftCopyParams */ .Dq(copyParams)];
      });

      return detectColumnTypes().then(function (res) {
        _this2.importerRowDesc = res.row_set.row_desc;
        return res;
      });
    }));

    _defineProperty(this, "queryAsync", this.handleErrors(function (query, options) {
      var columnarResults = true;
      var eliminateNullRows = false;
      var queryId = null;
      var returnTiming = false;
      var limit = -1;
      var curNonce = (_this2._nonce++).toString();

      if (options) {
        columnarResults = options.hasOwnProperty("columnarResults") ? options.columnarResults : columnarResults;
        eliminateNullRows = options.hasOwnProperty("eliminateNullRows") ? options.eliminateNullRows : eliminateNullRows;
        queryId = options.hasOwnProperty("queryId") ? options.queryId : queryId;
        returnTiming = options.hasOwnProperty("returnTiming") ? options.returnTiming : returnTiming;
        limit = options.hasOwnProperty("limit") ? options.limit : limit;
        curNonce = options.hasOwnProperty("logValues") ? _typeof(options.logValues) === "object" ? JSON.stringify(options.logValues) : options.logValues : curNonce;
      }

      var lastQueryTime = queryId in _this2.queryTimes ? _this2.queryTimes[queryId] : _this2.DEFAULT_QUERY_TIME;
      var conId = 0;
      var processResultsOptions = {
        returnTiming: returnTiming,
        eliminateNullRows: eliminateNullRows,
        query: query,
        queryId: queryId,
        conId: conId,
        estimatedQueryTime: lastQueryTime,
        startTime: Date.now()
      };
      var AT_MOST_N = -1;

      var sqlExecute = _this2.wrapThrift("sql_execute", _this2.overSingleClient, function (args) {
        return args;
      });

      var runQuery = function runQuery() {
        return sqlExecute(query, columnarResults, curNonce, limit, AT_MOST_N)["catch"](function (err) {
          if (err.name === "NetworkError") {
            _this2.removeConnection(0);

            if (_this2._numConnections === 0) {
              err.msg = "No remaining database connections";
              throw err;
            }

            return runQuery();
          }

          throw err;
        });
      };

      return _this2.processResults(processResultsOptions, runQuery());
    }));

    _defineProperty(this, "query", this.callbackify("queryAsync", 2));

    _defineProperty(this, "queryDFAsync", this.handleErrors(function (query, options) {
      var deviceId = 0;
      var limit = -1;

      var sqlExecuteDF = _this2.wrapThrift("sql_execute_df", _this2.overSingleClient, function () {
        return [query, _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TDeviceType.CPU, deviceId, limit, _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TArrowTransport.WIRE];
      });

      return sqlExecuteDF().then(function (data) {
        if (_this2._logging) {
          // eslint-disable-next-line no-console
          console.log(query, "on Server", 0, "- Execution Time:", data.execution_time_ms, "ms");
        }

        var buf = Buffer.from(data.df_buffer, "base64");
        var results = (0,apache_arrow__WEBPACK_IMPORTED_MODULE_1__.tableFromIPC)(buf);

        if (options && Boolean(options.returnTiming)) {
          results = {
            results: results,
            timing: {
              execution_time_ms: data.execution_time_ms
            }
          };
        }

        return results;
      });
    }));

    _defineProperty(this, "queryDF", this.callbackify("queryDFAsync", 2));

    _defineProperty(this, "validateQuery", this.handleErrors(function (query) {
      var sqlValidate = _this2.wrapThrift("sql_validate", _this2.overSingleClient, function (args) {
        return args;
      });

      return sqlValidate(query).then(function (fields) {
        var rowDict = fields.reduce(function (accum, value) {
          accum[value.col_name] = value;
          return accum;
        }, {});
        return _this2.convertFromThriftTypes(rowDict);
      });
    }));

    _defineProperty(this, "getTablesAsync", this.handleErrors(function () {
      var getTables = _this2.wrapThrift("get_tables", _this2.overSingleClient, function (args) {
        return args;
      });

      return getTables().then(function (tables) {
        return tables.map(function (table) {
          return {
            name: table,
            label: "obs"
          };
        });
      });
    }));

    _defineProperty(this, "getTables", this.callbackify("getTablesAsync", 0));

    _defineProperty(this, "getTablesWithMetaAsync", this.handleErrors(function () {
      var getTablesMeta = _this2.wrapThrift("get_tables_meta", _this2.overSingleClient, function (args) {
        return args;
      });

      return getTablesMeta().then(function (tables) {
        return tables.map(function (table) {
          return {
            name: table.table_name,
            num_cols: Number(table.num_cols.toString()),
            col_datum_types: table.col_types.map(function (type) {
              return _this2._datumEnum[type.type];
            }),
            is_view: table.is_view,
            is_replicated: table.is_replicated,
            shard_count: Number(table.shard_count.toString()),
            max_rows: isFinite(table.max_rows) ? Number(table.max_rows.toString()) : -1
          };
        });
      });
    }));

    _defineProperty(this, "getTablesWithMeta", this.callbackify("getTablesWithMetaAsync", 0));

    _defineProperty(this, "getTablesMetaAsync", this.handleErrors(this.wrapThrift("get_tables_meta", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getTablesMeta", this.callbackify("getTablesMetaAsync", 0));

    _defineProperty(this, "getTableEpochByNameAsync", this.handleErrors(this.wrapThrift("get_table_epoch_by_name", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getTableEpochByName", this.callbackify("getTableEpochByNameAsync", 0));

    _defineProperty(this, "getTableFunctionNamesAsync", this.handleErrors(this.wrapThrift("get_table_function_names", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getTableFunctionNames", this.callbackify("getTableFunctionNamesAsync", 0));

    _defineProperty(this, "getRuntimeTableFunctionNamesAsync", this.handleErrors(this.wrapThrift("get_runtime_table_function_names", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getRuntimeTableFunctionNames", this.callbackify("getRuntimeTableFunctionNamesAsync", 0));

    _defineProperty(this, "getTableFunctionDetailsAsync", this.handleErrors(this.wrapThrift("get_table_function_details", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "getTableFunctionDetails", this.callbackify("getTableFunctionDetailsAsync", 0));

    _defineProperty(this, "getCompletionHintsAsync", this.handleErrors(this.wrapThrift("get_completion_hints", this.overSingleClient, function (_ref11) {
      var _ref12 = _slicedToArray(_ref11, 2),
          queryString = _ref12[0],
          cursor = _ref12[1].cursor;

      return [queryString, cursor];
    })));

    _defineProperty(this, "getCompletionHints", this.callbackify("getCompletionHintsAsync", 2));

    _defineProperty(this, "loadTableBinaryColumnarAsync", this.handleErrors(this.wrapThrift("load_table_binary_columnar", this.overSingleClient, function (args) {
      return args;
    })));

    _defineProperty(this, "loadTableBinaryColumnar", this.callbackify("loadTableBinaryColumnarAsync", 3));

    _defineProperty(this, "buildTFileTypeMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TFileType) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TFileType.hasOwnProperty(key)) {
          _this2.TFileTypeMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TFileType[key]] = key;
        }
      }
    });

    _defineProperty(this, "buildTImportHeaderRowMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TImportHeaderRow) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TImportHeaderRow.hasOwnProperty(key)) {
          _this2.TImportHeaderRowMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TImportHeaderRow[key]] = key;
        }
      }
    });

    _defineProperty(this, "buildTEncodingTypeMap", function () {
      for (var encoding in _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TEncodingType) {
        if (_thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TEncodingType.hasOwnProperty(encoding)) {
          _this2.TEncodingTypeMap[_thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TEncodingType[encoding]] = encoding;
        }
      }
    });

    _defineProperty(this, "buildTRasterPointTypeMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointType) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointType.hasOwnProperty(key)) {
          _this2.TRasterPointTypeMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointType[key]] = key;
        }
      }
    });

    _defineProperty(this, "buildTRasterPointTransformMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointTransform) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointTransform.hasOwnProperty(key)) {
          _this2.TRasterPointTransformMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TRasterPointTransform[key]] = key;
        }
      }
    });

    _defineProperty(this, "buildTSourceTypeMap", function () {
      for (var key in _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TSourceType) {
        if (_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TSourceType.hasOwnProperty(key)) {
          _this2.TSourceTypeMap[_thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TSourceType[key]] = key;
        }
      }
    });

    _defineProperty(this, "getFieldsAsync", this.handleErrors(function (tableName) {
      var getTableDetails = _this2.wrapThrift("get_table_details", _this2.overSingleClient, function (args) {
        return args;
      });

      return getTableDetails(tableName).then(function (fields) {
        if (fields) {
          var rowDict = fields.row_desc.reduce(function (accum, value) {
            accum[value.col_name] = value;
            return accum;
          }, {});
          return _objectSpread(_objectSpread({}, fields), {}, {
            columns: _this2.convertFromThriftTypes(rowDict)
          });
        } else {
          throw new Error("Table (".concat(tableName, ") not found"));
        }
      });
    }));

    _defineProperty(this, "getFields", this.callbackify("getFieldsAsync", 1));

    _defineProperty(this, "createTableAsync", this.handleErrors(this.wrapThrift("create_table", this.overAllClients, function (_ref13) {
      var _ref14 = _slicedToArray(_ref13, 4),
          tableName = _ref14[0],
          rowDescObj = _ref14[1],
          createParams = _ref14[2],
          options = _ref14[3];

      return [tableName, (options === null || options === void 0 ? void 0 : options.useUnmodifiedRowDesc) ? rowDescObj : _helpers__WEBPACK_IMPORTED_MODULE_8__/* .mutateThriftRowDesc */ .HP(rowDescObj, _this2.importerRowDesc), createParams];
    })));

    _defineProperty(this, "createTable", this.callbackify("createTableAsync", 4));

    _defineProperty(this, "importTableAsync", this.handleErrors(this.wrapThrift("import_table", this.overAllClients, function (_ref15) {
      var _ref16 = _slicedToArray(_ref15, 3),
          tableName = _ref16[0],
          fileName = _ref16[1],
          copyParams = _ref16[2];

      return [tableName, fileName, _helpers__WEBPACK_IMPORTED_MODULE_8__/* .convertObjectToThriftCopyParams */ .Dq(copyParams)];
    })));

    _defineProperty(this, "importTableGeoAsync", this.handleErrors(this.wrapThrift("import_geo_table", this.overAllClients, function (_ref17) {
      var _ref18 = _slicedToArray(_ref17, 4),
          tableName = _ref18[0],
          fileName = _ref18[1],
          copyParams = _ref18[2],
          rowDescObj = _ref18[3];

      return [tableName, fileName, _helpers__WEBPACK_IMPORTED_MODULE_8__/* .convertObjectToThriftCopyParams */ .Dq(copyParams), _helpers__WEBPACK_IMPORTED_MODULE_8__/* .mutateThriftRowDesc */ .HP(rowDescObj, _this2.importerRowDesc), new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TCreateParams()];
    })));

    _defineProperty(this, "renderVegaAsync", this.handleErrors(function (widgetid, vega, options) {
      var queryId = null;
      var compressionLevel = COMPRESSION_LEVEL_DEFAULT;

      if (options) {
        queryId = options.hasOwnProperty("queryId") ? options.queryId : queryId;
        compressionLevel = options.hasOwnProperty("compressionLevel") ? options.compressionLevel : compressionLevel;
      }

      var lastQueryTime = queryId in _this2.queryTimes ? _this2.queryTimes[queryId] : _this2.DEFAULT_QUERY_TIME;
      var curNonce = (_this2._nonce++).toString();

      if (options) {
        curNonce = options.hasOwnProperty("logValues") ? _typeof(options.logValues) === "object" ? JSON.stringify(options.logValues) : options.logValues : curNonce;
      }

      var conId = 0;
      _this2._lastRenderCon = conId;
      var processResultsOptions = {
        isImage: true,
        query: "render: ".concat(vega),
        queryId: queryId,
        conId: conId,
        estimatedQueryTime: lastQueryTime
      };

      var renderVega = _this2.wrapThrift("render_vega", _this2.overSingleClient, function (args) {
        return args;
      });

      return _this2.processResults(processResultsOptions, renderVega(widgetid, vega, compressionLevel, curNonce));
    }));

    _defineProperty(this, "renderVega", this.callbackify("renderVegaAsync", 3));

    _defineProperty(this, "getResultRowForPixelAsync", this.handleErrors(function (widgetId, pixel, tableColNamesMap) {
      var pixelRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;

      if (!(pixel instanceof _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TPixel)) {
        pixel = new _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TPixel(pixel);
      }

      var columnFormat = true; // BOOL

      var curNonce = (_this2._nonce++).toString();
      return _this2._client[_this2._lastRenderCon].get_result_row_for_pixel(_this2._sessionId[_this2._lastRenderCon], widgetId, pixel, tableColNamesMap, columnFormat, pixelRadius, curNonce).then(function (results) {
        results = Array.isArray(results) ? results.pixel_rows : [results];
        var processResultsOptions = {
          isImage: false,
          eliminateNullRows: false,
          query: "pixel request",
          queryId: -2
        };
        var processor = (0,_process_query_results__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(_this2._logging, _this2.updateQueryTimes);
        var numPixels = results.length;

        for (var p = 0; p < numPixels; p++) {
          results[p].row_set = processor(processResultsOptions, _this2._datumEnum, results[p]);
        }

        return results;
      });
    }));

    _defineProperty(this, "getResultRowForPixel", this.callbackify("getResultRowForPixelAsync", 4));

    this._useBinaryProtocol = false;
    this._host = null;
    this._user = null;
    this._password = null;
    this._port = null;
    this._dbName = null;
    this._client = null;
    this._sessionId = null;
    this._protocol = null;
    this._disableAutoReconnect = false;
    this._datumEnum = {};
    this.TFileTypeMap = {};
    this.TEncodingTypeMap = {};
    this.TImportHeaderRowMap = {};
    this.TRasterPointTypeMap = {};
    this.TRasterPointTransformMap = {};
    this.TSourceTypeMap = {};
    this._logging = false;
    this._platform = "heavydb";
    this._nonce = 0;
    this._balanceStrategy = "adaptive";
    this._numConnections = 0;
    this._lastRenderCon = 0;
    this.queryTimes = {};
    this.serverQueueTimes = null;
    this.serverPingTimes = null;
    this.pingCount = null;
    this.DEFAULT_QUERY_TIME = 50;
    this.NUM_PINGS_PER_SERVER = 4;
    this.importerRowDesc = null; // invoke initialization methods

    this.invertDatumTypes();
    this.buildTFileTypeMap();
    this.buildTEncodingTypeMap();
    this.buildTImportHeaderRowMap();
    this.buildTRasterPointTypeMap();
    this.buildTRasterPointTransformMap();
    this.buildTSourceTypeMap();

    this.processResults = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var promise = arguments.length > 1 ? arguments[1] : undefined;
      return promise["catch"](function (error) {
        if (_this2._logging && options.query) {
          // eslint-disable-next-line no-console
          console.error(options.query, "\n", error);
        }

        throw error;
      }).then(function (result) {
        var processor = (0,_process_query_results__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(_this2._logging, _this2.updateQueryTimes);
        var processResultsObject = processor(options, _this2._datumEnum, result);
        return processResultsObject;
      });
    }; // return this to allow chaining off of instantiation


    return this;
  }

  _createClass(DbCon, [{
    key: "removeConnection",
    value: function removeConnection(conId) {
      if (conId < 0 || conId >= this.numConnections) {
        var err = {
          msg: "Remove connection id invalid"
        };
        throw err;
      }

      this._client.splice(conId, 1);

      this._sessionId.splice(conId, 1);

      this._numConnections--;
    }
  }, {
    key: "xhrWithCredentials",
    value: function xhrWithCredentials(enabled) {
      CustomXHRConnection.withCredentials = Boolean(enabled);
    }
    /**
     * Initializes the connector for use. This is similar to `connect()`, but stops short of
     * actually connecting to the server.
     *
     * @return {DbCon} Object.
     */

  }, {
    key: "initClients",
    value: function initClients() {
      var allAreArrays = Array.isArray(this._host) && Array.isArray(this._port) && Array.isArray(this._dbName);

      if (!allAreArrays) {
        throw new Error("Host, port, and dbName must be arrays.");
      }

      this._client = [];
      this._sessionId = [];

      if (!this._host[0]) {
        throw new Error("Please enter a host name.");
      } else if (!this._port[0]) {
        throw new Error("Please enter a port.");
      } // now check to see if length of all arrays are the same and > 0


      var hostLength = this._host.length;

      if (hostLength < 1) {
        throw new Error("Must have at least one server to connect to.");
      }

      if (hostLength !== this._port.length) {
        throw new Error("Array connection parameters must be of equal length.");
      }

      if (!this._protocol) {
        this._protocol = this._host.map(function () {
          return process.env.BROWSER ? window.location.protocol.replace(":", "") : "http";
        });
      }

      var transportUrls = this.getEndpoints();
      var clients = [];

      for (var h = 0; h < hostLength; h++) {
        var client = buildClient(transportUrls[h], this._useBinaryProtocol);
        clients.push(client);
      }

      this._client = clients;
      this._numConnections = this._client.length;
      return this;
    }
    /**
     * Create a connection to the MapD server, generating a client and session ID.
     * @return {Promise.DbCon} Object.
     *
     * @example <caption>Connect to a MapD server:</caption>
     * var con = new DbCon()
     *   .host('localhost')
     *   .port('8080')
     *   .dbName('myDatabase')
     *   .user('foo')
     *   .password('bar')
     *   .connect()
     *   .then((con) => console.log(con.sessionId()));
     *
     *   // ["om9E9Ujgbhl6wIzWgLENncjWsaXRDYLy"]
     */

  }, {
    key: "connectAsync",
    value: function connectAsync() {
      var _this3 = this;

      if (!Array.isArray(this._user) || !Array.isArray(this._password)) {
        return Promise.reject("Username and password must be arrays.");
      }

      if (!this._dbName[0]) {
        return Promise.reject("Please enter a database.");
      } else if (!this._user[0]) {
        return Promise.reject("Please enter a username.");
      } else if (!this._password[0]) {
        return Promise.reject("Please enter a password.");
      } // now check to see if length of all arrays are the same and > 0


      var hostLength = this._host.length;

      if (hostLength < 1) {
        return Promise.reject("Must have at least one server to connect to.");
      }

      if (hostLength !== this._port.length || hostLength !== this._user.length || hostLength !== this._password.length || hostLength !== this._dbName.length) {
        return Promise.reject("Array connection parameters must be of equal length.");
      }

      var clients = [];
      this.initClients();
      clients = this._client; // Reset the client property, so we can add only the ones that we can connect to below

      this._client = [];
      return Promise.all(clients.map(function (client, h) {
        return client.connect(_this3._user[h], _this3._password[h], _this3._dbName[h]).then(function (sessionId) {
          _this3._client.push(client);

          _this3._sessionId.push(sessionId);

          return null;
        });
      })).then(function () {
        return _this3;
      });
    }
    /**
     * Create a connection to the MapD server, generating a client and session ID.
     * @param {Function} callback An optional callback that takes `(err, success)` as its signature.  Returns con singleton if successful.
     * @return {Promise.DbCon} Object.
     *
     * @example <caption>Connect to a MapD server:</caption>
     * var con = new DbCon()
     *   .host('localhost')
     *   .port('8080')
     *   .dbName('myDatabase')
     *   .user('foo')
     *   .password('bar')
     *   .connect((err, con) => console.log(con.sessionId()));
     *
     *   // ["om9E9Ujgbhl6wIzWgLENncjWsaXRDYLy"]
     */

  }, {
    key: "convertFromThriftTypes",
    value: function convertFromThriftTypes(fields) {
      var fieldsArray = []; // silly to change this from map to array
      // - then later it turns back to map

      for (var key in fields) {
        if (fields.hasOwnProperty(key)) {
          fieldsArray.push({
            name: key,
            type: this._datumEnum[fields[key].col_type.type],
            precision: fields[key].col_type.precision,
            is_array: fields[key].col_type.is_array,
            is_dict: fields[key].col_type.encoding === _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TEncodingType.DICT // eslint-disable-line no-undef

          });
        }
      }

      return fieldsArray;
    }
    /**
     * Disconnect from the server and then clear the client and session values.
     * @return {Promise.DbCon} Object.
     *
     * @example <caption>Disconnect from the server:</caption>
     *
     * con.disconnect()
     */

  }, {
    key: "invertDatumTypes",

    /**
     * Create an array-like object from {@link TDatumType} by
     * changing the order of the string key and numerical value.
     *
     * @returns {Undefined} This function does not return anything.
     */
    value: function invertDatumTypes() {
      var datumType = _thrift_common_types_js__WEBPACK_IMPORTED_MODULE_3__.TDatumType; // eslint-disable-line no-undef

      for (var key in datumType) {
        if (datumType.hasOwnProperty(key)) {
          this._datumEnum[datumType[key]] = key;
        }
      }
    }
    /**
     * Get a list of field objects for a specified table.
     * @param {String} tableName Name of table containing field names.
     * @return {Promise.Array<Object>} The formatted list of field objects.
     *
     * @example <caption>Get the list of fields from a specific table:</caption>
     *
     * con.getFields('flights', (err, res) => console.log(res))
     * // [{
     *   name: 'fieldName',
     *   type: 'BIGINT',
     *   is_array: false,
     *   is_dict: false
     * }, ...]
     */

  }, {
    key: "importTableAsyncWrapper",
    value: function importTableAsyncWrapper(isShapeFile) {
      return isShapeFile ? this.importTableGeoAsync.bind(this) : this.importTableAsync.bind(this);
    }
  }, {
    key: "importTable",
    value: function importTable(tableName, fileName, copyParams, rowDescObj, isShapeFile, callback) {
      if (isShapeFile) {
        var func = this.callbackify("importTableGeoAsync", 4);
        return func(tableName, fileName, copyParams, rowDescObj, callback);
      } else {
        var _func = this.callbackify("importTableAsync", 3);

        return _func(tableName, fileName, copyParams, callback);
      }
    }
    /**
     * Use for backend rendering. This method fetches a PNG image that is a
     * render of the Vega JSON object. The Image will be a string if using
     * browser-connector.js, or a Buffer otherwise.
     *
     * @param {Number} widgetid The widget ID of the calling widget.
     * @param {String} vega The Vega JSON.
     * @param {Object} options The options for the render query.
     * @param {Number} options.compressionLevel The PNG compression level.
     *                  Range: 1 (low compression, faster) to 10 (high compression, slower).
     *                  Default: 3.
     * @returns {Promise.Image} Base64 image.
     */

  }, {
    key: "sessionId",
    // ** Configuration methods **

    /**
     * Get or set the session ID used by the server to serve the correct data.
     * This is typically set by {@link connect} and should not be set manually.
     * @param {Number} sessionId The session ID of the current connection.
     * @return {Number|DbCon} - The session ID or MapD connector itself.
     *
     * @example <caption>Get the session ID:</caption>
     *
     *  con.sessionId();
     * // sessionID === 3145846410
     *
     * @example <caption>Set the session ID:</caption>
     * var con = new DbCon().connect().sessionId(3415846410);
     * // NOTE: It is generally unsafe to set the session ID manually.
     */
    value: function sessionId(_sessionId) {
      if (!arguments.length) {
        return this._sessionId;
      }

      this._sessionId = arrayify(_sessionId);
      return this;
    }
  }, {
    key: "useBinaryProtocol",
    value: function useBinaryProtocol(use) {
      if (!arguments.length) {
        return this._useBinaryProtocol;
      }

      this._useBinaryProtocol = Boolean(use);
      return this;
    }
    /**
     * Get or set the connection server hostname.
     * This is is typically the first method called after instantiating a new DbCon.
     * @param {String} host The hostname address.
     * @return {String|DbCon} The hostname or MapD connector itself.
     *
     * @example <caption>Set the hostname:</caption>
     * var con = new DbCon().host('localhost');
     *
     * @example <caption>Get the hostname:</caption>
     * var host = con.host();
     * // host === 'localhost'
     */

  }, {
    key: "host",
    value: function host(_host) {
      if (!arguments.length) {
        return this._host;
      }

      this._host = arrayify(_host);
      return this;
    }
    /**
     * Get or set the connection port.
     * @param {String} port - The port to connect on.
     * @return {String|DbCon} - The port or MapD connector itself.
     *
     * @example <caption>Set the port:</caption>
     * var con = new DbCon().port('8080');
     *
     * @example <caption>Get the port:</caption>
     * var port = con.port();
     * // port === '8080'
     */

  }, {
    key: "port",
    value: function port(_port) {
      if (!arguments.length) {
        return this._port;
      }

      this._port = arrayify(_port);
      return this;
    }
    /**
     * Get or set the username with which to authenticate.
     * @param {String} user - The username with which to authenticate.
     * @return {String|DbCon} - The username or MapD connector itself.
     *
     * @example <caption>Set the username:</caption>
     * var con = new DbCon().user('foo');
     *
     * @example <caption>Get the username:</caption>
     * var username = con.user();
     * // user === 'foo'
     */

  }, {
    key: "user",
    value: function user(_user) {
      if (!arguments.length) {
        return this._user;
      }

      this._user = arrayify(_user);
      return this;
    }
    /**
     * Get or set the user password for authentication.
     * @param {String} password The password with which to authenticate.
     * @return {String|DbCon} The password or MapD connector itself.
     *
     * @example <caption>Set the password:</caption>
     * var con = new DbCon().password('bar');
     *
     * @example <caption>Get the username:</caption>
     * var password = con.password();
     * // password === 'bar'
     */

  }, {
    key: "password",
    value: function password(_password) {
      if (!arguments.length) {
        return this._password;
      }

      this._password = arrayify(_password);
      return this;
    }
    /**
     * Get or set the name of the database to connect to.
     * @param {String} dbName - The database to connect to.
     * @return {String|DbCon} - The name of the database or the MapD connector itself.
     *
     * @example <caption>Set the database name:</caption>
     * var con = new DbCon().dbName('myDatabase');
     *
     * @example <caption>Get the database name:</caption>
     * var dbName = con.dbName();
     * // dbName === 'myDatabase'
     */

  }, {
    key: "dbName",
    value: function dbName(_dbName) {
      if (!arguments.length) {
        return this._dbName;
      }

      this._dbName = arrayify(_dbName);
      return this;
    }
    /**
     * Configure whether raw query strings are logged to the console.
     * Used primarily for debugging; `false` by default.
     * @param {Boolean} logging Set to true to enable logging.
     * @return {Boolean|DbCon} The current logging flag or MapD connector itself.
     *
     * @example <caption>Set logging to true:</caption>
     * var con = new DbCon().logging(true);
     *
     * @example <caption>Get the logging flag:</caption>
     * var isLogging = con.logging();
     * // isLogging === true
     */

  }, {
    key: "logging",
    value: function logging(_logging) {
      if (typeof _logging === "undefined") {
        return this._logging;
      } else if (typeof _logging !== "boolean") {
        return "logging can only be set with boolean values";
      }

      this._logging = _logging;
      var isEnabledTxt = _logging ? "enabled" : "disabled";
      return "SQL logging is now ".concat(isEnabledTxt);
    }
    /**
     * The name of the platform.
     * @param {String} platform The platform; "heavydb" by default.
     * @return {String|DbCon} - The platform or MapD connector itself.
     *
     * @example <caption>Set the platform name:</caption>
     * var con = new DbCon().platform('myPlatform');
     *
     * @example <caption>Get the platform name:</caption>
     * var platform = con.platform();
     * // platform === 'myPlatform'
     */

  }, {
    key: "platform",
    value: function platform(_platform) {
      if (!arguments.length) {
        return this._platform;
      }

      this._platform = _platform;
      return this;
    }
    /**
     * Get the number of connections that are currently open.
     * @return {Number} The number of open connections.
     *
     * @example <caption>Get the number of connections:</caption>
     *
     * var numConnections = con.numConnections();
     * // numConnections === 1
     */

  }, {
    key: "numConnections",
    value: function numConnections() {
      return this._numConnections;
    }
    /**
     * The protocol to use for requests.
     * @param {String} protocol <code>http</code> or <code>https</code>.
     * @return {String|DbCon} The protocol or DbCon itself.
     *
     * @example <caption>Set the protocol:</caption>
     * var con = new DbCon().protocol('http');
     *
     * @example <caption>Get the protocol:</caption>
     * var protocol = con.protocol();
     * // protocol === 'http'
     */

  }, {
    key: "protocol",
    value: function protocol(_protocol) {
      if (!arguments.length) {
        return this._protocol;
      }

      this._protocol = arrayify(_protocol);
      return this;
    }
    /**
     * Disables logic that automatically tries to reconnect to the server if there's an error
     *
     * @param {Boolean?} disable - If true, disables auto-reconnect
     * @return {Boolean|DbCon} The status of auto-reconnect, or DbCon itself.
     */

  }, {
    key: "disableAutoReconnect",
    value: function disableAutoReconnect(disable) {
      if (!arguments.length) {
        return this._disableAutoReconnect;
      }

      this._disableAutoReconnect = disable;
      return this;
    }
    /**
     * Generates a list of endpoints from the connection parameters.
     * @return {Array<String>} List of endpoints.
     *
     * @example <caption>Get the endpoints:</caption>
     * var con = new DbCon().protocol('http').host('localhost').port('8000');
     * var endpoints = con.getEndpoints();
     * // endpoints === [ 'http://localhost:8000' ]
     */

  }, {
    key: "getEndpoints",
    value: function getEndpoints() {
      var _this4 = this;

      return this._host.map(function (host, i) {
        return "".concat(_this4._protocol[i], "://").concat(host, ":").concat(_this4._port[i]);
      });
    }
    /**
     * Set the license for Trial or Enterprise
     * @param {String} key The key to install
     * @param {Object} config Protocol, host and port to connect to
     * @return {Promise.<Object>} Claims or Error.
     */

  }, {
    key: "setLicenseKey",
    value: function setLicenseKey(key, _ref19) {
      var protocol = _ref19.protocol,
          host = _ref19.host,
          port = _ref19.port;

      var client = Array.isArray(this._client) && this._client[0];

      var sessionId = this._sessionId && this._sessionId[0];

      if (!client) {
        var url = "".concat(protocol, "://").concat(host, ":").concat(port);
        client = buildClient(url, this._useBinaryProtocol);
        sessionId = "";
      }

      return client.set_license_key(sessionId, key, this._nonce++);
    }
    /**
     * Get the license for Trial or Enterprise
     * @param {Object} config Protocol, host and port to connect to
     * @return {Promise.<Object>} Claims or Error.
     */

  }, {
    key: "getLicenseClaims",
    value: function getLicenseClaims(_ref20) {
      var protocol = _ref20.protocol,
          host = _ref20.host,
          port = _ref20.port;

      var client = Array.isArray(this._client) && this._client[0];

      var sessionId = this._sessionId && this._sessionId[0];

      if (!client) {
        var url = "".concat(protocol, "://").concat(host, ":").concat(port);
        client = buildClient(url, this._useBinaryProtocol);
        sessionId = "";
      }

      return client.get_license_claims(sessionId, this._nonce++);
    }
  }, {
    key: "isTimeoutError",
    value: function isTimeoutError(result) {
      return result instanceof _thrift_heavy_types_js__WEBPACK_IMPORTED_MODULE_4__.TDBException && (String(result.error_msg).includes("Session not valid") || String(result.error_msg).indexOf("User should re-authenticate.") !== -1);
    }
  }]);

  return DbCon;
}();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DbCon);







/***/ }),

/***/ 2033:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dq": () => /* binding */ convertObjectToThriftCopyParams,
/* harmony export */   "HP": () => /* binding */ mutateThriftRowDesc,
/* harmony export */   "RK": () => /* binding */ timestampToMs,
/* harmony export */   "kS": () => /* binding */ valueToBoolean
/* harmony export */ });
/* harmony import */ var _thrift_heavy_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2607);
/* harmony import */ var _thrift_heavy_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_thrift_heavy_types__WEBPACK_IMPORTED_MODULE_0__);

var convertObjectToThriftCopyParams = function convertObjectToThriftCopyParams(obj) {
  return new _thrift_heavy_types__WEBPACK_IMPORTED_MODULE_0__.TCopyParams(obj);
}; // eslint-disable-line no-undef

var mutateThriftRowDesc = function mutateThriftRowDesc(rowDescArray, thriftRowDescArray) {
  rowDescArray.forEach(function (obj, i) {
    thriftRowDescArray[i].col_name = obj.clean_col_name;
    thriftRowDescArray[i].col_type.encoding = obj.col_type.encoding;
    thriftRowDescArray[i].col_type.precision = obj.col_type.precision;
    thriftRowDescArray[i].col_type.comp_param = obj.col_type.comp_param;
    thriftRowDescArray[i].col_type.scale = obj.col_type.scale;
    thriftRowDescArray[i].col_type.type = obj.col_type.type;
  });
  return thriftRowDescArray;
};
/**
 * Converts a raw integer timestamp value from the DB into milliseconds. The DB timestamp value may
 * represent seconds, ms, us, or ns depending on the precision of the column. This value is
 * truncated or extended as necessary to convert to ms precision. The returned ms value is suitable
 * for passing to the JS Date object constructor.
 * @param {Number} timestamp - The raw integer timestamp in the database.
 * @param {Number} precision - The precision of the timestamp column in the database.
 * @returns {Number} The equivalent timestamp in milliseconds.
 */

function timestampToMs(timestamp, precision) {
  // A precision of 0 = sec, 3 = ms. Thus, this line finds the value to divide the DB val
  // eslint-disable-next-line no-magic-numbers
  var divisor = Math.pow(10, precision - 3);
  var timeInMs = timestamp / divisor;
  return timeInMs;
}
/**
 * Converts a Number/BigInt value to a Boolean
 * @param {BigInt} value - A BigInt value
 * @returns {Boolean} The equivalent boolean value representing the buffer
 */

function valueToBoolean(value) {
  if (value.toNumber) {
    return Boolean(value.toNumber(true));
  }

  return Boolean(value);
}

/***/ }),

/***/ 5141:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => /* binding */ processQueryResults
});

// EXTERNAL MODULE: ./src/helpers.js
var helpers = __webpack_require__(2033);
;// CONCATENATED MODULE: ./src/process-columnar-results.js

/**
 * Process the column-based results from the query in a row-based format.
 * (Returning row-based results directly from the server is inefficient.)
 *
 * @param {TRowSet} data The column-based data returned from a query.
 * @param {Boolean} eliminateNullRows A flag that removes null rows from results.
 * @param {Object} dataEnum A list of types created from when executing {@link #invertDatumTypes}.
 * @returns {Object} The formatted results of the query.
 * @example <caption>Convert data returned in column-based format to row-based:</caption>
 */

function processColumnarResults(data, eliminateNullRows, dataEnum) {
  var formattedResult = {
    fields: [],
    results: []
  };
  var numCols = data.row_desc.length;
  var numRows = typeof data.columns[0] === "undefined" ? 0 : data.columns[0].nulls.length;
  formattedResult.fields = data.row_desc.map(function (field) {
    return {
      name: field.col_name,
      type: dataEnum[field.col_type.type],
      is_array: field.col_type.is_array
    };
  });

  for (var r = 0; r < numRows; r++) {
    if (eliminateNullRows) {
      var rowHasNull = false;

      for (var c = 0; c < numCols; c++) {
        if (data.columns[c].nulls[r]) {
          rowHasNull = true;
          break;
        }
      }

      if (rowHasNull) {
        continue; // eslint-disable-line no-continue
      }
    }

    var row = {};

    for (var _c = 0; _c < numCols; _c++) {
      var fieldName = formattedResult.fields[_c].name;
      var fieldType = formattedResult.fields[_c].type;
      var fieldIsArray = formattedResult.fields[_c].is_array;
      var isNull = data.columns[_c].nulls[r];
      var fieldPrecision = data.row_desc[_c].col_type.precision;

      if (isNull) {
        // row[fieldName] = "NULL";
        row[fieldName] = null;
        continue; // eslint-disable-line no-continue
      }

      if (fieldIsArray) {
        row[fieldName] = [];
        var arrayNumElems = data.columns[_c].data.arr_col[r].nulls.length;

        for (var e = 0; e < arrayNumElems; e++) {
          if (data.columns[_c].data.arr_col[r].nulls[e]) {
            row[fieldName].push("NULL");
            continue; // eslint-disable-line no-continue
          }

          switch (fieldType) {
            case "BOOL":
              row[fieldName].push((0,helpers/* valueToBoolean */.kS)(data.columns[_c].data.arr_col[r].data.int_col[e]));
              break;

            case "SMALLINT":
            case "INT":
            case "BIGINT":
            case "TINYINT":
              row[fieldName].push(data.columns[_c].data.arr_col[r].data.int_col[e]);
              break;

            case "FLOAT":
            case "DOUBLE":
            case "DECIMAL":
              row[fieldName].push(data.columns[_c].data.arr_col[r].data.real_col[e]);
              break;

            case "STR":
              row[fieldName].push(data.columns[_c].data.arr_col[r].data.str_col[e]);
              break;

            case "TIME":
            case "TIMESTAMP":
            case "DATE":
              var timeInMs = (0,helpers/* timestampToMs */.RK)(data.columns[_c].data.int_col[r], fieldPrecision);
              row[fieldName].push(timeInMs);
              break;

            default:
              throw new Error("Unrecognized array field type: ".concat(fieldType));
          }
        }
      } else {
        // Not an array
        switch (fieldType) {
          case "BOOL":
            row[fieldName] = (0,helpers/* valueToBoolean */.kS)(data.columns[_c].data.int_col[r]);
            break;

          case "SMALLINT":
          case "INT":
          case "BIGINT":
          case "TINYINT":
            row[fieldName] = data.columns[_c].data.int_col[r];
            break;

          case "FLOAT":
          case "DOUBLE":
          case "DECIMAL":
            row[fieldName] = data.columns[_c].data.real_col[r];
            break;

          case "STR":
            row[fieldName] = data.columns[_c].data.str_col[r];
            break;

          case "TIME":
          case "TIMESTAMP":
          case "DATE":
            var _timeInMs = (0,helpers/* timestampToMs */.RK)(data.columns[_c].data.int_col[r], fieldPrecision);

            row[fieldName] = new Date(_timeInMs);
            break;

          case "POINT":
          case "LINESTRING":
          case "MULTILINESTRING":
          case "POLYGON":
          case "MULTIPOLYGON":
            row[fieldName] = data.columns[_c].data.str_col[r];
            break;

          default:
            throw new Error("Unrecognized field type: ".concat(fieldType));
        }
      }
    }

    formattedResult.results.push(row);
  }

  return formattedResult;
}
;// CONCATENATED MODULE: ./src/process-row-results.js

/**
 * Query for row-based results from the server. In general, is inefficient and should be
 * avoided. Instead, use {@link processColumnarResults} and then convert the results to
 * row-based format.
 * @param {TRowSet} data - The row-based data returned from a query.
 * @param {Boolean} eliminateNullRows Flag that removes null rows from results.
 * @param {Object} datumEnum A list of types created from when executing {@link #invertDatumTypes}.
 * @returns {Object} The formatted results of the query.
 * @example<caption> Return row-based results directly from the server:
 */

function processRowResults(data, eliminateNullRows, datumEnum) {
  var numCols = data.row_desc.length;
  var formattedResult = {
    fields: [],
    results: []
  };
  formattedResult.fields = data.row_desc.map(function (field) {
    return {
      name: field.col_name,
      type: datumEnum[field.col_type.type],
      is_array: field.col_type.is_array
    };
  });
  formattedResult.results = [];
  var numRows = 0;

  if (typeof data.rows !== "undefined" && data.rows !== null) {
    numRows = data.rows.length; // so won't throw if data.rows is missing
  }

  for (var r = 0; r < numRows; r++) {
    if (eliminateNullRows) {
      var rowHasNull = false;

      for (var c = 0; c < numCols; c++) {
        if (data.rows[r].columns[c].is_null) {
          rowHasNull = true;
          break;
        }
      }

      if (rowHasNull) {
        continue; // eslint-disable-line no-continue
      }
    }

    var row = {};

    for (var _c = 0; _c < numCols; _c++) {
      var fieldName = formattedResult.fields[_c].name;
      var fieldType = formattedResult.fields[_c].type;
      var fieldIsArray = formattedResult.fields[_c].is_array;
      var fieldPrecision = data.row_desc[_c].col_type.precision;

      if (fieldIsArray) {
        if (data.rows[r].cols[_c].is_null) {
          row[fieldName] = "NULL";
          continue; // eslint-disable-line no-continue
        }

        row[fieldName] = [];
        var arrayNumElems = data.rows[r].cols[_c].val.arr_val.length;

        for (var e = 0; e < arrayNumElems; e++) {
          var elemDatum = data.rows[r].cols[_c].val.arr_val[e];

          if (elemDatum.is_null) {
            row[fieldName].push("NULL");
            continue; // eslint-disable-line no-continue
          }

          switch (fieldType) {
            case "BOOL":
              row[fieldName].push((0,helpers/* valueToBoolean */.kS)(elemDatum.val.int_val));
              break;

            case "SMALLINT":
            case "INT":
            case "BIGINT":
            case "TINYINT":
              row[fieldName].push(elemDatum.val.int_val);
              break;

            case "FLOAT":
            case "DOUBLE":
            case "DECIMAL":
              row[fieldName].push(elemDatum.val.real_val);
              break;

            case "STR":
              row[fieldName].push(elemDatum.val.str_val);
              break;

            case "TIME":
            case "TIMESTAMP":
            case "DATE":
              var timeInMs = (0,helpers/* timestampToMs */.RK)(elemDatum.val.int_val, fieldPrecision);
              row[fieldName].push(timeInMs);
              break;

            default:
              throw new Error("Unrecognized array field type: ".concat(fieldType));
          }
        }
      } else {
        var scalarDatum = data.rows[r].cols[_c];

        if (scalarDatum.is_null) {
          row[fieldName] = "NULL";
          continue; // eslint-disable-line no-continue
        }

        switch (fieldType) {
          case "BOOL":
            row[fieldName] = (0,helpers/* valueToBoolean */.kS)(scalarDatum.val.int_val);
            break;

          case "SMALLINT":
          case "INT":
          case "BIGINT":
          case "TINYINT":
            row[fieldName] = scalarDatum.val.int_val;
            break;

          case "FLOAT":
          case "DOUBLE":
          case "DECIMAL":
            row[fieldName] = scalarDatum.val.real_val;
            break;

          case "STR":
            row[fieldName] = scalarDatum.val.str_val;
            break;

          case "TIME":
          case "TIMESTAMP":
          case "DATE":
            var _timeInMs = (0,helpers/* timestampToMs */.RK)(scalarDatum.val.int_val, fieldPrecision);

            row[fieldName] = new Date(_timeInMs);
            break;

          case "POINT":
          case "LINESTRING":
          case "MULTILINESTRING":
          case "POLYGON":
          case "MULTIPOLYGON":
            row[fieldName] = scalarDatum.val.str_val;
            break;

          default:
            throw new Error("Unrecognized field type: ".concat(fieldType));
        }
      }
    }

    formattedResult.results.push(row);
  }

  return formattedResult;
}
;// CONCATENATED MODULE: ./src/process-query-results.js


/**
 * Determines how to process raw results when they return from the server.
 *
 * @param {Boolean} logging If enabled, shows on the console how long the query took to run.
 * @param {Function} updateQueryTimes A function that updates internal query times on the connector.
 * @param {Object} options A list of options for processing the results.
 * @param {Boolean} options.isImage Set to true when querying for backend-rendered images.
 * @param {Boolean} options.eliminateNullRows Removes null rows.
 * @param {String} options.query The SQL query string used only for logging.
 * @param {Number} options.queryId The ID of the query.
 * @param {Number} options.conId The unique connector identification.
 * @param {String} options.estimatedQueryTime The estimate of the query time.
 * @param {Object} result - The query result used to decide whether to process
 *                          as column or row results.
 * @return {Object} result if image, otherwise formatted results.
 */

function processQueryResults(logging, updateQueryTimes) {
  return function (options, _datumEnum, result) {
    var isImage = false;
    var eliminateNullRows = false;
    var query = null;
    var queryId = null;
    var conId = null;
    var estimatedQueryTime = null;

    if (typeof options !== "undefined") {
      isImage = options.isImage ? options.isImage : false;
      eliminateNullRows = options.eliminateNullRows ? options.eliminateNullRows : false;
      query = options.query ? options.query : null;
      queryId = options.queryId ? options.queryId : null;
      conId = typeof options.conId === "undefined" ? null : options.conId;
      estimatedQueryTime = typeof options.estimatedQueryTime === "undefined" ? null : options.estimatedQueryTime;
    }

    if (result.execution_time_ms && conId !== null && estimatedQueryTime !== null) {
      updateQueryTimes(conId, queryId, estimatedQueryTime, result.execution_time_ms);
    } // should use node_env


    if (logging && result.execution_time_ms) {
      // eslint-disable-next-line no-console
      console.log(query, "on Server", conId, "- Execution Time:", result.execution_time_ms, "ms, Total Time:", result.total_time_ms, "ms, Real Time:", options.startTime ? Date.now() - options.startTime : undefined, "ms");
    }

    if (isImage) {
      return result;
    } else {
      var formattedResult = null;

      if (!result.row_set) {
        throw new Error("No result to process");
      }

      if (result.row_set.is_columnar) {
        formattedResult = processColumnarResults(result.row_set, eliminateNullRows, _datumEnum);
      } else {
        formattedResult = processRowResults(result.row_set, eliminateNullRows, _datumEnum);
      }

      formattedResult.timing = {
        execution_time_ms: result.execution_time_ms,
        total_time_ms: result.total_time_ms
      };
      return options.returnTiming ? formattedResult : formattedResult.results;
    }
  };
}

/***/ }),

/***/ 3818:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global window self */

var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

/* eslint-disable no-restricted-globals */
var isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';
/* eslint-enable no-restricted-globals */

var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

/**
 * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0
 * @see https://github.com/jsdom/jsdom/issues/1537
 */
/* eslint-disable no-undef */
var isJsDom = function isJsDom() {
  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');
};

exports.isBrowser = isBrowser;
exports.isWebWorker = isWebWorker;
exports.isNode = isNode;
exports.isJsDom = isJsDom;

/***/ }),

/***/ 6729:
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ 7030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(8777);

/***/ }),

/***/ 135:
/***/ ((module) => {

//     Int64.js
//
//     Copyright (c) 2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

/**
 * Support for handling 64-bit int numbers in Javascript (node.js)
 *
 * JS Numbers are IEEE-754 binary double-precision floats, which limits the
 * range of values that can be represented with integer precision to:
 *
 * 2^^53 <= N <= 2^53
 *
 * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These
 * objects operate directly on the buffer which means that if they are created
 * using an existing buffer then setting the value will modify the Buffer, and
 * vice-versa.
 *
 * Internal Representation
 *
 * The internal buffer format is Big Endian.  I.e. the most-significant byte is
 * at buffer[0], the least-significant at buffer[7].  For the purposes of
 * converting to/from JS native numbers, the value is assumed to be a signed
 * integer stored in 2's complement form.
 *
 * For details about IEEE-754 see:
 * http://en.wikipedia.org/wiki/Double_precision_floating-point_format
 */

// Useful masks and values for bit twiddling
var MASK31 =  0x7fffffff, VAL31 = 0x80000000;
var MASK32 =  0xffffffff, VAL32 = 0x100000000;

// Map for converting hex octets to strings
var _HEX = [];
for (var i = 0; i < 256; i++) {
  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);
}

//
// Int64
//

/**
 * Constructor accepts any of the following argument types:
 *
 * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset
 * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset
 * new Int64(string)             - Hex string (throws if n is outside int64 range)
 * new Int64(number)             - Number (throws if n is outside int64 range)
 * new Int64(hi, lo)             - Raw bits as two 32-bit values
 */
var Int64 = module.exports = function(a1, a2) {
  if (a1 instanceof Buffer) {
    this.buffer = a1;
    this.offset = a2 || 0;
  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {
    // Under Browserify, Buffers can extend Uint8Arrays rather than an
    // instance of Buffer. We could assume the passed in Uint8Array is actually
    // a buffer but that won't handle the case where a raw Uint8Array is passed
    // in. We construct a new Buffer just in case.
    this.buffer = new Buffer(a1);
    this.offset = a2 || 0;
  } else {
    this.buffer = this.buffer || new Buffer(8);
    this.offset = 0;
    this.setValue.apply(this, arguments);
  }
};


// Max integer value that JS can accurately represent
Int64.MAX_INT = Math.pow(2, 53);

// Min integer value that JS can accurately represent
Int64.MIN_INT = -Math.pow(2, 53);

Int64.prototype = {

  constructor: Int64,

  /**
   * Do in-place 2's compliment.  See
   * http://en.wikipedia.org/wiki/Two's_complement
   */
  _2scomp: function() {
    var b = this.buffer, o = this.offset, carry = 1;
    for (var i = o + 7; i >= o; i--) {
      var v = (b[i] ^ 0xff) + carry;
      b[i] = v & 0xff;
      carry = v >> 8;
    }
  },

  /**
   * Set the value. Takes any of the following arguments:
   *
   * setValue(string) - A hexidecimal string
   * setValue(number) - Number (throws if n is outside int64 range)
   * setValue(hi, lo) - Raw bits as two 32-bit values
   */
  setValue: function(hi, lo) {
    var negate = false;
    if (arguments.length == 1) {
      if (typeof(hi) == 'number') {
        // Simplify bitfield retrieval by using abs() value.  We restore sign
        // later
        negate = hi < 0;
        hi = Math.abs(hi);
        lo = hi % VAL32;
        hi = hi / VAL32;
        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');
        hi = hi | 0;
      } else if (typeof(hi) == 'string') {
        hi = (hi + '').replace(/^0x/, '');
        lo = hi.substr(-8);
        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';
        hi = parseInt(hi, 16);
        lo = parseInt(lo, 16);
      } else {
        throw new Error(hi + ' must be a Number or String');
      }
    }

    // Technically we should throw if hi or lo is outside int32 range here, but
    // it's not worth the effort. Anything past the 32'nd bit is ignored.

    // Copy bytes to buffer
    var b = this.buffer, o = this.offset;
    for (var i = 7; i >= 0; i--) {
      b[o+i] = lo & 0xff;
      lo = i == 4 ? hi : lo >>> 8;
    }

    // Restore sign of passed argument
    if (negate) this._2scomp();
  },

  /**
   * Convert to a native JS number.
   *
   * WARNING: Do not expect this value to be accurate to integer precision for
   * large (positive or negative) numbers!
   *
   * @param allowImprecise If true, no check is performed to verify the
   * returned value is accurate to integer precision.  If false, imprecise
   * numbers (very large positive or negative numbers) will be forced to +/-
   * Infinity.
   */
  toNumber: function(allowImprecise) {
    var b = this.buffer, o = this.offset;

    // Running sum of octets, doing a 2's complement
    var negate = b[o] & 0x80, x = 0, carry = 1;
    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {
      var v = b[o+i];

      // 2's complement for negative numbers
      if (negate) {
        v = (v ^ 0xff) + carry;
        carry = v >> 8;
        v = v & 0xff;
      }

      x += v * m;
    }

    // Return Infinity if we've lost integer precision
    if (!allowImprecise && x >= Int64.MAX_INT) {
      return negate ? -Infinity : Infinity;
    }

    return negate ? -x : x;
  },

  /**
   * Convert to a JS Number. Returns +/-Infinity for values that can't be
   * represented to integer precision.
   */
  valueOf: function() {
    return this.toNumber(false);
  },

  /**
   * Return string value
   *
   * @param radix Just like Number#toString()'s radix
   */
  toString: function(radix) {
    return this.valueOf().toString(radix || 10);
  },

  /**
   * Return a string showing the buffer octets, with MSB on the left.
   *
   * @param sep separator string. default is '' (empty string)
   */
  toOctetString: function(sep) {
    var out = new Array(8);
    var b = this.buffer, o = this.offset;
    for (var i = 0; i < 8; i++) {
      out[i] = _HEX[b[o+i]];
    }
    return out.join(sep || '');
  },

  /**
   * Returns the int64's 8 bytes in a buffer.
   *
   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if
   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.
   */
  toBuffer: function(rawBuffer) {
    if (rawBuffer && this.offset === 0) return this.buffer;

    var out = new Buffer(8);
    this.buffer.copy(out, 0, this.offset, this.offset + 8);
    return out;
  },

  /**
   * Copy 8 bytes of int64 into target buffer at target offset.
   *
   * @param {Buffer} targetBuffer       Buffer to copy into.
   * @param {number} [targetOffset=0]   Offset into target buffer.
   */
  copy: function(targetBuffer, targetOffset) {
    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
  },

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other in sort order.
   *
   * @param {Int64} other  Other Int64 to compare.
   */
  compare: function(other) {

    // If sign bits differ ...
    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {
      return other.buffer[other.offset] - this.buffer[this.offset];
    }

    // otherwise, compare bytes lexicographically
    for (var i = 0; i < 8; i++) {
      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {
        return this.buffer[this.offset+i] - other.buffer[other.offset+i];
      }
    }
    return 0;
  },

  /**
   * Returns a boolean indicating if this integer is equal to other.
   *
   * @param {Int64} other  Other Int64 to compare.
   */
  equals: function(other) {
    return this.compare(other) === 0;
  },

  /**
   * Pretty output in console.log
   */
  inspect: function() {
    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';
  }
};


/***/ }),

/***/ 8486:
/***/ ((module) => {

// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (true) {
        module.exports = definition();

    // RequireJS
    } else { var previousQ, global; }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.toString()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
    obj[prop] = descriptor.value;
    return obj;
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
                object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error, "stack", {value: stack, configurable: true});
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * The counter is used to determine the stopping point for building
 * long stack traces. In makeStackTraceLong we walk backwards through
 * the linked list of promises, only stacks which were created before
 * the rejection are concatenated.
 */
var longStackCounter = 1;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            promise.stackCounter = longStackCounter++;
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;

        if (Q.longStackSupport && hasStacks) {
            // Only hold a reference to the new promise if long stacks
            // are enabled to reduce memory usage
            promise.source = newPromise;
        }

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Q can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected(err) {
            pendingCount--;
            if (pendingCount === 0) {
                var rejection = err || new Error("" + err);

                rejection.message = ("Q can't get fulfillment value from any promise, all " +
                    "promises were rejected. Last error message: " + rejection.message);

                deferred.reject(rejection);
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
    }
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    if (callback === undefined) {
        throw new Error("Q can't wrap an undefined function");
    }
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});


/***/ }),

/***/ 7533:
/***/ ((__unused_webpack_module, exports) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var POW_8 = Math.pow(2, 8);
var POW_16 = Math.pow(2, 16);
var POW_24 = Math.pow(2, 24);
var POW_32 = Math.pow(2, 32);
var POW_40 = Math.pow(2, 40);
var POW_48 = Math.pow(2, 48);
var POW_52 = Math.pow(2, 52);
var POW_1022 = Math.pow(2, 1022);

exports.readByte = function(b){
	return b > 127 ? b-256 : b;
};

exports.readI16 = function(buff, off) {
  off = off || 0;
  var v = buff[off + 1];
  v += buff[off] << 8;
  if (buff[off] & 128) {
    v -= POW_16;
  }
  return v;
};

exports.readI32 = function(buff, off) {
  off = off || 0;
  var v = buff[off + 3];
  v += buff[off + 2] << 8;
  v += buff[off + 1] << 16;
  v += buff[off] * POW_24;
  if (buff[off] & 0x80) {
    v -= POW_32;
  }
  return v;
};

exports.writeI16 = function(buff, v) {
  buff[1] = v & 0xff;
  v >>= 8;
  buff[0] = v & 0xff;
  return buff;
};

exports.writeI32 = function(buff, v) {
  buff[3] = v & 0xff;
  v >>= 8;
  buff[2] = v & 0xff;
  v >>= 8;
  buff[1] = v & 0xff;
  v >>= 8;
  buff[0] = v & 0xff;
  return buff;
};

exports.readDouble = function(buff, off) {
  off = off || 0;
  var signed = buff[off] & 0x80;
  var e = (buff[off+1] & 0xF0) >> 4;
  e += (buff[off] & 0x7F) << 4;

  var m = buff[off+7];
  m += buff[off+6] << 8;
  m += buff[off+5] << 16;
  m += buff[off+4] * POW_24;
  m += buff[off+3] * POW_32;
  m += buff[off+2] * POW_40;
  m += (buff[off+1] & 0x0F) * POW_48;

  switch (e) {
    case 0:
      e = -1022;
      break;
    case 2047:
      return m ? NaN : (signed ? -Infinity : Infinity);
    default:
      m += POW_52;
      e -= 1023;
  }

  if (signed) {
    m *= -1;
  }

  return m * Math.pow(2, e - 52);
};

/*
 * Based on code from the jspack module:
 * http://code.google.com/p/jspack/
 */
exports.writeDouble = function(buff, v) {
  var m, e, c;

  buff[0] = (v < 0 ? 0x80 : 0x00);

  v = Math.abs(v);
  if (v !== v) {
    // NaN, use QNaN IEEE format
    m = 2251799813685248;
    e = 2047;
  } else if (v === Infinity) {
    m = 0;
    e = 2047;
  } else {
    e = Math.floor(Math.log(v) / Math.LN2);
    c = Math.pow(2, -e);
    if (v * c < 1) {
      e--;
      c *= 2;
    }

    if (e + 1023 >= 2047)
    {
      // Overflow
      m = 0;
      e = 2047;
    }
    else if (e + 1023 >= 1)
    {
      // Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow
      m = (v*c-1) * POW_52;
      e += 1023;
    }
    else
    {
      // Denormalized - also catches the '0' case, somewhat by chance
      m = (v * POW_1022) * POW_52;
      e = 0;
    }
  }

  buff[1] = (e << 4) & 0xf0;
  buff[0] |= (e >> 4) & 0x7f;

  buff[7] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[6] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[5] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[4] = m & 0xff;
  m >>= 8;
  buff[3] = m & 0xff;
  m >>= 8;
  buff[2] = m & 0xff;
  m >>= 8;
  buff[1] |= m & 0x0f;

  return buff;
};


/***/ }),

/***/ 4711:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var log = __webpack_require__(1291);
var binary = __webpack_require__(7533);
var Int64 = __webpack_require__(135);
var Thrift = __webpack_require__(5406);
var Type = Thrift.Type;

module.exports = TBinaryProtocol;

// JavaScript supports only numeric doubles, therefore even hex values are always signed.
// The largest integer value which can be represented in JavaScript is +/-2^53.
// Bitwise operations convert numbers to 32 bit integers but perform sign extension
// upon assigning values back to variables.
var VERSION_MASK = -65536,   // 0xffff0000
    VERSION_1 = -2147418112, // 0x80010000
    TYPE_MASK = 0x000000ff;

TBinaryProtocol.VERSION_MASK = VERSION_MASK;
TBinaryProtocol.VERSION_1 = VERSION_1;
TBinaryProtocol.TYPE_MASK = TYPE_MASK

function TBinaryProtocol(trans, strictRead, strictWrite) {
  this.trans = trans;
  this.strictRead = (strictRead !== undefined ? strictRead : false);
  this.strictWrite = (strictWrite !== undefined ? strictWrite : true);
  this._seqid = null;
};

TBinaryProtocol.prototype.flush = function() {
  return this.trans.flush();
};

TBinaryProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
    if (this.strictWrite) {
      this.writeI32(VERSION_1 | type);
      this.writeString(name);
      this.writeI32(seqid);
    } else {
      this.writeString(name);
      this.writeByte(type);
      this.writeI32(seqid);
    }
    // Record client seqid to find callback again
    if (this._seqid !== null) {
      log.warning('SeqId already set', { 'name': name });
    } else {
      this._seqid = seqid;
      this.trans.setCurrSeqId(seqid);
    }
};

TBinaryProtocol.prototype.writeMessageEnd = function() {
    if (this._seqid !== null) {
        this._seqid = null;
    } else {
        log.warning('No seqid to unset');
    }
};

TBinaryProtocol.prototype.writeStructBegin = function(name) {
};

TBinaryProtocol.prototype.writeStructEnd = function() {
};

TBinaryProtocol.prototype.writeFieldBegin = function(name, type, id) {
  this.writeByte(type);
  this.writeI16(id);
};

TBinaryProtocol.prototype.writeFieldEnd = function() {
};

TBinaryProtocol.prototype.writeFieldStop = function() {
  this.writeByte(Type.STOP);
};

TBinaryProtocol.prototype.writeMapBegin = function(ktype, vtype, size) {
  this.writeByte(ktype);
  this.writeByte(vtype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeMapEnd = function() {
};

TBinaryProtocol.prototype.writeListBegin = function(etype, size) {
  this.writeByte(etype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeListEnd = function() {
};

TBinaryProtocol.prototype.writeSetBegin = function(etype, size) {
  this.writeByte(etype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeSetEnd = function() {
};

TBinaryProtocol.prototype.writeBool = function(bool) {
  if (bool) {
    this.writeByte(1);
  } else {
    this.writeByte(0);
  }
};

TBinaryProtocol.prototype.writeByte = function(b) {
  this.trans.write(new Buffer([b]));
};

TBinaryProtocol.prototype.writeI16 = function(i16) {
  this.trans.write(binary.writeI16(new Buffer(2), i16));
};

TBinaryProtocol.prototype.writeI32 = function(i32) {
  this.trans.write(binary.writeI32(new Buffer(4), i32));
};

TBinaryProtocol.prototype.writeI64 = function(i64) {
  if (i64.buffer) {
    this.trans.write(i64.buffer);
  } else {
    this.trans.write(new Int64(i64).buffer);
  }
};

TBinaryProtocol.prototype.writeDouble = function(dub) {
  this.trans.write(binary.writeDouble(new Buffer(8), dub));
};

TBinaryProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
  if (typeof(arg) === 'string') {
    this.writeI32(Buffer.byteLength(arg, encoding));
    this.trans.write(new Buffer(arg, encoding));
  } else if ((arg instanceof Buffer) ||
             (Object.prototype.toString.call(arg) == '[object Uint8Array]')) {
    // Buffers in Node.js under Browserify may extend UInt8Array instead of
    // defining a new object. We detect them here so we can write them
    // correctly
    this.writeI32(arg.length);
    this.trans.write(arg);
  } else {
    throw new Error(name + ' called without a string/Buffer argument: ' + arg);
  }
};

TBinaryProtocol.prototype.writeString = function(arg) {
  this.writeStringOrBinary('writeString', 'utf8', arg);
};

TBinaryProtocol.prototype.writeBinary = function(arg) {
  this.writeStringOrBinary('writeBinary', 'binary', arg);
};

TBinaryProtocol.prototype.readMessageBegin = function() {
  var sz = this.readI32();
  var type, name, seqid;

  if (sz < 0) {
    var version = sz & VERSION_MASK;
    if (version != VERSION_1) {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad version in readMessageBegin: " + sz);
    }
    type = sz & TYPE_MASK;
    name = this.readString();
    seqid = this.readI32();
  } else {
    if (this.strictRead) {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "No protocol version header");
    }
    name = this.trans.read(sz);
    type = this.readByte();
    seqid = this.readI32();
  }
  return {fname: name, mtype: type, rseqid: seqid};
};

TBinaryProtocol.prototype.readMessageEnd = function() {
};

TBinaryProtocol.prototype.readStructBegin = function() {
  return {fname: ''};
};

TBinaryProtocol.prototype.readStructEnd = function() {
};

TBinaryProtocol.prototype.readFieldBegin = function() {
  var type = this.readByte();
  if (type == Type.STOP) {
    return {fname: null, ftype: type, fid: 0};
  }
  var id = this.readI16();
  return {fname: null, ftype: type, fid: id};
};

TBinaryProtocol.prototype.readFieldEnd = function() {
};

TBinaryProtocol.prototype.readMapBegin = function() {
  var ktype = this.readByte();
  var vtype = this.readByte();
  var size = this.readI32();
  return {ktype: ktype, vtype: vtype, size: size};
};

TBinaryProtocol.prototype.readMapEnd = function() {
};

TBinaryProtocol.prototype.readListBegin = function() {
  var etype = this.readByte();
  var size = this.readI32();
  return {etype: etype, size: size};
};

TBinaryProtocol.prototype.readListEnd = function() {
};

TBinaryProtocol.prototype.readSetBegin = function() {
  var etype = this.readByte();
  var size = this.readI32();
  return {etype: etype, size: size};
};

TBinaryProtocol.prototype.readSetEnd = function() {
};

TBinaryProtocol.prototype.readBool = function() {
  var b = this.readByte();
  if (b === 0) {
    return false;
  }
  return true;
};

TBinaryProtocol.prototype.readByte = function() {
  return this.trans.readByte();
};

TBinaryProtocol.prototype.readI16 = function() {
  return this.trans.readI16();
};

TBinaryProtocol.prototype.readI32 = function() {
  return this.trans.readI32();
};

TBinaryProtocol.prototype.readI64 = function() {
  var buff = this.trans.read(8);
  return new Int64(buff);
};

TBinaryProtocol.prototype.readDouble = function() {
  return this.trans.readDouble();
};

TBinaryProtocol.prototype.readBinary = function() {
  var len = this.readI32();
  if (len === 0) {
    return new Buffer(0);
  }

  if (len < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative binary size");
  }
  return this.trans.read(len);
};

TBinaryProtocol.prototype.readString = function() {
  var len = this.readI32();
  if (len === 0) {
    return "";
  }

  if (len < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative string size");
  }
  return this.trans.readString(len);
};

TBinaryProtocol.prototype.getTransport = function() {
  return this.trans;
};

TBinaryProtocol.prototype.skip = function(type) {
  switch (type) {
    case Type.BOOL:
      this.readBool();
      break;
    case Type.BYTE:
      this.readByte();
      break;
    case Type.I16:
      this.readI16();
      break;
    case Type.I32:
      this.readI32();
      break;
    case Type.I64:
      this.readI64();
      break;
    case Type.DOUBLE:
      this.readDouble();
      break;
    case Type.STRING:
      this.readString();
      break;
    case Type.STRUCT:
      this.readStructBegin();
      while (true) {
        var r = this.readFieldBegin();
        if (r.ftype === Type.STOP) {
          break;
        }
        this.skip(r.ftype);
        this.readFieldEnd();
      }
      this.readStructEnd();
      break;
    case Type.MAP:
      var mapBegin = this.readMapBegin();
      for (var i = 0; i < mapBegin.size; ++i) {
        this.skip(mapBegin.ktype);
        this.skip(mapBegin.vtype);
      }
      this.readMapEnd();
      break;
    case Type.SET:
      var setBegin = this.readSetBegin();
      for (var i2 = 0; i2 < setBegin.size; ++i2) {
        this.skip(setBegin.etype);
      }
      this.readSetEnd();
      break;
    case Type.LIST:
      var listBegin = this.readListBegin();
      for (var i3 = 0; i3 < listBegin.size; ++i3) {
        this.skip(listBegin.etype);
      }
      this.readListEnd();
      break;
    default:
      throw new  Error("Invalid type: " + type);
  }
};


/***/ }),

/***/ 8869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var binary = __webpack_require__(7533);
var InputBufferUnderrunError = __webpack_require__(3590);
var THeaderTransport = __webpack_require__(5190);

module.exports = TBufferedTransport;

function TBufferedTransport(buffer, callback) {
  this.defaultReadBufferSize = 1024;
  this.writeBufferSize = 512; // Soft Limit
  this.inBuf = new Buffer(this.defaultReadBufferSize);
  this.readCursor = 0;
  this.writeCursor = 0; // for input buffer
  this.outBuffers = [];
  this.outCount = 0;
  this.onFlush = callback;
};

TBufferedTransport.prototype = new THeaderTransport();

TBufferedTransport.prototype.reset = function() {
  this.inBuf = new Buffer(this.defaultReadBufferSize);
  this.readCursor = 0;
  this.writeCursor = 0;
  this.outBuffers = [];
  this.outCount = 0;
}

TBufferedTransport.receiver = function(callback, seqid) {
  var reader = new TBufferedTransport();

  return function(data) {
    if (reader.writeCursor + data.length > reader.inBuf.length) {
      var buf = new Buffer(reader.writeCursor + data.length);
      reader.inBuf.copy(buf, 0, 0, reader.writeCursor);
      reader.inBuf = buf;
    }
    data.copy(reader.inBuf, reader.writeCursor, 0);
    reader.writeCursor += data.length;

    callback(reader, seqid);
  };
};


TBufferedTransport.prototype.commitPosition = function(){
  var unreadSize = this.writeCursor - this.readCursor;
  var bufSize = (unreadSize * 2 > this.defaultReadBufferSize) ?
    unreadSize * 2 : this.defaultReadBufferSize;
  var buf = new Buffer(bufSize);
  if (unreadSize > 0) {
    this.inBuf.copy(buf, 0, this.readCursor, this.writeCursor);
  }
  this.readCursor = 0;
  this.writeCursor = unreadSize;
  this.inBuf = buf;
};

TBufferedTransport.prototype.rollbackPosition = function(){
  this.readCursor = 0;
}

  // TODO: Implement open/close support
TBufferedTransport.prototype.isOpen = function() {
  return true;
};

TBufferedTransport.prototype.open = function() {
};

TBufferedTransport.prototype.close = function() {
};

  // Set the seqid of the message in the client
  // So that callbacks can be found
TBufferedTransport.prototype.setCurrSeqId = function(seqid) {
  this._seqid = seqid;
};

TBufferedTransport.prototype.ensureAvailable = function(len) {
  if (this.readCursor + len > this.writeCursor) {
    throw new InputBufferUnderrunError();
  }
};

TBufferedTransport.prototype.read = function(len) {
  this.ensureAvailable(len);
  var buf = new Buffer(len);
  this.inBuf.copy(buf, 0, this.readCursor, this.readCursor + len);
  this.readCursor += len;
  return buf;
};

TBufferedTransport.prototype.readByte = function() {
  this.ensureAvailable(1);
  return binary.readByte(this.inBuf[this.readCursor++]);
};

TBufferedTransport.prototype.readI16 = function() {
  this.ensureAvailable(2);
  var i16 = binary.readI16(this.inBuf, this.readCursor);
  this.readCursor += 2;
  return i16;
};

TBufferedTransport.prototype.readI32 = function() {
  this.ensureAvailable(4);
  var i32 = binary.readI32(this.inBuf, this.readCursor);
  this.readCursor += 4;
  return i32;
};

TBufferedTransport.prototype.readDouble = function() {
  this.ensureAvailable(8);
  var d = binary.readDouble(this.inBuf, this.readCursor);
  this.readCursor += 8;
  return d;
};

TBufferedTransport.prototype.readString = function(len) {
  this.ensureAvailable(len);
  var str = this.inBuf.toString('utf8', this.readCursor, this.readCursor + len);
  this.readCursor += len;
  return str;
};

TBufferedTransport.prototype.borrow = function() {
  var obj = {buf: this.inBuf, readIndex: this.readCursor, writeIndex: this.writeCursor};
  return obj;
};

TBufferedTransport.prototype.consume = function(bytesConsumed) {
  this.readCursor += bytesConsumed;
};

TBufferedTransport.prototype.write = function(buf) {
  if (typeof(buf) === "string") {
    buf = new Buffer(buf, 'utf8');
  }
  this.outBuffers.push(buf);
  this.outCount += buf.length;
};

TBufferedTransport.prototype.flush = function() {
  // If the seqid of the callback is available pass it to the onFlush
  // Then remove the current seqid
  var seqid = this._seqid;
  this._seqid = null;

  if (this.outCount < 1) {
    return;
  }

  var msg = new Buffer(this.outCount),
      pos = 0;
  this.outBuffers.forEach(function(buf) {
    buf.copy(msg, pos, 0);
    pos += buf.length;
  });

  if (this.onFlush) {
    // Passing seqid through this call to get it to the connection
    this.onFlush(msg, seqid);
  }

  this.outBuffers = [];
  this.outCount = 0;
}


/***/ }),

/***/ 9277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var log = __webpack_require__(1291);
var Int64 = __webpack_require__(135);
var Thrift = __webpack_require__(5406);
var Type = Thrift.Type;

module.exports = TCompactProtocol;

var POW_8 = Math.pow(2, 8);
var POW_24 = Math.pow(2, 24);
var POW_32 = Math.pow(2, 32);
var POW_40 = Math.pow(2, 40);
var POW_48 = Math.pow(2, 48);
var POW_52 = Math.pow(2, 52);
var POW_1022 = Math.pow(2, 1022);

/**
 * Constructor Function for the Compact Protocol.
 * @constructor
 * @param {object} [trans] - The underlying transport to read/write.
 * @classdesc The Apache Thrift Protocol layer performs serialization
 *     of base types, the compact protocol serializes data in binary
 *     form with minimal space used for scalar values.
 */
function TCompactProtocol(trans) {
  this.trans = trans;
  this.lastField_ = [];
  this.lastFieldId_ = 0;
  this.string_limit_ = 0;
  this.string_buf_ = null;
  this.string_buf_size_ = 0;
  this.container_limit_ = 0;
  this.booleanField_ = {
    name: null,
    hasBoolValue: false
  };
  this.boolValue_ = {
    hasBoolValue: false,
    boolValue: false
  };
};


//
// Compact Protocol Constants
//

/**
  * Compact Protocol ID number.
  * @readonly
  * @const {number} PROTOCOL_ID
  */
TCompactProtocol.PROTOCOL_ID = -126;  //1000 0010

/**
  * Compact Protocol version number.
  * @readonly
  * @const {number} VERSION_N
  */
TCompactProtocol.VERSION_N = 1;

/**
  * Compact Protocol version mask for combining protocol version and message type in one byte.
  * @readonly
  * @const {number} VERSION_MASK
  */
TCompactProtocol.VERSION_MASK = 0x1f; //0001 1111

/**
  * Compact Protocol message type mask for combining protocol version and message type in one byte.
  * @readonly
  * @const {number} TYPE_MASK
  */
TCompactProtocol.TYPE_MASK = -32;     //1110 0000

/**
  * Compact Protocol message type bits for ensuring message type bit size.
  * @readonly
  * @const {number} TYPE_BITS
  */
TCompactProtocol.TYPE_BITS = 7; //0000 0111

/**
  * Compact Protocol message type shift amount for combining protocol version and message type in one byte.
  * @readonly
  * @const {number} TYPE_SHIFT_AMOUNT
  */
TCompactProtocol.TYPE_SHIFT_AMOUNT = 5;

/**
 * Compact Protocol type IDs used to keep type data within one nibble.
 * @readonly
 * @property {number}  CT_STOP          - End of a set of fields.
 * @property {number}  CT_BOOLEAN_TRUE  - Flag for Boolean field with true value (packed field and value).
 * @property {number}  CT_BOOLEAN_FALSE - Flag for Boolean field with false value (packed field and value).
 * @property {number}  CT_BYTE          - Signed 8 bit integer.
 * @property {number}  CT_I16           - Signed 16 bit integer.
 * @property {number}  CT_I32           - Signed 32 bit integer.
 * @property {number}  CT_I64           - Signed 64 bit integer (2^53 max in JavaScript).
 * @property {number}  CT_DOUBLE        - 64 bit IEEE 854 floating point.
 * @property {number}  CT_BINARY        - Array of bytes (used for strings also).
 * @property {number}  CT_LIST          - A collection type (unordered).
 * @property {number}  CT_SET           - A collection type (unordered and without repeated values).
 * @property {number}  CT_MAP           - A collection type (map/associative-array/dictionary).
 * @property {number}  CT_STRUCT        - A multifield type.
 */
TCompactProtocol.Types = {
  CT_STOP:           0x00,
  CT_BOOLEAN_TRUE:   0x01,
  CT_BOOLEAN_FALSE:  0x02,
  CT_BYTE:           0x03,
  CT_I16:            0x04,
  CT_I32:            0x05,
  CT_I64:            0x06,
  CT_DOUBLE:         0x07,
  CT_BINARY:         0x08,
  CT_LIST:           0x09,
  CT_SET:            0x0A,
  CT_MAP:            0x0B,
  CT_STRUCT:         0x0C
};

/**
 * Array mapping Compact type IDs to standard Thrift type IDs.
 * @readonly
 */
TCompactProtocol.TTypeToCType = [
  TCompactProtocol.Types.CT_STOP,         // T_STOP
  0,                                      // unused
  TCompactProtocol.Types.CT_BOOLEAN_TRUE, // T_BOOL
  TCompactProtocol.Types.CT_BYTE,         // T_BYTE
  TCompactProtocol.Types.CT_DOUBLE,       // T_DOUBLE
  0,                                      // unused
  TCompactProtocol.Types.CT_I16,          // T_I16
  0,                                      // unused
  TCompactProtocol.Types.CT_I32,          // T_I32
  0,                                      // unused
  TCompactProtocol.Types.CT_I64,          // T_I64
  TCompactProtocol.Types.CT_BINARY,       // T_STRING
  TCompactProtocol.Types.CT_STRUCT,       // T_STRUCT
  TCompactProtocol.Types.CT_MAP,          // T_MAP
  TCompactProtocol.Types.CT_SET,          // T_SET
  TCompactProtocol.Types.CT_LIST,         // T_LIST
];


//
// Compact Protocol Utilities
//

/**
 * Returns the underlying transport layer.
 * @return {object} The underlying transport layer.
 */TCompactProtocol.prototype.getTransport = function() {
  return this.trans;
};

/**
 * Lookup a Compact Protocol Type value for a given Thrift Type value.
 * N.B. Used only internally.
 * @param {number} ttype - Thrift type value
 * @returns {number} Compact protocol type value
 */
TCompactProtocol.prototype.getCompactType = function(ttype) {
  return TCompactProtocol.TTypeToCType[ttype];
};

/**
 * Lookup a Thrift Type value for a given Compact Protocol Type value.
 * N.B. Used only internally.
 * @param {number} type - Compact Protocol type value
 * @returns {number} Thrift Type value
 */
TCompactProtocol.prototype.getTType = function(type) {
  switch (type) {
    case Type.STOP:
      return Type.STOP;
    case TCompactProtocol.Types.CT_BOOLEAN_FALSE:
    case TCompactProtocol.Types.CT_BOOLEAN_TRUE:
      return Type.BOOL;
    case TCompactProtocol.Types.CT_BYTE:
      return Type.BYTE;
    case TCompactProtocol.Types.CT_I16:
      return Type.I16;
    case TCompactProtocol.Types.CT_I32:
      return Type.I32;
    case TCompactProtocol.Types.CT_I64:
      return Type.I64;
    case TCompactProtocol.Types.CT_DOUBLE:
      return Type.DOUBLE;
    case TCompactProtocol.Types.CT_BINARY:
      return Type.STRING;
    case TCompactProtocol.Types.CT_LIST:
      return Type.LIST;
    case TCompactProtocol.Types.CT_SET:
      return Type.SET;
    case TCompactProtocol.Types.CT_MAP:
      return Type.MAP;
    case TCompactProtocol.Types.CT_STRUCT:
      return Type.STRUCT;
    default:
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Unknown type: " + type);
  }
  return Type.STOP;
};


//
// Compact Protocol write operations
//

/**
 * Send any buffered bytes to the end point.
 */
TCompactProtocol.prototype.flush = function() {
  return this.trans.flush();
};

/**
 * Writes an RPC message header
 * @param {string} name - The method name for the message.
 * @param {number} type - The type of message (CALL, REPLY, EXCEPTION, ONEWAY).
 * @param {number} seqid - The call sequence number (if any).
 */
TCompactProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
  this.writeByte(TCompactProtocol.PROTOCOL_ID);
  this.writeByte((TCompactProtocol.VERSION_N & TCompactProtocol.VERSION_MASK) |
                     ((type << TCompactProtocol.TYPE_SHIFT_AMOUNT) & TCompactProtocol.TYPE_MASK));
  this.writeVarint32(seqid);
  this.writeString(name);

  // Record client seqid to find callback again
  if (this._seqid) {
    log.warning('SeqId already set', { 'name': name });
  } else {
    this._seqid = seqid;
    this.trans.setCurrSeqId(seqid);
  }
};

TCompactProtocol.prototype.writeMessageEnd = function() {
};

TCompactProtocol.prototype.writeStructBegin = function(name) {
  this.lastField_.push(this.lastFieldId_);
  this.lastFieldId_ = 0;
};

TCompactProtocol.prototype.writeStructEnd = function() {
  this.lastFieldId_ = this.lastField_.pop();
};

/**
 * Writes a struct field header
 * @param {string} name - The field name (not written with the compact protocol).
 * @param {number} type - The field data type (a normal Thrift field Type).
 * @param {number} id - The IDL field Id.
 */
TCompactProtocol.prototype.writeFieldBegin = function(name, type, id) {
  if (type != Type.BOOL) {
    return this.writeFieldBeginInternal(name, type, id, -1);
  }

  this.booleanField_.name = name;
  this.booleanField_.fieldType = type;
  this.booleanField_.fieldId = id;
};

TCompactProtocol.prototype.writeFieldEnd = function() {
};

TCompactProtocol.prototype.writeFieldStop = function() {
  this.writeByte(TCompactProtocol.Types.CT_STOP);
};

/**
 * Writes a map collection header
 * @param {number} keyType - The Thrift type of the map keys.
 * @param {number} valType - The Thrift type of the map values.
 * @param {number} size - The number of k/v pairs in the map.
 */
TCompactProtocol.prototype.writeMapBegin = function(keyType, valType, size) {
  if (size === 0) {
    this.writeByte(0);
  } else {
    this.writeVarint32(size);
    this.writeByte(this.getCompactType(keyType) << 4 | this.getCompactType(valType));
  }
};

TCompactProtocol.prototype.writeMapEnd = function() {
};

/**
 * Writes a list collection header
 * @param {number} elemType - The Thrift type of the list elements.
 * @param {number} size - The number of elements in the list.
 */
TCompactProtocol.prototype.writeListBegin = function(elemType, size) {
  this.writeCollectionBegin(elemType, size);
};

TCompactProtocol.prototype.writeListEnd = function() {
};

/**
 * Writes a set collection header
 * @param {number} elemType - The Thrift type of the set elements.
 * @param {number} size - The number of elements in the set.
 */
TCompactProtocol.prototype.writeSetBegin = function(elemType, size) {
  this.writeCollectionBegin(elemType, size);
};

TCompactProtocol.prototype.writeSetEnd = function() {
};

TCompactProtocol.prototype.writeBool = function(value) {
  if (this.booleanField_.name !== null) {
    // we haven't written the field header yet
    this.writeFieldBeginInternal(this.booleanField_.name,
                                 this.booleanField_.fieldType,
                                 this.booleanField_.fieldId,
                                 (value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE
                                          : TCompactProtocol.Types.CT_BOOLEAN_FALSE));
    this.booleanField_.name = null;
  } else {
    // we're not part of a field, so just write the value
    this.writeByte((value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE
                            : TCompactProtocol.Types.CT_BOOLEAN_FALSE));
  }
};

TCompactProtocol.prototype.writeByte = function(b) {
  this.trans.write(new Buffer([b]));
};

TCompactProtocol.prototype.writeI16 = function(i16) {
  this.writeVarint32(this.i32ToZigzag(i16));
};

TCompactProtocol.prototype.writeI32 = function(i32) {
  this.writeVarint32(this.i32ToZigzag(i32));
};

TCompactProtocol.prototype.writeI64 = function(i64) {
  this.writeVarint64(this.i64ToZigzag(i64));
};

// Little-endian, unlike TBinaryProtocol
TCompactProtocol.prototype.writeDouble = function(v) {
  var buff = new Buffer(8);
  var m, e, c;

  buff[7] = (v < 0 ? 0x80 : 0x00);

  v = Math.abs(v);
  if (v !== v) {
    // NaN, use QNaN IEEE format
    m = 2251799813685248;
    e = 2047;
  } else if (v === Infinity) {
    m = 0;
    e = 2047;
  } else {
    e = Math.floor(Math.log(v) / Math.LN2);
    c = Math.pow(2, -e);
    if (v * c < 1) {
      e--;
      c *= 2;
    }

    if (e + 1023 >= 2047)
    {
      // Overflow
      m = 0;
      e = 2047;
    }
    else if (e + 1023 >= 1)
    {
      // Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow
      m = (v*c-1) * POW_52;
      e += 1023;
    }
    else
    {
      // Denormalized - also catches the '0' case, somewhat by chance
      m = (v * POW_1022) * POW_52;
      e = 0;
    }
  }

  buff[6] = (e << 4) & 0xf0;
  buff[7] |= (e >> 4) & 0x7f;

  buff[0] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[1] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[2] = m & 0xff;
  m = Math.floor(m / POW_8);
  buff[3] = m & 0xff;
  m >>= 8;
  buff[4] = m & 0xff;
  m >>= 8;
  buff[5] = m & 0xff;
  m >>= 8;
  buff[6] |= m & 0x0f;

  this.trans.write(buff);
};

TCompactProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
  if (typeof arg === 'string') {
    this.writeVarint32(Buffer.byteLength(arg, encoding)) ;
    this.trans.write(new Buffer(arg, encoding));
  } else if (arg instanceof Buffer ||
             Object.prototype.toString.call(arg) == '[object Uint8Array]') {
    // Buffers in Node.js under Browserify may extend UInt8Array instead of
    // defining a new object. We detect them here so we can write them
    // correctly
    this.writeVarint32(arg.length);
    this.trans.write(arg);
  } else {
    throw new Error(name + ' called without a string/Buffer argument: ' + arg);
  }
};

TCompactProtocol.prototype.writeString = function(arg) {
  this.writeStringOrBinary('writeString', 'utf8', arg);
};

TCompactProtocol.prototype.writeBinary = function(arg) {
  this.writeStringOrBinary('writeBinary', 'binary', arg);
};


//
// Compact Protocol internal write methods
//

TCompactProtocol.prototype.writeFieldBeginInternal = function(name,
                                                              fieldType,
                                                              fieldId,
                                                              typeOverride) {
  //If there's a type override, use that.
  var typeToWrite = (typeOverride == -1 ? this.getCompactType(fieldType) : typeOverride);
  //Check if we can delta encode the field id
  if (fieldId > this.lastFieldId_ && fieldId - this.lastFieldId_ <= 15) {
    //Include the type delta with the field ID
    this.writeByte((fieldId - this.lastFieldId_) << 4 | typeToWrite);
  } else {
    //Write separate type and ID values
    this.writeByte(typeToWrite);
    this.writeI16(fieldId);
  }
  this.lastFieldId_ = fieldId;
};

TCompactProtocol.prototype.writeCollectionBegin = function(elemType, size) {
  if (size <= 14) {
    //Combine size and type in one byte if possible
    this.writeByte(size << 4 | this.getCompactType(elemType));
  } else {
    this.writeByte(0xf0 | this.getCompactType(elemType));
    this.writeVarint32(size);
  }
};

/**
 * Write an i32 as a varint. Results in 1-5 bytes on the wire.
 */
TCompactProtocol.prototype.writeVarint32 = function(n) {
  var buf = new Buffer(5);
  var wsize = 0;
  while (true) {
    if ((n & ~0x7F) === 0) {
      buf[wsize++] = n;
      break;
    } else {
      buf[wsize++] = ((n & 0x7F) | 0x80);
      n = n >>> 7;
    }
  }
  var wbuf = new Buffer(wsize);
  buf.copy(wbuf,0,0,wsize);
  this.trans.write(wbuf);
};

/**
 * Write an i64 as a varint. Results in 1-10 bytes on the wire.
 * N.B. node-int64 is always big endian
 */
TCompactProtocol.prototype.writeVarint64 = function(n) {
  if (typeof n === "number"){
    n = new Int64(n);
  }
  if (! (n instanceof Int64)) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Expected Int64 or Number, found: " + n);
  }

  var buf = new Buffer(10);
  var wsize = 0;
  var hi = n.buffer.readUInt32BE(0, true);
  var lo = n.buffer.readUInt32BE(4, true);
  var mask = 0;
  while (true) {
    if (((lo & ~0x7F) === 0) && (hi === 0)) {
      buf[wsize++] = lo;
      break;
    } else {
      buf[wsize++] = ((lo & 0x7F) | 0x80);
      mask = hi << 25;
      lo = lo >>> 7;
      hi = hi >>> 7;
      lo = lo | mask;
    }
  }
  var wbuf = new Buffer(wsize);
  buf.copy(wbuf,0,0,wsize);
  this.trans.write(wbuf);
};

/**
 * Convert l into a zigzag long. This allows negative numbers to be
 * represented compactly as a varint.
 */
TCompactProtocol.prototype.i64ToZigzag = function(l) {
  if (typeof l === 'string') {
    l = new Int64(parseInt(l, 10));
  } else if (typeof l === 'number') {
    l = new Int64(l);
  }
  if (! (l instanceof Int64)) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Expected Int64 or Number, found: " + l);
  }
  var hi = l.buffer.readUInt32BE(0, true);
  var lo = l.buffer.readUInt32BE(4, true);
  var sign = hi >>> 31;
  hi = ((hi << 1) | (lo >>> 31)) ^ ((!!sign) ? 0xFFFFFFFF : 0);
  lo = (lo << 1) ^ ((!!sign) ? 0xFFFFFFFF : 0);
  return new Int64(hi, lo);
};

/**
 * Convert n into a zigzag int. This allows negative numbers to be
 * represented compactly as a varint.
 */
TCompactProtocol.prototype.i32ToZigzag = function(n) {
  return (n << 1) ^ ((n & 0x80000000) ? 0xFFFFFFFF : 0);
};


//
// Compact Protocol read operations
//

TCompactProtocol.prototype.readMessageBegin = function() {
  //Read protocol ID
  var protocolId = this.trans.readByte();
  if (protocolId != TCompactProtocol.PROTOCOL_ID) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad protocol identifier " + protocolId);
  }

  //Read Version and Type
  var versionAndType = this.trans.readByte();
  var version = (versionAndType & TCompactProtocol.VERSION_MASK);
  if (version != TCompactProtocol.VERSION_N) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad protocol version " + version);
  }
  var type = ((versionAndType >> TCompactProtocol.TYPE_SHIFT_AMOUNT) & TCompactProtocol.TYPE_BITS);

  //Read SeqId
  var seqid = this.readVarint32();

  //Read name
  var name = this.readString();

  return {fname: name, mtype: type, rseqid: seqid};
};

TCompactProtocol.prototype.readMessageEnd = function() {
};

TCompactProtocol.prototype.readStructBegin = function() {
  this.lastField_.push(this.lastFieldId_);
  this.lastFieldId_ = 0;
  return {fname: ''};
};

TCompactProtocol.prototype.readStructEnd = function() {
  this.lastFieldId_ = this.lastField_.pop();
};

TCompactProtocol.prototype.readFieldBegin = function() {
  var fieldId = 0;
  var b = this.trans.readByte(b);
  var type = (b & 0x0f);

  if (type == TCompactProtocol.Types.CT_STOP) {
    return {fname: null, ftype: Thrift.Type.STOP, fid: 0};
  }

  //Mask off the 4 MSB of the type header to check for field id delta.
  var modifier = ((b & 0x000000f0) >>> 4);
  if (modifier === 0) {
    //If not a delta read the field id.
    fieldId = this.readI16();
  } else {
    //Recover the field id from the delta
    fieldId = (this.lastFieldId_ + modifier);
  }
  var fieldType = this.getTType(type);

  //Boolean are encoded with the type
  if (type == TCompactProtocol.Types.CT_BOOLEAN_TRUE ||
      type == TCompactProtocol.Types.CT_BOOLEAN_FALSE) {
    this.boolValue_.hasBoolValue = true;
    this.boolValue_.boolValue =
      (type == TCompactProtocol.Types.CT_BOOLEAN_TRUE ? true : false);
  }

  //Save the new field for the next delta computation.
  this.lastFieldId_ = fieldId;
  return {fname: null, ftype: fieldType, fid: fieldId};
};

TCompactProtocol.prototype.readFieldEnd = function() {
};

TCompactProtocol.prototype.readMapBegin = function() {
  var msize = this.readVarint32();
  if (msize < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative map size");
  }

  var kvType = 0;
  if (msize !== 0) {
    kvType = this.trans.readByte();
  }

  var keyType = this.getTType((kvType & 0xf0) >>> 4);
  var valType = this.getTType(kvType & 0xf);
  return {ktype: keyType, vtype: valType, size: msize};
};

TCompactProtocol.prototype.readMapEnd = function() {
};

TCompactProtocol.prototype.readListBegin = function() {
  var size_and_type = this.trans.readByte();

  var lsize = (size_and_type >>> 4) & 0x0000000f;
  if (lsize == 15) {
    lsize = this.readVarint32();
  }

  if (lsize < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative list size");
  }

  var elemType = this.getTType(size_and_type & 0x0000000f);

  return {etype: elemType, size: lsize};
};

TCompactProtocol.prototype.readListEnd = function() {
};

TCompactProtocol.prototype.readSetBegin = function() {
  return this.readListBegin();
};

TCompactProtocol.prototype.readSetEnd = function() {
};

TCompactProtocol.prototype.readBool = function() {
  var value = false;
  var rsize = 0;
  if (this.boolValue_.hasBoolValue === true) {
    value = this.boolValue_.boolValue;
    this.boolValue_.hasBoolValue = false;
  } else {
    var res = this.trans.readByte();
    rsize = res.rsize;
    value = (res.value == TCompactProtocol.Types.CT_BOOLEAN_TRUE);
  }
  return value;
};

TCompactProtocol.prototype.readByte = function() {
  return this.trans.readByte();
};

TCompactProtocol.prototype.readI16 = function() {
  return this.readI32();
};

TCompactProtocol.prototype.readI32 = function() {
  return this.zigzagToI32(this.readVarint32());
};

TCompactProtocol.prototype.readI64 = function() {
  return this.zigzagToI64(this.readVarint64());
};

// Little-endian, unlike TBinaryProtocol
TCompactProtocol.prototype.readDouble = function() {
  var buff = this.trans.read(8);
  var off = 0;

  var signed = buff[off + 7] & 0x80;
  var e = (buff[off+6] & 0xF0) >> 4;
  e += (buff[off+7] & 0x7F) << 4;

  var m = buff[off];
  m += buff[off+1] << 8;
  m += buff[off+2] << 16;
  m += buff[off+3] * POW_24;
  m += buff[off+4] * POW_32;
  m += buff[off+5] * POW_40;
  m += (buff[off+6] & 0x0F) * POW_48;

  switch (e) {
    case 0:
      e = -1022;
      break;
    case 2047:
      return m ? NaN : (signed ? -Infinity : Infinity);
    default:
      m += POW_52;
      e -= 1023;
  }

  if (signed) {
    m *= -1;
  }

  return m * Math.pow(2, e - 52);
};

TCompactProtocol.prototype.readBinary = function() {
  var size = this.readVarint32();
  if (size === 0) {
    return new Buffer(0);
  }

  if (size < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative binary size");
  }
  return this.trans.read(size);
};

TCompactProtocol.prototype.readString = function() {
  var size = this.readVarint32();
  // Catch empty string case
  if (size === 0) {
    return "";
  }

  // Catch error cases
  if (size < 0) {
    throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative string size");
  }
  return this.trans.readString(size);
};


//
// Compact Protocol internal read operations
//

/**
 * Read an i32 from the wire as a varint. The MSB of each byte is set
 * if there is another byte to follow. This can read up to 5 bytes.
 */
TCompactProtocol.prototype.readVarint32 = function() {
  return this.readVarint64().toNumber();
};

/**
 * Read an i64 from the wire as a proper varint. The MSB of each byte is set
 * if there is another byte to follow. This can read up to 10 bytes.
 */
TCompactProtocol.prototype.readVarint64 = function() {
  var rsize = 0;
  var lo = 0;
  var hi = 0;
  var shift = 0;
  while (true) {
    var b = this.trans.readByte();
    rsize ++;
    if (shift <= 25) {
      lo = lo | ((b & 0x7f) << shift);
    } else if (25 < shift && shift < 32) {
      lo = lo | ((b & 0x7f) << shift);
      hi = hi | ((b & 0x7f) >>> (32-shift));
    } else {
      hi = hi | ((b & 0x7f) << (shift-32));
    }
    shift += 7;
    if (!(b & 0x80)) {
      break;
    }
    if (rsize >= 10) {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Variable-length int over 10 bytes.");
    }
  }
  return new Int64(hi, lo);
};

/**
 * Convert from zigzag int to int.
 */
TCompactProtocol.prototype.zigzagToI32 = function(n) {
  return (n >>> 1) ^ (-1 * (n & 1));
};

/**
 * Convert from zigzag long to long.
 */
TCompactProtocol.prototype.zigzagToI64 = function(n) {
  var hi = n.buffer.readUInt32BE(0, true);
  var lo = n.buffer.readUInt32BE(4, true);

  var neg = new Int64(hi & 0, lo & 1);
  neg._2scomp();
  var hi_neg = neg.buffer.readUInt32BE(0, true);
  var lo_neg = neg.buffer.readUInt32BE(4, true);

  var hi_lo = (hi << 31);
  hi = (hi >>> 1) ^ (hi_neg);
  lo = ((lo >>> 1) | hi_lo) ^ (lo_neg);
  return new Int64(hi, lo);
};

TCompactProtocol.prototype.skip = function(type) {
  switch (type) {
    case Type.BOOL:
      this.readBool();
      break;
    case Type.BYTE:
      this.readByte();
      break;
    case Type.I16:
      this.readI16();
      break;
    case Type.I32:
      this.readI32();
      break;
    case Type.I64:
      this.readI64();
      break;
    case Type.DOUBLE:
      this.readDouble();
      break;
    case Type.STRING:
      this.readString();
      break;
    case Type.STRUCT:
      this.readStructBegin();
      while (true) {
        var r = this.readFieldBegin();
        if (r.ftype === Type.STOP) {
          break;
        }
        this.skip(r.ftype);
        this.readFieldEnd();
      }
      this.readStructEnd();
      break;
    case Type.MAP:
      var mapBegin = this.readMapBegin();
      for (var i = 0; i < mapBegin.size; ++i) {
        this.skip(mapBegin.ktype);
        this.skip(mapBegin.vtype);
      }
      this.readMapEnd();
      break;
    case Type.SET:
      var setBegin = this.readSetBegin();
      for (var i2 = 0; i2 < setBegin.size; ++i2) {
        this.skip(setBegin.etype);
      }
      this.readSetEnd();
      break;
    case Type.LIST:
      var listBegin = this.readListBegin();
      for (var i3 = 0; i3 < listBegin.size; ++i3) {
        this.skip(listBegin.etype);
      }
      this.readListEnd();
      break;
    default:
      throw new  Error("Invalid type: " + type);
  }
};


/***/ }),

/***/ 6526:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(1669);
var EventEmitter = __webpack_require__(8614).EventEmitter;
var constants = __webpack_require__(7619);
var net = __webpack_require__(1631);
var tls = __webpack_require__(4016);
var thrift = __webpack_require__(5406);
var log = __webpack_require__(1291);

var TBufferedTransport = __webpack_require__(8869);
var TBinaryProtocol = __webpack_require__(4711);
var InputBufferUnderrunError = __webpack_require__(3590);

var createClient = __webpack_require__(6243);

var binary = __webpack_require__(7533);

var Connection = exports.Connection = function(stream, options) {
  var self = this;
  EventEmitter.call(this);

  this.seqId2Service = {};
  this.connection = stream;
  this.ssl = (stream.encrypted);
  this.options = options || {};
  this.transport = this.options.transport || TBufferedTransport;
  this.protocol = this.options.protocol || TBinaryProtocol;
  this.offline_queue = [];
  this.connected = false;
  this.initialize_retry_vars();

  this._debug = this.options.debug || false;
  if (this.options.max_attempts &&
      !isNaN(this.options.max_attempts) &&
      this.options.max_attempts > 0) {
     this.max_attempts = +this.options.max_attempts;
  }
  this.retry_max_delay = null;
  if (this.options.retry_max_delay !== undefined &&
      !isNaN(this.options.retry_max_delay) &&
      this.options.retry_max_delay > 0) {
     this.retry_max_delay = this.options.retry_max_delay;
  }
  this.connect_timeout = false;
  if (this.options.connect_timeout &&
      !isNaN(this.options.connect_timeout) &&
      this.options.connect_timeout > 0) {
     this.connect_timeout = +this.options.connect_timeout;
  }

  this.connection.addListener(this.ssl ? "secureConnect" : "connect", function() {
    self.connected = true;

    this.setTimeout(self.options.timeout || 0);
    this.setNoDelay();
    this.frameLeft = 0;
    this.framePos = 0;
    this.frame = null;
    self.initialize_retry_vars();
    self.flush_offline_queue();

    self.emit("connect");
  });

  this.connection.addListener("error", function(err) {
    // Only emit the error if no-one else is listening on the connection
    // or if someone is listening on us, because Node turns unhandled
    // 'error' events into exceptions.
    if (self.connection.listeners('error').length === 1 ||
        self.listeners('error').length > 0) {
      self.emit("error", err);
    }
  });

  // Add a close listener
  this.connection.addListener("close", function() {
    self.connection_gone(); // handle close event. try to reconnect
  });

  this.connection.addListener("timeout", function() {
    self.emit("timeout");
  });

  this.connection.addListener("data", self.transport.receiver(function(transport_with_data) {
    var message = new self.protocol(transport_with_data);
    try {
      while (true) {
        var header = message.readMessageBegin();
        var dummy_seqid = header.rseqid * -1;
        var client = self.client;
        //The Multiplexed Protocol stores a hash of seqid to service names
        //  in seqId2Service. If the SeqId is found in the hash we need to
        //  lookup the appropriate client for this call.
        //  The connection.client object is a single client object when not
        //  multiplexing, when using multiplexing it is a service name keyed
        //  hash of client objects.
        //NOTE: The 2 way interdependencies between protocols, transports,
        //  connections and clients in the Node.js implementation are irregular
        //  and make the implementation difficult to extend and maintain. We
        //  should bring this stuff inline with typical thrift I/O stack
        //  operation soon.
        //  --ra
        var service_name = self.seqId2Service[header.rseqid];
        if (service_name) {
          client = self.client[service_name];
        }
        /*jshint -W083 */
        client._reqs[dummy_seqid] = function(err, success){
          transport_with_data.commitPosition();

          var callback = client._reqs[header.rseqid];
          delete client._reqs[header.rseqid];
          if (service_name) {
            delete self.seqId2Service[header.rseqid];
          }
          if (callback) {
            callback(err, success);
          }
        };
        /*jshint +W083 */

        if(client['recv_' + header.fname]) {
          client['recv_' + header.fname](message, header.mtype, dummy_seqid);
        } else {
          delete client._reqs[dummy_seqid];
          self.emit("error",
                    new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
                             "Received a response to an unknown RPC function"));
        }
      }
    }
    catch (e) {
      if (e instanceof InputBufferUnderrunError) {
        transport_with_data.rollbackPosition();
      }
      else {
        self.emit('error', e);
      }
    }
  }));
};
util.inherits(Connection, EventEmitter);

Connection.prototype.end = function() {
  this.connection.end();
};

Connection.prototype.destroy = function() {
  this.connection.destroy();
};

Connection.prototype.initialize_retry_vars = function () {
  this.retry_timer = null;
  this.retry_totaltime = 0;
  this.retry_delay = 150;
  this.retry_backoff = 1.7;
  this.attempts = 0;
};

Connection.prototype.flush_offline_queue = function () {
  var self = this;
  var offline_queue = this.offline_queue;

  // Reset offline queue
  this.offline_queue = [];
  // Attempt to write queued items
  offline_queue.forEach(function(data) {
    self.write(data);
  });
};

Connection.prototype.write = function(data) {
  if (!this.connected) {
    this.offline_queue.push(data);
    return;
  }
  this.connection.write(data);
};

Connection.prototype.connection_gone = function () {
  var self = this;
  this.connected = false;

  // If a retry is already in progress, just let that happen
  if (this.retry_timer) {
    return;
  }
  // We cannot reconnect a secure socket.
  if (!this.max_attempts || this.ssl) {
    self.emit("close");
    return;
  }

  if (this.retry_max_delay !== null && this.retry_delay >= this.retry_max_delay) {
    this.retry_delay = this.retry_max_delay;
  } else {
    this.retry_delay = Math.floor(this.retry_delay * this.retry_backoff);
  }

  log.debug("Retry connection in " + this.retry_delay + " ms");

  if (this.max_attempts && this.attempts >= this.max_attempts) {
    this.retry_timer = null;
    console.error("thrift: Couldn't get thrift connection after " + this.max_attempts + " attempts.");
    self.emit("close");
    return;
  }

  this.attempts += 1;
  this.emit("reconnecting", {
    delay: self.retry_delay,
    attempt: self.attempts
  });

  this.retry_timer = setTimeout(function () {
    if (self.connection.destroyed) {
      self.retry_timer = null;
      return;
    }

    log.debug("Retrying connection...");

    self.retry_totaltime += self.retry_delay;

    if (self.connect_timeout && self.retry_totaltime >= self.connect_timeout) {
       self.retry_timer = null;
       console.error("thrift: Couldn't get thrift connection after " + self.retry_totaltime + "ms.");
       self.emit("close");
       return;
    }

    if (self.path !== undefined) {
      self.connection.connect(self.path);
    } else {
      self.connection.connect(self.port, self.host);
    }
    self.retry_timer = null;
  }, this.retry_delay);
};

exports.createConnection = function(host, port, options) {
  var stream = net.createConnection( {
    port: port, 
    host: host,
    timeout: options.connect_timeout || options.timeout || 0
  });
  var connection = new Connection(stream, options);
  connection.host = host;
  connection.port = port;

  return connection;
};

exports.createUDSConnection = function(path, options) {
  var stream = net.createConnection(path);
  var connection = new Connection(stream, options);
  connection.path = path;

  return connection;
};

exports.createSSLConnection = function(host, port, options) {
  if (!('secureProtocol' in options) && !('secureOptions' in options)) {
    options.secureProtocol = "SSLv23_method";
    options.secureOptions = constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3;
  }

  var stream = tls.connect(port, host, options);
  var connection = new Connection(stream, options);
  connection.host = host;
  connection.port = port;

  return connection;
};


exports.createClient = createClient;

var child_process = __webpack_require__(3129);
var StdIOConnection = exports.StdIOConnection = function(command, options) {
  var command_parts = command.split(' ');
  command = command_parts[0];
  var args = command_parts.splice(1,command_parts.length -1);
  var child = this.child = child_process.spawn(command,args);

  var self = this;
  EventEmitter.call(this);

  this.connection = child.stdin;
  this.options = options || {};
  this.transport = this.options.transport || TBufferedTransport;
  this.protocol = this.options.protocol || TBinaryProtocol;
  this.offline_queue = [];

  if (log.getLogLevel() === 'debug') {
    this.child.stderr.on('data', function (err) {
      log.debug(err.toString(), 'CHILD ERROR');
    });

    this.child.on('exit', function (code,signal) {
      log.debug(code + ':' + signal, 'CHILD EXITED');
    });
  }

  this.frameLeft = 0;
  this.framePos = 0;
  this.frame = null;
  this.connected = true;

  self.flush_offline_queue();

  this.connection.addListener("error", function(err) {
    self.emit("error", err);
  });

  // Add a close listener
  this.connection.addListener("close", function() {
    self.emit("close");
  });

  child.stdout.addListener("data", self.transport.receiver(function(transport_with_data) {
    var message = new self.protocol(transport_with_data);
    try {
      var header = message.readMessageBegin();
      var dummy_seqid = header.rseqid * -1;
      var client = self.client;
      client._reqs[dummy_seqid] = function(err, success){
        transport_with_data.commitPosition();

        var callback = client._reqs[header.rseqid];
        delete client._reqs[header.rseqid];
        if (callback) {
          callback(err, success);
        }
      };
      client['recv_' + header.fname](message, header.mtype, dummy_seqid);
    }
    catch (e) {
      if (e instanceof InputBufferUnderrunError) {
        transport_with_data.rollbackPosition();
      }
      else {
        throw e;
      }
    }
  }));
};

util.inherits(StdIOConnection, EventEmitter);

StdIOConnection.prototype.end = function() {
  this.connection.end();
};

StdIOConnection.prototype.flush_offline_queue = function () {
  var self = this;
  var offline_queue = this.offline_queue;

  // Reset offline queue
  this.offline_queue = [];
  // Attempt to write queued items
  offline_queue.forEach(function(data) {
    self.write(data);
  });
};

StdIOConnection.prototype.write = function(data) {
  if (!this.connected) {
    this.offline_queue.push(data);
    return;
  }
  this.connection.write(data);
};

exports.createStdIOConnection = function(command,options){
  return new StdIOConnection(command,options);
};

exports.createStdIOClient = createClient;


/***/ }),

/***/ 6243:
/***/ ((module) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

module.exports = createClient;

/**
 * Creates a new client object for the specified Thrift service.
 * @param {object} ServiceClient - The module containing the generated service client
 * @param {Connection} Connection - The connection to use.
 * @returns {object} The client object.
 */
function createClient(ServiceClient, connection) {
  // TODO validate required options and throw otherwise
  if (ServiceClient.Client) {
    ServiceClient = ServiceClient.Client;
  }
  // TODO detangle these initialization calls
  // creating "client" requires
  //   - new service client instance
  //
  // New service client instance requires
  //   - new transport instance
  //   - protocol class reference
  //
  // New transport instance requires
  //   - Buffer to use (or none)
  //   - Callback to call on flush

  // Wrap the write method
  var writeCb = function(buf, seqid) {
    connection.write(buf, seqid);
  };
  var transport = new connection.transport(undefined, writeCb);
  var client = new ServiceClient(transport, connection.protocol);
  transport.client = client;
  connection.client = client;
  return client;
};


/***/ }),

/***/ 7584:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var binary = __webpack_require__(7533);
var InputBufferUnderrunError = __webpack_require__(3590);
var THeaderTransport = __webpack_require__(5190);

module.exports = TFramedTransport;

function TFramedTransport(buffer, callback) {
  this.inBuf = buffer || new Buffer(0);
  this.outBuffers = [];
  this.outCount = 0;
  this.readPos = 0;
  this.onFlush = callback;
};

TFramedTransport.prototype = new THeaderTransport();

TFramedTransport.receiver = function(callback, seqid) {
  var residual = null;

  return function(data) {
    // Prepend any residual data from our previous read
    if (residual) {
      data = Buffer.concat([residual, data]);
      residual = null;
    }

    // framed transport
    while (data.length) {
      if (data.length < 4) {
        // Not enough bytes to continue, save and resume on next packet
        residual = data;
        return;
      }
      var frameSize = binary.readI32(data, 0);
      if (data.length < 4 + frameSize) {
        // Not enough bytes to continue, save and resume on next packet
        residual = data;
        return;
      }

      var frame = data.slice(4, 4 + frameSize);
      residual = data.slice(4 + frameSize);

      callback(new TFramedTransport(frame), seqid);

      data = residual;
      residual = null;
    }
  };
};

TFramedTransport.prototype.commitPosition = function(){},
TFramedTransport.prototype.rollbackPosition = function(){},

  // TODO: Implement open/close support
TFramedTransport.prototype.isOpen = function() {
  return true;
};
TFramedTransport.prototype.open = function() {};
TFramedTransport.prototype.close =  function() {};

  // Set the seqid of the message in the client
  // So that callbacks can be found
TFramedTransport.prototype.setCurrSeqId = function(seqid) {
  this._seqid = seqid;
};

TFramedTransport.prototype.ensureAvailable = function(len) {
  if (this.readPos + len > this.inBuf.length) {
    throw new InputBufferUnderrunError();
  }
};

TFramedTransport.prototype.read = function(len) { // this function will be used for each frames.
  this.ensureAvailable(len);
  var end = this.readPos + len;

  if (this.inBuf.length < end) {
    throw new Error('read(' + len + ') failed - not enough data');
  }

  var buf = this.inBuf.slice(this.readPos, end);
  this.readPos = end;
  return buf;
};

TFramedTransport.prototype.readByte = function() {
  this.ensureAvailable(1);
  return binary.readByte(this.inBuf[this.readPos++]);
};

TFramedTransport.prototype.readI16 = function() {
  this.ensureAvailable(2);
  var i16 = binary.readI16(this.inBuf, this.readPos);
  this.readPos += 2;
  return i16;
};

TFramedTransport.prototype.readI32 = function() {
  this.ensureAvailable(4);
  var i32 = binary.readI32(this.inBuf, this.readPos);
  this.readPos += 4;
  return i32;
};

TFramedTransport.prototype.readDouble = function() {
  this.ensureAvailable(8);
  var d = binary.readDouble(this.inBuf, this.readPos);
  this.readPos += 8;
  return d;
};

TFramedTransport.prototype.readString = function(len) {
  this.ensureAvailable(len);
  var str = this.inBuf.toString('utf8', this.readPos, this.readPos + len);
  this.readPos += len;
  return str;
};

TFramedTransport.prototype.borrow = function() {
  return {
    buf: this.inBuf,
    readIndex: this.readPos,
    writeIndex: this.inBuf.length
  };
};

TFramedTransport.prototype.consume = function(bytesConsumed) {
  this.readPos += bytesConsumed;
};

TFramedTransport.prototype.write = function(buf, encoding) {
  if (typeof(buf) === "string") {
    buf = new Buffer(buf, encoding || 'utf8');
  }
  this.outBuffers.push(buf);
  this.outCount += buf.length;
};

TFramedTransport.prototype.flush = function() {
  // If the seqid of the callback is available pass it to the onFlush
  // Then remove the current seqid
  var seqid = this._seqid;
  this._seqid = null;

  var out = new Buffer(this.outCount),
      pos = 0;
  this.outBuffers.forEach(function(buf) {
    buf.copy(out, pos, 0);
    pos += buf.length;
  });

  if (this.onFlush) {
    // TODO: optimize this better, allocate one buffer instead of both:
    var msg = new Buffer(out.length + 4);
    binary.writeI32(msg, out.length);
    out.copy(msg, 4, 0, out.length);
    if (this.onFlush) {
      // Passing seqid through this call to get it to the connection
      this.onFlush(msg, seqid);
    }
  }

  this.outBuffers = [];
  this.outCount = 0;
};


/***/ }),

/***/ 6357:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(1669);
var TBinaryProtocol = __webpack_require__(4711);
var TCompactProtocol = __webpack_require__(9277);
var THeaderTransport = __webpack_require__(5190);

var ProtocolMap = {};
ProtocolMap[THeaderTransport.SubprotocolId.BINARY] = TBinaryProtocol;
ProtocolMap[THeaderTransport.SubprotocolId.COMPACT] = TCompactProtocol;

module.exports = THeaderProtocol;

function THeaderProtocolError(message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = this.constructor.name;
  this.message = message;
}

util.inherits(THeaderProtocolError, Error);

/**
 * A framed protocol with headers.
 *
 * THeaderProtocol frames other Thrift protocols and adds support for
 * optional out-of-band headers. The currently supported subprotocols are
 * TBinaryProtocol and TCompactProtocol. It can currently only be used with
 * transports that inherit THeaderTransport.
 *
 * THeaderProtocol does not currently support THTTPServer, TNonblockingServer,
 * or TProcessPoolServer.
 *
 * See doc/specs/HeaderFormat.md for details of the wire format.
 */
function THeaderProtocol(trans) {
  if (!(trans instanceof THeaderTransport)) {
    throw new THeaderProtocolError(
      'Only transports that inherit THeaderTransport can be' +
      ' used with THeaderProtocol'
    );
  }
  this.trans = trans;
  this.setProtocol();
};

THeaderProtocol.prototype.flush = function() {
   // Headers must be written prior to flushing because because
   // you need to calculate the length of the payload for the length
   // field of the header
  this.trans.writeHeaders();
  return this.trans.flush();
};

THeaderProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
  return this.protocol.writeMessageBegin(name, type, seqid);
};

THeaderProtocol.prototype.writeMessageEnd = function() {
  return this.protocol.writeMessageEnd();
};

THeaderProtocol.prototype.writeStructBegin = function(name) {
  return this.protocol.writeStructBegin(name);
};

THeaderProtocol.prototype.writeStructEnd = function() {
  return this.protocol.writeStructEnd();
};

THeaderProtocol.prototype.writeFieldBegin = function(name, type, id) {
  return this.protocol.writeFieldBegin(name, type, id);
}

THeaderProtocol.prototype.writeFieldEnd = function() {
  return this.protocol.writeFieldEnd();
};

THeaderProtocol.prototype.writeFieldStop = function() {
  return this.protocol.writeFieldStop();
};

THeaderProtocol.prototype.writeMapBegin = function(ktype, vtype, size) {
  return this.protocol.writeMapBegin(ktype, vtype, size);
};

THeaderProtocol.prototype.writeMapEnd = function() {
  return this.protocol.writeMapEnd();
};

THeaderProtocol.prototype.writeListBegin = function(etype, size) {
  return this.protocol.writeListBegin(etype, size);
};

THeaderProtocol.prototype.writeListEnd = function() {
  return this.protocol.writeListEnd();
};

THeaderProtocol.prototype.writeSetBegin = function(etype, size) {
  return this.protocol.writeSetBegin(etype, size);
};

THeaderProtocol.prototype.writeSetEnd = function() {
  return this.protocol.writeSetEnd();
};

THeaderProtocol.prototype.writeBool = function(b) {
  return this.protocol.writeBool(b);
};

THeaderProtocol.prototype.writeByte = function(b) {
  return this.protocol.writeByte(b);
};

THeaderProtocol.prototype.writeI16 = function(i16) {
  return this.protocol.writeI16(i16);
};

THeaderProtocol.prototype.writeI32 = function(i32) {
  return this.protocol.writeI32(i32);
};

THeaderProtocol.prototype.writeI64 = function(i64) {
  return this.protocol.writeI64(i64);
};

THeaderProtocol.prototype.writeDouble = function(dub) {
  return this.protocol.writeDouble(dub);
};

THeaderProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
  return this.protocol.writeStringOrBinary(name, encoding, arg);
};

THeaderProtocol.prototype.writeString = function(arg) {
  return this.protocol.writeString(arg);
};

THeaderProtocol.prototype.writeBinary = function(arg) {
  return this.protocol.writeBinary(arg);
};

THeaderProtocol.prototype.readMessageBegin = function() {
  this.trans.readHeaders();
  this.setProtocol();
  return this.protocol.readMessageBegin();
};

THeaderProtocol.prototype.readMessageEnd = function() {
  return this.protocol.readMessageEnd();
};

THeaderProtocol.prototype.readStructBegin = function() {
  return this.protocol.readStructBegin();
};

THeaderProtocol.prototype.readStructEnd = function() {
  return this.protocol.readStructEnd();
};

THeaderProtocol.prototype.readFieldBegin = function() {
  return this.protocol.readFieldBegin();
};

THeaderProtocol.prototype.readFieldEnd = function() {
  return this.protocol.readFieldEnd();
};

THeaderProtocol.prototype.readMapBegin = function() {
  return this.protocol.readMapBegin();
};

THeaderProtocol.prototype.readMapEnd = function() {
  return this.protocol.readMapEnd();
};

THeaderProtocol.prototype.readListBegin = function() {
  return this.protocol.readListBegin();
};

THeaderProtocol.prototype.readListEnd = function() {
  return this.protocol.readListEnd();
};

THeaderProtocol.prototype.readSetBegin = function() {
  return this.protocol.readSetBegin();
};

THeaderProtocol.prototype.readSetEnd = function() {
  return this.protocol.readSetEnd();
};

THeaderProtocol.prototype.readBool = function() {
  return this.protocol.readBool();
};

THeaderProtocol.prototype.readByte = function() {
  return this.protocol.readByte();
};

THeaderProtocol.prototype.readI16 = function() {
  return this.protocol.readI16();
};

THeaderProtocol.prototype.readI32 = function() {
  return this.protocol.readI32();
};

THeaderProtocol.prototype.readI64 = function() {
  return this.protocol.readI64();
};

THeaderProtocol.prototype.readDouble = function() {
  return this.protocol.readDouble();
};

THeaderProtocol.prototype.readBinary = function() {
  return this.protocol.readBinary();
};

THeaderProtocol.prototype.readString = function() {
  return this.protocol.readString();
};

THeaderProtocol.prototype.getTransport = function() {
  return this.trans;
};

THeaderProtocol.prototype.skip = function(type) {
  return this.protocol.skip(type);
};

THeaderProtocol.prototype.setProtocol = function(subProtocolId) {
  var subProtocolId = this.trans.getProtocolId();
  if (!ProtocolMap[subProtocolId]) {
    throw new THeaderProtocolError('Headers not supported for protocol ' + subProtocolId);
  }

  this.protocol = new ProtocolMap[subProtocolId](this.trans);
};


/***/ }),

/***/ 5190:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var util = __webpack_require__(1669);
var TCompactProtocol = __webpack_require__(9277);
var TBinaryProtocol = __webpack_require__(4711);
var InputBufferUnderrunError = __webpack_require__(3590);

function THeaderTransportError(message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = this.constructor.name;
  this.message = message;
}

util.inherits(THeaderTransportError, Error);

module.exports = THeaderTransport;

// from HeaderFormat.md
var COMPACT_PROTOCOL_OFFSET = 0;
var COMPACT_PROTOCOL_VERSION_OFFSET = 1;
var FRAME_SIZE_OFFSET = 0;
var HEADER_MAGIC_OFFSET = 32 / 8;
var FLAGS_OFFSET = 48 / 8;
var SEQID_OFFSET = 64 / 8;
var HEADER_SIZE_OFFSET = 96 / 8;
var HEADER_START_OFFSET = 112 / 8;

var HEADER_MAGIC = 0x0FFF;

var TINFO_HEADER_KEY_VALUE_TYPE = 0x01;
var MAX_FRAME_SIZE = 0x3FFFFFFF;

 // A helper class for reading/writing varints. Uses
 // TCompactProtocol under the hood
function VarintHelper(readBuffer) {
  var TBufferedTransport = __webpack_require__(8869);
  this.outputBuffer = null;
  var _this = this;
  this.transport = new TBufferedTransport(null, function(output) {
    _this.outputBuffer = output;
  });

  this.transport.inBuf = readBuffer || Buffer.alloc(0);
  this.transport.writeCursor = this.transport.inBuf.length;
  this.protocol = new TCompactProtocol(this.transport);
};

VarintHelper.prototype.readVarint32 = function() {
  return this.protocol.readVarint32();
};

VarintHelper.prototype.writeVarint32 = function(i) {
  this.protocol.writeVarint32(i);
};

VarintHelper.prototype.readString = function() {
  return this.protocol.readString();
};

VarintHelper.prototype.writeString = function(str) {
  this.protocol.writeString(str);
}

VarintHelper.prototype.getOutCount = function() {
  return this.transport.outCount;
};

VarintHelper.prototype.write = function(str) {
  this.transport.write(str);
};

VarintHelper.prototype.toBuffer = function() {
  this.transport.flush();
  return this.outputBuffer;
};

// from lib/cpp/src/thrift/protocol/TProtocolTypes.h
THeaderTransport.SubprotocolId = {
  BINARY: 0,
  JSON: 1,
  COMPACT: 2,
};

/**
  An abstract transport used as a prototype for other transports
  to enable reading/writing theaders. This should NOT be used as a standalone transport
  The methods in this transport are called by THeaderProtocol, which will call readHeaders/writeHeaders
  in the read/writeMessageBegin methods and parse/write headers to/from a request
  prior to reading/writing.

  The reason this is not a standalone transport type is because different transport types
  have their own individual static receiver methods that are called prior to instantiation.
  There doesn't seem to be a way for THeaderTransport to know which receiver method to use
  without reworking the server API.

  For reading headers from a request, the parsed headers can be retrieved via
  getReadHeader. Similarly, you can set headers to be written on the client via
  setWriteHeader.
 */
function THeaderTransport() {
  this.maxFrameSize = MAX_FRAME_SIZE;
  this.protocolId = THeaderTransport.SubprotocolId.BINARY;
  this.rheaders = {};
  this.wheaders = {};
  this.inBuf = Buffer.alloc(0);
  this.outCount = 0;
  this.flags = null;
  this.seqid = 0;
  this.shouldWriteHeaders = true;
};

var validateHeaders = function(key, value) {
  if (typeof key !== 'string' || typeof value !== 'string') {
    throw new THeaderTransportError('Header key and values must be strings');
  }
};

var validateProtocolId = function(protocolId) {
  var protocols = Object.keys(THeaderTransport.SubprotocolId);
  for (var i = 0; i < protocols.length; i++) {
    if (protocolId === THeaderTransport.SubprotocolId[protocols[i]]) return true;
  }

  throw new Error(protocolId + ' is not a valid protocol id');
};

THeaderTransport.prototype.setSeqId = function(seqid) {
  this.seqid = seqid;
};

THeaderTransport.prototype.getSeqId = function(seqid) {
  return this.seqid;
};

THeaderTransport.prototype.setFlags = function(flags) {
  this.flags = flags;
};

THeaderTransport.prototype.getReadHeaders = function() {
  return this.rheaders;
};

THeaderTransport.prototype.setReadHeader = function(key, value) {
  validateHeaders(key, value);
  this.rheaders[key] = value;
};

THeaderTransport.prototype.clearReadHeaders = function() {
  this.rheaders = {};
};

THeaderTransport.prototype.getWriteHeaders = function() {
  return this.wheaders;
};

THeaderTransport.prototype.setWriteHeader = function(key, value) {
  validateHeaders(key, value);
  this.wheaders[key] = value;
};

THeaderTransport.prototype.clearWriteHeaders = function() {
  this.wheaders = {};
};

THeaderTransport.prototype.setMaxFrameSize = function(frameSize) {
  this.maxFrameSize = frameSize;
};

THeaderTransport.prototype.setProtocolId = function(protocolId) {
  validateProtocolId(protocolId);
  this.protocolId = protocolId;
};

THeaderTransport.prototype.getProtocolId = function() {
  return this.protocolId;
};

var isUnframedBinary = function(readBuffer) {
  var version = readBuffer.readInt32BE();
  return (version & TBinaryProtocol.VERSION_MASK) === TBinaryProtocol.VERSION_1;
}

var isUnframedCompact = function(readBuffer) {
  var protocolId = readBuffer.readInt8(COMPACT_PROTOCOL_OFFSET);
  var version = readBuffer.readInt8(COMPACT_PROTOCOL_VERSION_OFFSET);
  return protocolId === TCompactProtocol.PROTOCOL_ID &&
    (version & TCompactProtocol.VERSION_MASK) === TCompactProtocol.VERSION_N;
}

THeaderTransport.prototype.readHeaders = function() {
  var readBuffer = this.inBuf;

  var isUnframed = false;
  if (isUnframedBinary(readBuffer)) {
    this.setProtocolId(THeaderTransport.SubprotocolId.BINARY);
    isUnframed = true;
  }

  if (isUnframedCompact(readBuffer)) {
    this.setProtocolId(THeaderTransport.SubprotocolId.COMPACT);
    isUnframed = true;
  }

  if (isUnframed) {
    this.shouldWriteHeaders = false;
    return;
  }

  var frameSize = readBuffer.readInt32BE(FRAME_SIZE_OFFSET);
  if (frameSize > this.maxFrameSize) {
    throw new THeaderTransportError('Frame exceeds maximum frame size');
  }

  var headerMagic = readBuffer.readInt16BE(HEADER_MAGIC_OFFSET);
  this.shouldWriteHeaders = headerMagic === HEADER_MAGIC;
  if (!this.shouldWriteHeaders) {
    return;
  }

  this.setFlags(readBuffer.readInt16BE(FLAGS_OFFSET));
  this.setSeqId(readBuffer.readInt32BE(SEQID_OFFSET));
  var headerSize = readBuffer.readInt16BE(HEADER_SIZE_OFFSET) * 4;
  var endOfHeaders = HEADER_START_OFFSET + headerSize;
  if (endOfHeaders > readBuffer.length) {
    throw new THeaderTransportError('Header size is greater than frame size');
  }

  var headerBuffer = Buffer.alloc(headerSize);
  readBuffer.copy(headerBuffer, 0, HEADER_START_OFFSET, endOfHeaders);

  var varintHelper = new VarintHelper(headerBuffer);
  this.setProtocolId(varintHelper.readVarint32());
  var transformCount = varintHelper.readVarint32();
  if (transformCount > 0) {
    throw new THeaderTransportError('Transforms are not yet supported');
  }

  while (true) {
    try {
      var headerType = varintHelper.readVarint32();
      if (headerType !== TINFO_HEADER_KEY_VALUE_TYPE) {
        break;
      }

      var numberOfHeaders = varintHelper.readVarint32();
      for (var i = 0; i < numberOfHeaders; i++) {
        var key = varintHelper.readString();
        var value = varintHelper.readString();
        this.setReadHeader(key, value);
      }
    } catch (e) {
      if (e instanceof InputBufferUnderrunError) {
        break;
      }
      throw e;
    }
  }

  // moves the read cursor past the headers
  this.read(endOfHeaders);
  return this.getReadHeaders();
};

THeaderTransport.prototype.writeHeaders = function() {
  // only write headers on the server if the client contained headers
  if (!this.shouldWriteHeaders) {
    return;
  }
  var headers = this.getWriteHeaders();

  var varintWriter = new VarintHelper();
  varintWriter.writeVarint32(this.protocolId);
  varintWriter.writeVarint32(0); // transforms not supported

  // writing info header key values
  var headerKeys = Object.keys(headers);
  if (headerKeys.length > 0) {
    varintWriter.writeVarint32(TINFO_HEADER_KEY_VALUE_TYPE);
    varintWriter.writeVarint32(headerKeys.length);
    for (var i = 0; i < headerKeys.length; i++) {
      var key = headerKeys[i];
      var value = headers[key];

      varintWriter.writeString(key);
      varintWriter.writeString(value);
    }
  }
 var headerSizeWithoutPadding = varintWriter.getOutCount();
  var paddingNeeded = (4 - (headerSizeWithoutPadding % 4)) % 4;

  var headerSize = Buffer.alloc(2);
  headerSize.writeInt16BE(Math.floor((headerSizeWithoutPadding + paddingNeeded) / 4));

  var paddingBuffer = Buffer.alloc(paddingNeeded);
  paddingBuffer.fill(0x00);
  varintWriter.write(paddingBuffer);
  var headerContentBuffer = varintWriter.toBuffer();
  var frameSize = Buffer.alloc(4);
  frameSize.writeInt32BE(10 + this.outCount + headerContentBuffer.length);
  var headerMagic = Buffer.alloc(2);
  headerMagic.writeInt16BE(HEADER_MAGIC);

  // flags are not yet supported, so write a zero
  var flags = Buffer.alloc(2);
  flags.writeInt16BE(0);

  var seqid = Buffer.alloc(4);
  seqid.writeInt32BE(this.getSeqId());

  var headerBuffer = Buffer.concat([
    frameSize,
    headerMagic,
    flags,
    seqid,
    headerSize,
    headerContentBuffer,
  ]);

  this.outBuffers.unshift(headerBuffer);
  this.outCount += headerBuffer.length;
};


/***/ }),

/***/ 3741:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(1669);
var http = __webpack_require__(8605);
var https = __webpack_require__(7211);
var EventEmitter = __webpack_require__(8614).EventEmitter;
var thrift = __webpack_require__(5406);

var TBufferedTransport = __webpack_require__(8869);
var TBinaryProtocol = __webpack_require__(4711);
var InputBufferUnderrunError = __webpack_require__(3590);

var createClient = __webpack_require__(6243);

/**
 * @class
 * @name ConnectOptions
 * @property {string} transport - The Thrift layered transport to use (TBufferedTransport, etc).
 * @property {string} protocol - The Thrift serialization protocol to use (TBinaryProtocol, etc.).
 * @property {string} path - The URL path to POST to (e.g. "/", "/mySvc", "/thrift/quoteSvc", etc.).
 * @property {object} headers - A standard Node.js header hash, an object hash containing key/value
 *        pairs where the key is the header name string and the value is the header value string.
 * @property {boolean} https - True causes the connection to use https, otherwise http is used.
 * @property {object} nodeOptions - Options passed on to node.
 * @example
 *     //Use a connection that requires ssl/tls, closes the connection after each request,
 *     //  uses the buffered transport layer, uses the JSON protocol and directs RPC traffic
 *     //  to https://thrift.example.com:9090/hello
 *     var thrift = require('thrift');
 *     var options = {
 *        transport: thrift.TBufferedTransport,
 *        protocol: thrift.TJSONProtocol,
 *        path: "/hello",
 *        headers: {"Connection": "close"},
 *        https: true
 *     };
 *     var con = thrift.createHttpConnection("thrift.example.com", 9090, options);
 *     var client = thrift.createHttpClient(myService, connection);
 *     client.myServiceFunction();
 */

/**
 * Initializes a Thrift HttpConnection instance (use createHttpConnection() rather than
 *    instantiating directly).
 * @constructor
 * @param {ConnectOptions} options - The configuration options to use.
 * @throws {error} Exceptions other than InputBufferUnderrunError are rethrown
 * @event {error} The "error" event is fired when a Node.js error event occurs during
 *     request or response processing, in which case the node error is passed on. An "error"
 *     event may also be fired when the connection can not map a response back to the
 *     appropriate client (an internal error), generating a TApplicationException.
 * @classdesc HttpConnection objects provide Thrift end point transport
 *     semantics implemented over the Node.js http.request() method.
 * @see {@link createHttpConnection}
 */
var HttpConnection = exports.HttpConnection = function(options) {
  //Initialize the emitter base object
  EventEmitter.call(this);

  //Set configuration
  var self = this;
  this.options = options || {};
  this.host = this.options.host;
  this.port = this.options.port;
  this.socketPath = this.options.socketPath;
  this.https = this.options.https || false;
  this.transport = this.options.transport || TBufferedTransport;
  this.protocol = this.options.protocol || TBinaryProtocol;

  //Prepare Node.js options
  this.nodeOptions = {
    host: this.host,
    port: this.port,
    socketPath: this.socketPath,
    path: this.options.path || '/',
    method: 'POST',
    headers: this.options.headers || {},
    responseType: this.options.responseType || null
  };
  for (var attrname in this.options.nodeOptions) {
    this.nodeOptions[attrname] = this.options.nodeOptions[attrname];
  }
  /*jshint -W069 */
  if (! this.nodeOptions.headers['Connection']) {
    this.nodeOptions.headers['Connection'] = 'keep-alive';
  }
  /*jshint +W069 */

  //The sequence map is used to map seqIDs back to the
  //  calling client in multiplexed scenarios
  this.seqId2Service = {};

  function decodeCallback(transport_with_data) {
    var proto = new self.protocol(transport_with_data);
    try {
      while (true) {
        var header = proto.readMessageBegin();
        var dummy_seqid = header.rseqid * -1;
        var client = self.client;
        //The Multiplexed Protocol stores a hash of seqid to service names
        //  in seqId2Service. If the SeqId is found in the hash we need to
        //  lookup the appropriate client for this call.
        //  The client var is a single client object when not multiplexing,
        //  when using multiplexing it is a service name keyed hash of client
        //  objects.
        //NOTE: The 2 way interdependencies between protocols, transports,
        //  connections and clients in the Node.js implementation are irregular
        //  and make the implementation difficult to extend and maintain. We
        //  should bring this stuff inline with typical thrift I/O stack
        //  operation soon.
        //  --ra
        var service_name = self.seqId2Service[header.rseqid];
        if (service_name) {
          client = self.client[service_name];
          delete self.seqId2Service[header.rseqid];
        }
        /*jshint -W083 */
        client._reqs[dummy_seqid] = function(err, success){
          transport_with_data.commitPosition();
          var clientCallback = client._reqs[header.rseqid];
          delete client._reqs[header.rseqid];
          if (clientCallback) {
            process.nextTick(function() {
              clientCallback(err, success);
            });
          }
        };
        /*jshint +W083 */
        if(client['recv_' + header.fname]) {
          client['recv_' + header.fname](proto, header.mtype, dummy_seqid);
        } else {
          delete client._reqs[dummy_seqid];
          self.emit("error",
                    new thrift.TApplicationException(
                       thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
                       "Received a response to an unknown RPC function"));
        }
      }
    }
    catch (e) {
      if (e instanceof InputBufferUnderrunError) {
        transport_with_data.rollbackPosition();
      } else {
        self.emit('error', e);
      }
    }
  }


  //Response handler
  //////////////////////////////////////////////////
  this.responseCallback = function(response) {
    var data = [];
    var dataLen = 0;

    if (response.statusCode !== 200) {
      this.emit("error", new THTTPException(response));
    }

    response.on('error', function (e) {
      self.emit("error", e);
    });

    // When running directly under node, chunk will be a buffer,
    // however, when running in a Browser (e.g. Browserify), chunk
    // will be a string or an ArrayBuffer.
    response.on('data', function (chunk) {
      if ((typeof chunk == 'string') ||
          (Object.prototype.toString.call(chunk) == '[object Uint8Array]')) {
        // Wrap ArrayBuffer/string in a Buffer so data[i].copy will work
        data.push(new Buffer(chunk));
      } else {
        data.push(chunk);
      }
      dataLen += chunk.length;
    });

    response.on('end', function(){
      var buf = new Buffer(dataLen);
      for (var i=0, len=data.length, pos=0; i<len; i++) {
        data[i].copy(buf, pos);
        pos += data[i].length;
      }
      //Get the receiver function for the transport and
      //  call it with the buffer
      self.transport.receiver(decodeCallback)(buf);
    });
  };
};
util.inherits(HttpConnection, EventEmitter);

/**
 * Writes Thrift message data to the connection
 * @param {Buffer} data - A Node.js Buffer containing the data to write
 * @returns {void} No return value.
 * @event {error} the "error" event is raised upon request failure passing the
 *     Node.js error object to the listener.
 */
HttpConnection.prototype.write = function(data) {
  var self = this;
  var opts = self.nodeOptions;
  opts.headers["Content-length"] = data.length;
  if (!opts.headers["Content-Type"])
    opts.headers["Content-Type"] = "application/x-thrift";
  var req = (self.https) ?
      https.request(opts, self.responseCallback) :
      http.request(opts, self.responseCallback);
  req.on('error', function(err) {
    self.emit("error", err);
  });
  req.write(data);
  req.end();
};

/**
 * Creates a new HttpConnection object, used by Thrift clients to connect
 *    to Thrift HTTP based servers.
 * @param {string} host - The host name or IP to connect to.
 * @param {number} port - The TCP port to connect to.
 * @param {ConnectOptions} options - The configuration options to use.
 * @returns {HttpConnection} The connection object.
 * @see {@link ConnectOptions}
 */
exports.createHttpConnection = function(host, port, options) {
  options.host = host;
  options.port = port || 80;
  return new HttpConnection(options);
};

exports.createHttpUDSConnection = function(path, options) {
  options.socketPath = path;
  return new HttpConnection(options);
};

exports.createHttpClient = createClient


function THTTPException(response) {
  thrift.TApplicationException.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = this.constructor.name;
  this.statusCode = response.statusCode;
  this.response = response;
  this.type = thrift.TApplicationExceptionType.PROTOCOL_ERROR;
  this.message = "Received a response with a bad HTTP status code: " + response.statusCode;
}
util.inherits(THTTPException, thrift.TApplicationException);


/***/ }),

/***/ 7392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
exports.Thrift = __webpack_require__(5406);

var log = __webpack_require__(1291);
exports.setLogFunc = log.setLogFunc;
exports.setLogLevel = log.setLogLevel;
exports.getLogLevel = log.getLogLevel;

var connection = __webpack_require__(6526);
exports.Connection = connection.Connection;
exports.createClient = connection.createClient;
exports.createConnection = connection.createConnection;
exports.createUDSConnection = connection.createUDSConnection;
exports.createSSLConnection = connection.createSSLConnection;
exports.createStdIOClient = connection.createStdIOClient;
exports.createStdIOConnection = connection.createStdIOConnection;

var httpConnection = __webpack_require__(3741);
exports.HttpConnection = httpConnection.HttpConnection;
exports.createHttpConnection = httpConnection.createHttpConnection;
exports.createHttpUDSConnection = httpConnection.createHttpUDSConnection;
exports.createHttpClient = httpConnection.createHttpClient;

var wsConnection = __webpack_require__(5455);
exports.WSConnection = wsConnection.WSConnection;
exports.createWSConnection = wsConnection.createWSConnection;
exports.createWSClient = wsConnection.createWSClient;

var xhrConnection = __webpack_require__(4050);
exports.XHRConnection = xhrConnection.XHRConnection;
exports.createXHRConnection = xhrConnection.createXHRConnection;
exports.createXHRClient = xhrConnection.createXHRClient;

var server = __webpack_require__(6969);
exports.createServer = server.createServer;
exports.createMultiplexServer = server.createMultiplexServer;

var web_server = __webpack_require__(8954);
exports.createWebServer = web_server.createWebServer;

exports.Int64 = __webpack_require__(135);
exports.Q = __webpack_require__(8486);

var mpxProcessor = __webpack_require__(9023);
var mpxProtocol = __webpack_require__(4184);
exports.MultiplexedProcessor = mpxProcessor.MultiplexedProcessor;
exports.Multiplexer = mpxProtocol.Multiplexer;

/*
 * Export transport and protocol so they can be used outside of a
 * cassandra/server context
 */
exports.TBufferedTransport = __webpack_require__(8869);
exports.TFramedTransport = __webpack_require__(7584);

exports.TJSONProtocol = __webpack_require__(5086);
exports.TBinaryProtocol = __webpack_require__(4711);
exports.TCompactProtocol = __webpack_require__(9277);
exports.THeaderProtocol = __webpack_require__(6357);


/***/ }),

/***/ 3590:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(1669);

module.exports = InputBufferUnderrunError;

function InputBufferUnderrunError(message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = this.constructor.name;
  this.message = message;
};

util.inherits(InputBufferUnderrunError, Error);


/***/ }),

/***/ 5197:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Int64 = __webpack_require__(135);

var Int64Util = module.exports = {};

var POW2_24 = Math.pow(2, 24);
var POW2_31 = Math.pow(2, 31);
var POW2_32 = Math.pow(2, 32);
var POW10_11 = Math.pow(10, 11);

Int64Util.toDecimalString = function(i64) {
  var b = i64.buffer;
  var o = i64.offset;
  if ((!b[o] && !(b[o + 1] & 0xe0)) ||
      (!~b[o] && !~(b[o + 1] & 0xe0))) {
    // The magnitude is small enough.
    return i64.toString();
  } else {
    var negative = b[o] & 0x80;
    if (negative) {
      // 2's complement
      var incremented = false;
      var buffer = new Buffer(8);
      for (var i = 7; i >= 0; --i) {
        buffer[i] = (~b[o + i] + (incremented ? 0 : 1)) & 0xff;
        incremented |= b[o + i];
      }
      b = buffer;
    }
    var high2 = b[o + 1] + (b[o] << 8);
    // Lesser 11 digits with exceeding values but is under 53 bits capacity.
    var low = b[o + 7] + (b[o + 6] << 8) + (b[o + 5] << 16)
        + b[o + 4] * POW2_24  // Bit shift renders 32th bit as sign, so use multiplication
        + (b[o + 3] + (b[o + 2] << 8)) * POW2_32 + high2 * 74976710656;  // The literal is 2^48 % 10^11
    // 12th digit and greater.
    var high = Math.floor(low / POW10_11) + high2 * 2814;  // The literal is 2^48 / 10^11
    // Make it exactly 11 with leading zeros.
    low = ('00000000000' + String(low % POW10_11)).slice(-11);
    return (negative ? '-' : '') + String(high) + low;
  }
};

Int64Util.fromDecimalString = function(text) {
  var negative = text.charAt(0) === '-';
  if (text.length < (negative ? 17 : 16)) {
    // The magnitude is smaller than 2^53.
    return new Int64(+text);
  } else if (text.length > (negative ? 20 : 19)) {
    throw new RangeError('Too many digits for Int64: ' + text);
  } else {
    // Most significant (up to 5) digits
    var high5 = +text.slice(negative ? 1 : 0, -15);
    var low = +text.slice(-15) + high5 * 2764472320;  // The literal is 10^15 % 2^32
    var high = Math.floor(low / POW2_32) + high5 * 232830;  // The literal is 10^15 / 2^&32
    low = low % POW2_32;
    if (high >= POW2_31 &&
        !(negative && high == POW2_31 && low == 0)  // Allow minimum Int64
       ) {
      throw new RangeError('The magnitude is too large for Int64.');
    }
    if (negative) {
      // 2's complement
      high = ~high;
      if (low === 0) {
        high = (high + 1) & 0xffffffff;
      } else {
        low = ~low + 1;
      }
      high = 0x80000000 | high;
    }
    return new Int64(high, low);
  }
};


/***/ }),

/***/ 6502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Imported from Douglas Crockford's reference implementation with minimum modification
 * to handle Int64.
 *
 * https://github.com/douglascrockford/JSON-js/blob/c98948ae1944a28e2e8ebc3717894e580aeaaa05/json_parse.js
 *
 * Original license header:
 *
 * json_parse.js
 * 2015-05-02
 * Public Domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */


/*jslint for */

/*property
    at, b, call, charAt, f, fromCharCode, hasOwnProperty, message, n, name,
    prototype, push, r, t, text
*/

var Int64 = __webpack_require__(135);
var Int64Util = __webpack_require__(5197);

var json_parse = module.exports = (function () {
    "use strict";

// This is a function that can parse a JSON text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,     // The index of the current character
        ch,     // The current character
        escapee = {
            '"': '"',
            '\\': '\\',
            '/': '/',
            b: '\b',
            f: '\f',
            n: '\n',
            r: '\r',
            t: '\t'
        },
        text,

        error = function (m) {

// Call error when something is wrong.

            throw new SyntaxError(m);
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected '" + c + "' instead of '" + ch + "'");
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at += 1;
            return ch;
        },

        number = function () {

// Parse a number value.

            var number,
                string = '';

            if (ch === '-') {
                string = '-';
                next('-');
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
            if (ch === '.') {
                string += '.';
                while (next() && ch >= '0' && ch <= '9') {
                    string += ch;
                }
            }
            if (ch === 'e' || ch === 'E') {
                string += ch;
                next();
                if (ch === '-' || ch === '+') {
                    string += ch;
                    next();
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
            }
            number = +string;
            if (!isFinite(number)) {
                error("Bad number");
            } else if (number >= Int64.MAX_INT || number <= Int64.MIN_INT) {
                // Return raw string for further process in TJSONProtocol
                return string;
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                uffff;

// When parsing for string values, we must look for " and \ characters.

            if (ch === '"') {
                while (next()) {
                    if (ch === '"') {
                        next();
                        return string;
                    }
                    if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        white = function () {

// Skip whitespace.

            while (ch && ch <= ' ') {
                next();
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            }
            error("Unexpected '" + ch + "'");
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                if (ch === ']') {
                    next(']');
                    return array;   // empty array
                }
                while (ch) {
                    array.push(value());
                    white();
                    if (ch === ']') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                if (ch === '}') {
                    next('}');
                    return object;   // empty object
                }
                while (ch) {
                    key = string();
                    white();
                    next(':');
                    if (Object.hasOwnProperty.call(object, key)) {
                        error('Duplicate key "' + key + '"');
                    }
                    object[key] = value();
                    white();
                    if (ch === '}') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
            return string();
        case '-':
            return number();
        default:
            return ch >= '0' && ch <= '9'
                ? number()
                : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source) {
        var result;

        text = source;
        at = 0;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

        return result;
    };
}());


/***/ }),

/***/ 5086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var Int64 = __webpack_require__(135);
var Thrift = __webpack_require__(5406);
var Type = Thrift.Type;
var util = __webpack_require__(1669);

var Int64Util = __webpack_require__(5197);
var json_parse = __webpack_require__(6502);

var InputBufferUnderrunError = __webpack_require__(3590);

module.exports = TJSONProtocol;

/**
 * Initializes a Thrift JSON protocol instance.
 * @constructor
 * @param {Thrift.Transport} trans - The transport to serialize to/from.
 * @classdesc Apache Thrift Protocols perform serialization which enables cross
 * language RPC. The Protocol type is the JavaScript browser implementation
 * of the Apache Thrift TJSONProtocol.
 * @example
 *     var protocol  = new Thrift.Protocol(transport);
 */
function TJSONProtocol(trans) {
  this.tstack = [];
  this.tpos = [];
  this.trans = trans;
};

/**
 * Thrift IDL type Id to string mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
TJSONProtocol.Type = {};
TJSONProtocol.Type[Type.BOOL] = '"tf"';
TJSONProtocol.Type[Type.BYTE] = '"i8"';
TJSONProtocol.Type[Type.I16] = '"i16"';
TJSONProtocol.Type[Type.I32] = '"i32"';
TJSONProtocol.Type[Type.I64] = '"i64"';
TJSONProtocol.Type[Type.DOUBLE] = '"dbl"';
TJSONProtocol.Type[Type.STRUCT] = '"rec"';
TJSONProtocol.Type[Type.STRING] = '"str"';
TJSONProtocol.Type[Type.MAP] = '"map"';
TJSONProtocol.Type[Type.LIST] = '"lst"';
TJSONProtocol.Type[Type.SET] = '"set"';

/**
 * Thrift IDL type string to Id mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
TJSONProtocol.RType = {};
TJSONProtocol.RType.tf = Type.BOOL;
TJSONProtocol.RType.i8 = Type.BYTE;
TJSONProtocol.RType.i16 = Type.I16;
TJSONProtocol.RType.i32 = Type.I32;
TJSONProtocol.RType.i64 = Type.I64;
TJSONProtocol.RType.dbl = Type.DOUBLE;
TJSONProtocol.RType.rec = Type.STRUCT;
TJSONProtocol.RType.str = Type.STRING;
TJSONProtocol.RType.map = Type.MAP;
TJSONProtocol.RType.lst = Type.LIST;
TJSONProtocol.RType.set = Type.SET;

/**
 * The TJSONProtocol version number.
 * @readonly
 * @const {number} Version
 * @memberof Thrift.Protocol
 */
TJSONProtocol.Version = 1;

TJSONProtocol.prototype.flush = function() {
  this.writeToTransportIfStackIsFlushable();
  return this.trans.flush();
};

TJSONProtocol.prototype.writeToTransportIfStackIsFlushable = function() {
  if (this.tstack.length === 1) {
    this.trans.write(this.tstack.pop());
  }
};

/**
 * Serializes the beginning of a Thrift RPC message.
 * @param {string} name - The service method to call.
 * @param {Thrift.MessageType} messageType - The type of method call.
 * @param {number} seqid - The sequence number of this call (always 0 in Apache Thrift).
 */
TJSONProtocol.prototype.writeMessageBegin = function(name, messageType, seqid) {
  this.tstack.push([TJSONProtocol.Version, '"' + name + '"', messageType, seqid]);
};

/**
 * Serializes the end of a Thrift RPC message.
 */
TJSONProtocol.prototype.writeMessageEnd = function() {
  var obj = this.tstack.pop();

  this.wobj = this.tstack.pop();
  this.wobj.push(obj);

  this.wbuf = '[' + this.wobj.join(',') + ']';

  // we assume there is nothing more to come so we write
  this.trans.write(this.wbuf);
};

/**
 * Serializes the beginning of a struct.
 * @param {string} name - The name of the struct.
 */
TJSONProtocol.prototype.writeStructBegin = function(name) {
  this.tpos.push(this.tstack.length);
  this.tstack.push({});
};

/**
 * Serializes the end of a struct.
 */
TJSONProtocol.prototype.writeStructEnd = function() {
  var p = this.tpos.pop();
  var struct = this.tstack[p];
  var str = '{';
  var first = true;
  for (var key in struct) {
    if (first) {
      first = false;
    } else {
      str += ',';
    }

    str += key + ':' + struct[key];
  }

  str += '}';
  this.tstack[p] = str;

  this.writeToTransportIfStackIsFlushable();
};

/**
 * Serializes the beginning of a struct field.
 * @param {string} name - The name of the field.
 * @param {Thrift.Protocol.Type} fieldType - The data type of the field.
 * @param {number} fieldId - The field's unique identifier.
 */
TJSONProtocol.prototype.writeFieldBegin = function(name, fieldType, fieldId) {
  this.tpos.push(this.tstack.length);
  this.tstack.push({ 'fieldId': '"' +
    fieldId + '"', 'fieldType': TJSONProtocol.Type[fieldType]
  });
};

/**
 * Serializes the end of a field.
 */
TJSONProtocol.prototype.writeFieldEnd = function() {
  var value = this.tstack.pop();
  var fieldInfo = this.tstack.pop();

  if (':' + value === ":[object Object]") {
    this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
      fieldInfo.fieldType + ':' + JSON.stringify(value) + '}';
  } else {
    this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
      fieldInfo.fieldType + ':' + value + '}';
  }
  this.tpos.pop();

  this.writeToTransportIfStackIsFlushable();
};

/**
 * Serializes the end of the set of fields for a struct.
 */
TJSONProtocol.prototype.writeFieldStop = function() {
};

/**
 * Serializes the beginning of a map collection.
 * @param {Thrift.Type} keyType - The data type of the key.
 * @param {Thrift.Type} valType - The data type of the value.
 * @param {number} [size] - The number of elements in the map (ignored).
 */
TJSONProtocol.prototype.writeMapBegin = function(keyType, valType, size) {
  //size is invalid, we'll set it on end.
  this.tpos.push(this.tstack.length);
  this.tstack.push([TJSONProtocol.Type[keyType], TJSONProtocol.Type[valType], 0]);
};

/**
 * Serializes the end of a map.
 */
TJSONProtocol.prototype.writeMapEnd = function() {
  var p = this.tpos.pop();

  if (p == this.tstack.length) {
    return;
  }

  if ((this.tstack.length - p - 1) % 2 !== 0) {
    this.tstack.push('');
  }

  var size = (this.tstack.length - p - 1) / 2;

  this.tstack[p][this.tstack[p].length - 1] = size;

  var map = '}';
  var first = true;
  while (this.tstack.length > p + 1) {
    var v = this.tstack.pop();
    var k = this.tstack.pop();
    if (first) {
      first = false;
    } else {
      map = ',' + map;
    }

    if (! isNaN(k)) { k = '"' + k + '"'; } //json "keys" need to be strings
    map = k + ':' + v + map;
  }
  map = '{' + map;

  this.tstack[p].push(map);
  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';

  this.writeToTransportIfStackIsFlushable();
};

/**
 * Serializes the beginning of a list collection.
 * @param {Thrift.Type} elemType - The data type of the elements.
 * @param {number} size - The number of elements in the list.
 */
TJSONProtocol.prototype.writeListBegin = function(elemType, size) {
  this.tpos.push(this.tstack.length);
  this.tstack.push([TJSONProtocol.Type[elemType], size]);
};

/**
 * Serializes the end of a list.
 */
TJSONProtocol.prototype.writeListEnd = function() {
  var p = this.tpos.pop();

  while (this.tstack.length > p + 1) {
    var tmpVal = this.tstack[p + 1];
    this.tstack.splice(p + 1, 1);
    this.tstack[p].push(tmpVal);
  }

  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';

  this.writeToTransportIfStackIsFlushable();
};

/**
 * Serializes the beginning of a set collection.
 * @param {Thrift.Type} elemType - The data type of the elements.
 * @param {number} size - The number of elements in the list.
 */
TJSONProtocol.prototype.writeSetBegin = function(elemType, size) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([TJSONProtocol.Type[elemType], size]);
};

/**
 * Serializes the end of a set.
 */
TJSONProtocol.prototype.writeSetEnd = function() {
  var p = this.tpos.pop();

  while (this.tstack.length > p + 1) {
    var tmpVal = this.tstack[p + 1];
    this.tstack.splice(p + 1, 1);
    this.tstack[p].push(tmpVal);
  }

  this.tstack[p] = '[' + this.tstack[p].join(',') + ']';

  this.writeToTransportIfStackIsFlushable();
};

/** Serializes a boolean */
TJSONProtocol.prototype.writeBool = function(bool) {
  this.tstack.push(bool ? 1 : 0);
};

/** Serializes a number */
TJSONProtocol.prototype.writeByte = function(byte) {
  this.tstack.push(byte);
};

/** Serializes a number */
TJSONProtocol.prototype.writeI16 = function(i16) {
  this.tstack.push(i16);
};

/** Serializes a number */
TJSONProtocol.prototype.writeI32 = function(i32) {
  this.tstack.push(i32);
};

/** Serializes a number */
TJSONProtocol.prototype.writeI64 = function(i64) {
  if (i64 instanceof Int64) {
    this.tstack.push(Int64Util.toDecimalString(i64));
  } else {
    this.tstack.push(i64);
  }
};

/** Serializes a number */
TJSONProtocol.prototype.writeDouble = function(dub) {
  this.tstack.push(dub);
};

/** Serializes a string */
TJSONProtocol.prototype.writeString = function(arg) {
  // We do not encode uri components for wire transfer:
  if (arg === null) {
      this.tstack.push(null);
  } else {
      if (typeof arg === 'string') {
        var str = arg;
      } else if (arg instanceof Buffer) {
        var str = arg.toString('utf8');
      } else {
        throw new Error('writeString called without a string/Buffer argument: ' + arg);
      }

      // concat may be slower than building a byte buffer
      var escapedString = '';
      for (var i = 0; i < str.length; i++) {
          var ch = str.charAt(i);      // a single double quote: "
          if (ch === '\"') {
              escapedString += '\\\"'; // write out as: \"
          } else if (ch === '\\') {    // a single backslash: \
              escapedString += '\\\\'; // write out as: \\
          /* Currently escaped forward slashes break TJSONProtocol.
           * As it stands, we can simply pass forward slashes into
           * our strings across the wire without being escaped.
           * I think this is the protocol's bug, not thrift.js
           * } else if(ch === '/') {   // a single forward slash: /
           *  escapedString += '\\/';  // write out as \/
           * }
           */
          } else if (ch === '\b') {    // a single backspace: invisible
              escapedString += '\\b';  // write out as: \b"
          } else if (ch === '\f') {    // a single formfeed: invisible
              escapedString += '\\f';  // write out as: \f"
          } else if (ch === '\n') {    // a single newline: invisible
              escapedString += '\\n';  // write out as: \n"
          } else if (ch === '\r') {    // a single return: invisible
              escapedString += '\\r';  // write out as: \r"
          } else if (ch === '\t') {    // a single tab: invisible
              escapedString += '\\t';  // write out as: \t"
          } else {
              escapedString += ch;     // Else it need not be escaped
          }
      }
      this.tstack.push('"' + escapedString + '"');
  }
};

/** Serializes a string */
TJSONProtocol.prototype.writeBinary = function(arg) {
  if (typeof arg === 'string') {
    var buf = new Buffer(arg, 'binary');
  } else if (arg instanceof Buffer ||
             Object.prototype.toString.call(arg) == '[object Uint8Array]')  {
    var buf = arg;
  } else {
    throw new Error('writeBinary called without a string/Buffer argument: ' + arg);
  }
  this.tstack.push('"' + buf.toString('base64') + '"');
};

/**
 * @class
 * @name AnonReadMessageBeginReturn
 * @property {string} fname - The name of the service method.
 * @property {Thrift.MessageType} mtype - The type of message call.
 * @property {number} rseqid - The sequence number of the message (0 in Thrift RPC).
 */
/**
 * Deserializes the beginning of a message.
 * @returns {AnonReadMessageBeginReturn}
 */
TJSONProtocol.prototype.readMessageBegin = function() {
  this.rstack = [];
  this.rpos = [];

  //Borrow the inbound transport buffer and ensure data is present/consistent
  var transBuf = this.trans.borrow();
  if (transBuf.readIndex >= transBuf.writeIndex) {
    throw new InputBufferUnderrunError();
  }
  var cursor = transBuf.readIndex;

  if (transBuf.buf[cursor] !== 0x5B) { //[
    throw new Error("Malformed JSON input, no opening bracket");
  }

  //Parse a single message (there may be several in the buffer)
  //  TODO: Handle characters using multiple code units
  cursor++;
  var openBracketCount = 1;
  var inString = false;
  for (; cursor < transBuf.writeIndex; cursor++) {
    var chr = transBuf.buf[cursor];
    //we use hexa charcode here because data[i] returns an int and not a char
    if (inString) {
      if (chr === 0x22) { //"
        inString = false;
      } else if (chr === 0x5C) { //\
        //escaped character, skip
        cursor += 1;
      }
    } else {
      if (chr === 0x5B) { //[
        openBracketCount += 1;
      } else if (chr === 0x5D) { //]
        openBracketCount -= 1;
        if (openBracketCount === 0) {
          //end of json message detected
          break;
        }
      } else if (chr === 0x22) { //"
        inString = true;
      }
    }
  }

  if (openBracketCount !== 0) {
    // Missing closing bracket. Can be buffer underrun.
    throw new InputBufferUnderrunError();
  }

  //Reconstitute the JSON object and conume the necessary bytes
  this.robj = json_parse(transBuf.buf.slice(transBuf.readIndex, cursor+1).toString());
  this.trans.consume(cursor + 1 - transBuf.readIndex);

  //Verify the protocol version
  var version = this.robj.shift();
  if (version != TJSONProtocol.Version) {
    throw new Error('Wrong thrift protocol version: ' + version);
  }

  //Objectify the thrift message {name/type/sequence-number} for return
  // and then save the JSON object in rstack
  var r = {};
  r.fname = this.robj.shift();
  r.mtype = this.robj.shift();
  r.rseqid = this.robj.shift();
  this.rstack.push(this.robj.shift());
  return r;
};

/** Deserializes the end of a message. */
TJSONProtocol.prototype.readMessageEnd = function() {
};

/**
 * Deserializes the beginning of a struct.
 * @param {string} [name] - The name of the struct (ignored)
 * @returns {object} - An object with an empty string fname property
 */
TJSONProtocol.prototype.readStructBegin = function() {
  var r = {};
  r.fname = '';

  //incase this is an array of structs
  if (this.rstack[this.rstack.length - 1] instanceof Array) {
    this.rstack.push(this.rstack[this.rstack.length - 1].shift());
  }

  return r;
};

/** Deserializes the end of a struct. */
TJSONProtocol.prototype.readStructEnd = function() {
  this.rstack.pop();
};

/**
 * @class
 * @name AnonReadFieldBeginReturn
 * @property {string} fname - The name of the field (always '').
 * @property {Thrift.Type} ftype - The data type of the field.
 * @property {number} fid - The unique identifier of the field.
 */
/**
 * Deserializes the beginning of a field.
 * @returns {AnonReadFieldBeginReturn}
 */
TJSONProtocol.prototype.readFieldBegin = function() {
  var r = {};

  var fid = -1;
  var ftype = Type.STOP;

  //get a fieldId
  for (var f in (this.rstack[this.rstack.length - 1])) {
    if (f === null) {
      continue;
    }

    fid = parseInt(f, 10);
    this.rpos.push(this.rstack.length);

    var field = this.rstack[this.rstack.length - 1][fid];

    //remove so we don't see it again
    delete this.rstack[this.rstack.length - 1][fid];

    this.rstack.push(field);

    break;
  }

  if (fid != -1) {
    //should only be 1 of these but this is the only
    //way to match a key
    for (var i in (this.rstack[this.rstack.length - 1])) {
      if (TJSONProtocol.RType[i] === null) {
        continue;
      }

      ftype = TJSONProtocol.RType[i];
      this.rstack[this.rstack.length - 1] = this.rstack[this.rstack.length - 1][i];
    }
  }

  r.fname = '';
  r.ftype = ftype;
  r.fid = fid;

  return r;
};

/** Deserializes the end of a field. */
TJSONProtocol.prototype.readFieldEnd = function() {
  var pos = this.rpos.pop();

  //get back to the right place in the stack
  while (this.rstack.length > pos) {
    this.rstack.pop();
  }
};

/**
 * @class
 * @name AnonReadMapBeginReturn
 * @property {Thrift.Type} ktype - The data type of the key.
 * @property {Thrift.Type} vtype - The data type of the value.
 * @property {number} size - The number of elements in the map.
 */
/**
 * Deserializes the beginning of a map.
 * @returns {AnonReadMapBeginReturn}
 */
TJSONProtocol.prototype.readMapBegin = function() {
  var map = this.rstack.pop();
  var first = map.shift();
  if (first instanceof Array) {
    this.rstack.push(map);
    map = first;
    first = map.shift();
  }

  var r = {};
  r.ktype = TJSONProtocol.RType[first];
  r.vtype = TJSONProtocol.RType[map.shift()];
  r.size = map.shift();


  this.rpos.push(this.rstack.length);
  this.rstack.push(map.shift());

  return r;
};

/** Deserializes the end of a map. */
TJSONProtocol.prototype.readMapEnd = function() {
  this.readFieldEnd();
};

/**
 * @class
 * @name AnonReadColBeginReturn
 * @property {Thrift.Type} etype - The data type of the element.
 * @property {number} size - The number of elements in the collection.
 */
/**
 * Deserializes the beginning of a list.
 * @returns {AnonReadColBeginReturn}
 */
TJSONProtocol.prototype.readListBegin = function() {
  var list = this.rstack[this.rstack.length - 1];

  var r = {};
  r.etype = TJSONProtocol.RType[list.shift()];
  r.size = list.shift();

  this.rpos.push(this.rstack.length);
  this.rstack.push(list.shift());

  return r;
};

/** Deserializes the end of a list. */
TJSONProtocol.prototype.readListEnd = function() {
  var pos = this.rpos.pop() - 2;
  var st = this.rstack;
  st.pop();
  if (st instanceof Array && st.length > pos && st[pos].length > 0) {
    st.push(st[pos].shift());
  }
};

/**
 * Deserializes the beginning of a set.
 * @returns {AnonReadColBeginReturn}
 */
TJSONProtocol.prototype.readSetBegin = function() {
  return this.readListBegin();
};

/** Deserializes the end of a set. */
TJSONProtocol.prototype.readSetEnd = function() {
  return this.readListEnd();
};

TJSONProtocol.prototype.readBool = function() {
  return this.readValue() == '1';
};

TJSONProtocol.prototype.readByte = function() {
  return this.readI32();
};

TJSONProtocol.prototype.readI16 = function() {
  return this.readI32();
};

TJSONProtocol.prototype.readI32 = function(f) {
  return +this.readValue();
}

/** Returns the next value found in the protocol buffer */
TJSONProtocol.prototype.readValue = function(f) {
  if (f === undefined) {
    f = this.rstack[this.rstack.length - 1];
  }

  var r = {};

  if (f instanceof Array) {
    if (f.length === 0) {
      r.value = undefined;
    } else {
      r.value = f.shift();
    }
  } else if (!(f instanceof Int64) && f instanceof Object) {
    for (var i in f) {
      if (i === null) {
        continue;
      }
      this.rstack.push(f[i]);
      delete f[i];

      r.value = i;
      break;
    }
  } else {
    r.value = f;
    this.rstack.pop();
  }

  return r.value;
};

TJSONProtocol.prototype.readI64 = function() {
  var n = this.readValue()
  if (typeof n === 'string') {
    // Assuming no one is sending in 1.11111e+33 format
    return Int64Util.fromDecimalString(n);
  } else {
    return new Int64(n);
  }
};

TJSONProtocol.prototype.readDouble = function() {
  return this.readI32();
};

TJSONProtocol.prototype.readBinary = function() {
  return new Buffer(this.readValue(), 'base64');
};

TJSONProtocol.prototype.readString = function() {
  return this.readValue();
};

/**
 * Returns the underlying transport.
 * @readonly
 * @returns {Thrift.Transport} The underlying transport.
 */
TJSONProtocol.prototype.getTransport = function() {
  return this.trans;
};

/**
 * Method to arbitrarily skip over data
 */
TJSONProtocol.prototype.skip = function(type) {
    switch (type) {
    case Type.BOOL:
      this.readBool();
      break;
    case Type.BYTE:
      this.readByte();
      break;
    case Type.I16:
      this.readI16();
      break;
    case Type.I32:
      this.readI32();
      break;
    case Type.I64:
      this.readI64();
      break;
    case Type.DOUBLE:
      this.readDouble();
      break;
    case Type.STRING:
      this.readString();
      break;
    case Type.STRUCT:
      this.readStructBegin();
      while (true) {
        var r = this.readFieldBegin();
        if (r.ftype === Type.STOP) {
          break;
        }
        this.skip(r.ftype);
        this.readFieldEnd();
      }
      this.readStructEnd();
      break;
    case Type.MAP:
      var mapBegin = this.readMapBegin();
      for (var i = 0; i < mapBegin.size; ++i) {
        this.skip(mapBegin.ktype);
        this.skip(mapBegin.vtype);
      }
      this.readMapEnd();
      break;
    case Type.SET:
      var setBegin = this.readSetBegin();
      for (var i2 = 0; i2 < setBegin.size; ++i2) {
        this.skip(setBegin.etype);
      }
      this.readSetEnd();
      break;
    case Type.LIST:
      var listBegin = this.readListBegin();
      for (var i3 = 0; i3 < listBegin.size; ++i3) {
        this.skip(listBegin.etype);
      }
      this.readListEnd();
      break;
    default:
      throw new  Error("Invalid type: " + type);
  }
};


/***/ }),

/***/ 1291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var util = __webpack_require__(1669);

var disabled = function () {};
var logFunc = console.log;
var logLevel = 'error'; // default level

function factory(level) {
  return function () {
    // better use spread syntax, but due to compatibility,
    // use legacy method here.
    var args = ['thrift: [' + level + '] '].concat(Array.from(arguments));
    return logFunc(util.format.apply(null, args));
  };
}

var trace = disabled;
var debug = disabled;
var error = disabled;
var warning = disabled;
var info = disabled;

exports.setLogFunc = function (func) {
  logFunc = func;
};

var setLogLevel = exports.setLogLevel = function (level) {
  trace = debug = error = warning = info = disabled;
  logLevel = level;
  switch (logLevel) {
  case 'trace':
    trace = factory('TRACE');
  case 'debug':
    debug = factory('DEBUG');
  case 'error':
    error = factory('ERROR');
  case 'warning':
    warning = factory('WARN');
  case 'info':
    info = factory('INFO');
  }
};

// set default
setLogLevel(logLevel);

exports.getLogLevel = function () {
  return logLevel;
};

exports.trace = function () {
  return trace.apply(null, arguments);
};

exports.debug = function () {
  return debug.apply(null, arguments);
};

exports.error = function () {
  return error.apply(null, arguments);
};

exports.warning = function () {
  return warning.apply(null, arguments);
};

exports.info = function () {
  return info.apply(null, arguments);
};


/***/ }),

/***/ 9023:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var Thrift = __webpack_require__(5406);

exports.MultiplexedProcessor = MultiplexedProcessor;

function MultiplexedProcessor(stream, options) {
  this.services = {};
};

MultiplexedProcessor.prototype.registerProcessor = function(name, handler) {
  this.services[name] = handler;
};

MultiplexedProcessor.prototype.process = function(inp, out) {
  var begin = inp.readMessageBegin();

  if (begin.mtype != Thrift.MessageType.CALL && begin.mtype != Thrift.MessageType.ONEWAY) {
    throw new Thrift.TException('TMultiplexedProcessor: Unexpected message type');
  }

  var p = begin.fname.split(':');
  var sname = p[0];
  var fname = p[1];

  if (! (sname in this.services)) {
    throw new Thrift.TException('TMultiplexedProcessor: Unknown service: ' + sname);
  }

  //construct a proxy object which stubs the readMessageBegin
  //for the service
  var inpProxy = {};

  for (var attr in inp) {
    inpProxy[attr] = inp[attr];
  }

  inpProxy.readMessageBegin = function() {
    return {
      fname: fname,
      mtype: begin.mtype,
      rseqid: begin.rseqid
    };
  };

  this.services[sname].process(inpProxy, out);
};


/***/ }),

/***/ 4184:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(1669);
var Thrift = __webpack_require__(5406);

exports.Multiplexer = Multiplexer;

function Wrapper(serviceName, protocol, connection) {

  function MultiplexProtocol(trans, strictRead, strictWrite) {
    protocol.call(this, trans, strictRead, strictWrite);
  };

  util.inherits(MultiplexProtocol, protocol);

  MultiplexProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
    if (type == Thrift.MessageType.CALL || type == Thrift.MessageType.ONEWAY) {
      connection.seqId2Service[seqid] = serviceName;
      MultiplexProtocol.super_.prototype.writeMessageBegin.call(this,
                                                                serviceName + ":" + name,
                                                                type,
                                                                seqid);
    } else {
      MultiplexProtocol.super_.prototype.writeMessageBegin.call(this, name, type, seqid);
    }
  };

  return MultiplexProtocol;
};

function Multiplexer() {
  this.seqid = 0;
};

Multiplexer.prototype.createClient = function(serviceName, ServiceClient, connection) {
  if (ServiceClient.Client) {
    ServiceClient = ServiceClient.Client;
  }
  var writeCb = function(buf, seqid) {
    connection.write(buf,seqid);
  };
  var transport = new connection.transport(undefined, writeCb);
  var protocolWrapper = new Wrapper(serviceName, connection.protocol, connection);
  var client = new ServiceClient(transport, protocolWrapper);
  var self = this;
  client.new_seqid = function() {
    self.seqid += 1;
    return self.seqid;
  };

  if (typeof connection.client !== 'object') {
    connection.client = {};
  }
  connection.client[serviceName] = client;

  return client;
};


/***/ }),

/***/ 6969:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

var constants = __webpack_require__(7619);
var net = __webpack_require__(1631);
var tls = __webpack_require__(4016);

var TBufferedTransport = __webpack_require__(8869);
var TBinaryProtocol = __webpack_require__(4711);
var THeaderProtocol = __webpack_require__(6357);
var InputBufferUnderrunError = __webpack_require__(3590);

/**
 * Create a Thrift server which can serve one or multiple services.
 * @param {object} processor - A normal or multiplexedProcessor (must
 *                             be preconstructed with the desired handler).
 * @param {ServerOptions} options - Optional additional server configuration.
 * @returns {object} - The Apache Thrift Multiplex Server.
 */
exports.createMultiplexServer = function(processor, options) {
  var transport = (options && options.transport) ? options.transport : TBufferedTransport;
  var protocol = (options && options.protocol) ? options.protocol : TBinaryProtocol;

  function serverImpl(stream) {
    var self = this;
    stream.on('error', function(err) {
        self.emit('error', err);
    });
    stream.on('data', transport.receiver(function(transportWithData) {
      var input = new protocol(transportWithData);
      var outputCb = function(buf) {
        try {
            stream.write(buf);
        } catch (err) {
            self.emit('error', err);
            stream.end();
        }
      };

      var output = new protocol(new transport(undefined, outputCb));
      // Read and write need to be performed on the same transport
      // for THeaderProtocol because we should only respond with
      // headers if the request contains headers
      if (protocol === THeaderProtocol) {
        output = input;
        output.trans.onFlush = outputCb;
      }

      try {
        do {
          processor.process(input, output);
          transportWithData.commitPosition();
        } while (true);
      } catch (err) {
        if (err instanceof InputBufferUnderrunError) {
          //The last data in the buffer was not a complete message, wait for the rest
          transportWithData.rollbackPosition();
        }
        else if (err.message === "Invalid type: undefined") {
          //No more data in the buffer
          //This trap is a bit hackish
          //The next step to improve the node behavior here is to have
          //  the compiler generated process method throw a more explicit
          //  error when the network buffer is empty (regardles of the
          //  protocol/transport stack in use) and replace this heuristic.
          //  Also transports should probably not force upper layers to
          //  manage their buffer positions (i.e. rollbackPosition() and
          //  commitPosition() should be eliminated in lieu of a transport
          //  encapsulated buffer management strategy.)
          transportWithData.rollbackPosition();
        }
        else {
          //Unexpected error
          self.emit('error', err);
          stream.end();
        }
      }
    }));

    stream.on('end', function() {
      stream.end();
    });
  }

  if (options && options.tls) {
    if (!('secureProtocol' in options.tls) && !('secureOptions' in options.tls)) {
      options.tls.secureProtocol = "SSLv23_method";
      options.tls.secureOptions = constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3;
    }
    return tls.createServer(options.tls, serverImpl);
  } else {
    return net.createServer(serverImpl);
  }
};

/**
 * Create a single service Apache Thrift server.
 * @param {object} processor - A service class or processor function.
 * @param {ServerOptions} options - Optional additional server configuration.
 * @returns {object} - The Apache Thrift Multiplex Server.
 */
exports.createServer = function(processor, handler, options) {
  if (processor.Processor) {
    processor = processor.Processor;
  }
  return exports.createMultiplexServer(new processor(handler), options);
};


/***/ }),

/***/ 5406:
/***/ ((module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(1669);

var Type = exports.Type = {
  STOP: 0,
  VOID: 1,
  BOOL: 2,
  BYTE: 3,
  I08: 3,
  DOUBLE: 4,
  I16: 6,
  I32: 8,
  I64: 10,
  STRING: 11,
  UTF7: 11,
  STRUCT: 12,
  MAP: 13,
  SET: 14,
  LIST: 15,
  UTF8: 16,
  UTF16: 17
};

exports.MessageType = {
  CALL: 1,
  REPLY: 2,
  EXCEPTION: 3,
  ONEWAY: 4
};

exports.TException = TException;

function TException(message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = this.constructor.name;
  this.message = message;
};
util.inherits(TException, Error);

var TApplicationExceptionType = exports.TApplicationExceptionType = {
  UNKNOWN: 0,
  UNKNOWN_METHOD: 1,
  INVALID_MESSAGE_TYPE: 2,
  WRONG_METHOD_NAME: 3,
  BAD_SEQUENCE_ID: 4,
  MISSING_RESULT: 5,
  INTERNAL_ERROR: 6,
  PROTOCOL_ERROR: 7,
  INVALID_TRANSFORM: 8,
  INVALID_PROTOCOL: 9,
  UNSUPPORTED_CLIENT_TYPE: 10
};

exports.TApplicationException = TApplicationException;

function TApplicationException(type, message) {
  TException.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.type = type || TApplicationExceptionType.UNKNOWN;
  this.name = this.constructor.name;
  this.message = message;
};
util.inherits(TApplicationException, TException);

TApplicationException.prototype.read = function(input) {
  var ftype;
  var ret = input.readStructBegin('TApplicationException');

  while(1){
      ret = input.readFieldBegin();
      if(ret.ftype == Type.STOP)
          break;

      switch(ret.fid){
          case 1:
              if( ret.ftype == Type.STRING ){
                  ret = input.readString();
                  this.message = ret;
              } else {
                  ret = input.skip(ret.ftype);
              }
              break;
          case 2:
              if( ret.ftype == Type.I32 ){
                  ret = input.readI32();
                  this.type = ret;
              } else {
                  ret   = input.skip(ret.ftype);
              }
              break;
          default:
              ret = input.skip(ret.ftype);
              break;
      }
      input.readFieldEnd();
  }
  input.readStructEnd();
};

TApplicationException.prototype.write = function(output){
  output.writeStructBegin('TApplicationException');

  if (this.message) {
      output.writeFieldBegin('message', Type.STRING, 1);
      output.writeString(this.message);
      output.writeFieldEnd();
  }

  if (this.code) {
      output.writeFieldBegin('type', Type.I32, 2);
      output.writeI32(this.code);
      output.writeFieldEnd();
  }

  output.writeFieldStop();
  output.writeStructEnd();
};

var TProtocolExceptionType = exports.TProtocolExceptionType = {
  UNKNOWN: 0,
  INVALID_DATA: 1,
  NEGATIVE_SIZE: 2,
  SIZE_LIMIT: 3,
  BAD_VERSION: 4,
  NOT_IMPLEMENTED: 5,
  DEPTH_LIMIT: 6
};


exports.TProtocolException = TProtocolException;

function TProtocolException(type, message) {
  Error.call(this);
  if (Error.captureStackTrace !== undefined) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = this.constructor.name;
  this.type = type;
  this.message = message;
};
util.inherits(TProtocolException, Error);

exports.objectLength = function(obj) {
  return Object.keys(obj).length;
};

exports.inherits = function(constructor, superConstructor) {
  util.inherits(constructor, superConstructor);
};

var copyList, copyMap;

copyList = function(lst, types) {

  if (!lst) {return lst; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var len = lst.length, result = [], i, val;
  for (i = 0; i < len; i++) {
    val = lst[i];
    if (type === null) {
      result.push(val);
    }
    else if (type === copyMap || type === copyList) {
      result.push(type(val, types.slice(1)));
    }
    else {
      result.push(new Type(val));
    }
  }
  return result;
};

copyMap = function(obj, types){

  if (!obj) {return obj; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var result = {}, val;
  for(var prop in obj) {
    if(obj.hasOwnProperty(prop)) {
      val = obj[prop];
      if (type === null) {
        result[prop] = val;
      }
      else if (type === copyMap || type === copyList) {
        result[prop] = type(val, types.slice(1));
      }
      else {
        result[prop] = new Type(val);
      }
    }
  }
  return result;
};

module.exports.copyMap = copyMap;
module.exports.copyList = copyList;


/***/ }),

/***/ 8954:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var http = __webpack_require__(8605);
var https = __webpack_require__(7211);
var url = __webpack_require__(8835);
var path = __webpack_require__(5622);
var fs = __webpack_require__(5747);
var crypto = __webpack_require__(6417);
var log = __webpack_require__(1291);

var MultiplexedProcessor = __webpack_require__(9023).MultiplexedProcessor;

var TBufferedTransport = __webpack_require__(8869);
var TBinaryProtocol = __webpack_require__(4711);
var InputBufferUnderrunError = __webpack_require__(3590);

// WSFrame constructor and prototype
/////////////////////////////////////////////////////////////////////

/** Apache Thrift RPC Web Socket Transport
 *  Frame layout conforming to RFC 6455 circa 12/2011
 *
 * Theoretical frame size limit is 4GB*4GB, however the Node Buffer
 * limit is 1GB as of v0.10. The frame length encoding is also
 * configured for a max of 4GB presently and needs to be adjusted
 * if Node/Browsers become capabile of > 4GB frames.
 *
 *  - FIN is 1 if the message is complete
 *  - RSV1/2/3 are always 0
 *  - Opcode is 1(TEXT) for TJSONProtocol and 2(BIN) for TBinaryProtocol
 *  - Mask Present bit is 1 sending to-server and 0 sending to-client
 *  - Payload Len:
 *        + If < 126: then represented directly
 *        + If >=126: but within range of an unsigned 16 bit integer
 *             then Payload Len is 126 and the two following bytes store
 *             the length
 *        + Else: Payload Len is 127 and the following 8 bytes store the
 *             length as an unsigned 64 bit integer
 *  - Masking key is a 32 bit key only present when sending to the server
 *  - Payload follows the masking key or length
 *
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-------+-+-------------+-------------------------------+
 *    |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 *    |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 *    |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 *    | |1|2|3|       |K|             |                               |
 *    +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 *    |     Extended payload length continued, if payload len == 127  |
 *    + - - - - - - - - - - - - - - - +-------------------------------+
 *    |                               |Masking-key, if MASK set to 1  |
 *    +-------------------------------+-------------------------------+
 *    | Masking-key (continued)       |          Payload Data         |
 *    +-------------------------------- - - - - - - - - - - - - - - - +
 *    :                     Payload Data continued ...                :
 *    + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 *    |                     Payload Data continued ...                |
 *    +---------------------------------------------------------------+
 */
var wsFrame = {
  /** Encodes a WebSocket frame
   *
   * @param {Buffer} data - The raw data to encode
   * @param {Buffer} mask - The mask to apply when sending to server, null for no mask
   * @param {Boolean} binEncoding - True for binary encoding, false for text encoding
   * @returns {Buffer} - The WebSocket frame, ready to send
   */
  encode: function(data, mask, binEncoding) {
      var frame = new Buffer(wsFrame.frameSizeFromData(data, mask));
      //Byte 0 - FIN & OPCODE
      frame[0] = wsFrame.fin.FIN +
          (binEncoding ? wsFrame.frameOpCodes.BIN : wsFrame.frameOpCodes.TEXT);
      //Byte 1 or 1-3 or 1-9 - MASK FLAG & SIZE
      var payloadOffset = 2;
      if (data.length < 0x7E) {
        frame[1] = data.length + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);
      } else if (data.length < 0xFFFF) {
        frame[1] = 0x7E + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);
        frame.writeUInt16BE(data.length, 2, true);
        payloadOffset = 4;
      } else {
        frame[1] = 0x7F + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);
        frame.writeUInt32BE(0, 2, true);
        frame.writeUInt32BE(data.length, 6, true);
        payloadOffset = 10;
      }
      //MASK
      if (mask) {
        mask.copy(frame, payloadOffset, 0, 4);
        payloadOffset += 4;
      }
      //Payload
      data.copy(frame, payloadOffset);
      if (mask) {
        wsFrame.applyMask(frame.slice(payloadOffset), frame.slice(payloadOffset-4,payloadOffset));
      }
      return frame;
  },

  /**
   * @class
   * @name WSDecodeResult
   * @property {Buffer} data - The decoded data for the first ATRPC message
   * @property {Buffer} mask - The frame mask
   * @property {Boolean} binEncoding - True if binary (TBinaryProtocol),
   *                                   False if text (TJSONProtocol)
   * @property {Buffer} nextFrame - Multiple ATRPC messages may be sent in a
   *                                single WebSocket frame, this Buffer contains
   *                                any bytes remaining to be decoded
   * @property {Boolean} FIN - True is the message is complete
   */

   /** Decodes a WebSocket frame
   *
   * @param {Buffer} frame - The raw inbound frame, if this is a continuation
   *                         frame it must have a mask property with the mask.
   * @returns {WSDecodeResult} - The decoded payload
   *
   * @see {@link WSDecodeResult}
   */
  decode: function(frame) {
      var result = {
        data: null,
        mask: null,
        binEncoding: false,
        nextFrame: null,
        FIN: true
      };

      //Byte 0 - FIN & OPCODE
      if (wsFrame.fin.FIN != (frame[0] & wsFrame.fin.FIN)) {
        result.FIN = false;
      }
      result.binEncoding = (wsFrame.frameOpCodes.BIN == (frame[0] & wsFrame.frameOpCodes.BIN));
      //Byte 1 or 1-3 or 1-9 - SIZE
      var lenByte = (frame[1] & 0x0000007F);
      var len = lenByte;
      var dataOffset = 2;
      if (lenByte == 0x7E) {
        len = frame.readUInt16BE(2);
        dataOffset = 4;
      } else if (lenByte == 0x7F) {
        len = frame.readUInt32BE(6);
        dataOffset = 10;
      }
      //MASK
      if (wsFrame.mask.TO_SERVER == (frame[1] & wsFrame.mask.TO_SERVER)) {
        result.mask = new Buffer(4);
        frame.copy(result.mask, 0, dataOffset, dataOffset + 4);
        dataOffset += 4;
      }
      //Payload
      result.data = new Buffer(len);
      frame.copy(result.data, 0, dataOffset, dataOffset+len);
      if (result.mask) {
        wsFrame.applyMask(result.data, result.mask);
      }
      //Next Frame
      if (frame.length > dataOffset+len) {
        result.nextFrame = new Buffer(frame.length - (dataOffset+len));
        frame.copy(result.nextFrame, 0, dataOffset+len, frame.length);
      }
      //Don't forward control frames
      if (frame[0] & wsFrame.frameOpCodes.FINCTRL) {
        result.data = null;
      }

      return result;
  },

  /** Masks/Unmasks data
   *
   * @param {Buffer} data - data to mask/unmask in place
   * @param {Buffer} mask - the mask
   */
  applyMask: function(data, mask){
    //TODO: look into xoring words at a time
    var dataLen = data.length;
    var maskLen = mask.length;
    for (var i = 0; i < dataLen; i++) {
      data[i] = data[i] ^ mask[i%maskLen];
    }
  },

  /** Computes frame size on the wire from data to be sent
   *
   * @param {Buffer} data - data.length is the assumed payload size
   * @param {Boolean} mask - true if a mask will be sent (TO_SERVER)
   */
  frameSizeFromData: function(data, mask) {
    var headerSize = 10;
    if (data.length < 0x7E) {
      headerSize = 2;
    } else if (data.length < 0xFFFF) {
      headerSize = 4;
    }
    return headerSize + data.length + (mask ? 4 : 0);
  },

  frameOpCodes: {
    CONT:     0x00,
    TEXT:     0x01,
    BIN:      0x02,
    CTRL:     0x80
  },

  mask: {
    TO_SERVER: 0x80,
    TO_CLIENT: 0x00
  },

  fin: {
    CONT: 0x00,
    FIN: 0x80
  }
};


// createWebServer constructor and options
/////////////////////////////////////////////////////////////////////

/**
 * @class
 * @name ServerOptions
 * @property {array} cors - Array of CORS origin strings to permit requests from.
 * @property {string} files - Path to serve static files from, if absent or ""
 *                               static file service is disabled.
 * @property {object} headers - An object hash mapping header strings to header value
 *                              strings, these headers are transmitted in response to
 *                              static file GET operations.
 * @property {object} services - An object hash mapping service URI strings
 *                               to ServiceOptions objects
 * @property {object} tls - Node.js TLS options (see: nodejs.org/api/tls.html),
 *                          if not present or null regular http is used,
 *                          at least a key and a cert must be defined to use SSL/TLS
 * @see {@link ServiceOptions}
 */

/**
 * @class
 * @name ServiceOptions
 * @property {object} transport - The layered transport to use (defaults
 *                                to TBufferedTransport).
 * @property {object} protocol - The serialization Protocol to use (defaults to
 *                               TBinaryProtocol).
 * @property {object} processor - The Thrift Service class/processor generated
 *                                by the IDL Compiler for the service (the "cls"
 *                                key can also be used for this attribute).
 * @property {object} handler - The handler methods for the Thrift Service.
 */

/**
 * Create a Thrift server which can serve static files and/or one or
 * more Thrift Services.
 * @param {ServerOptions} options - The server configuration.
 * @returns {object} - The Apache Thrift Web Server.
 */
exports.createWebServer = function(options) {
  var baseDir = options.files;
  var contentTypesByExtension = {
    '.txt': 'text/plain',
    '.html': 'text/html',
    '.css': 'text/css',
    '.xml': 'application/xml',
    '.json': 'application/json',
    '.js': 'application/javascript',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.png': 'image/png',
    '.svg': 'image/svg+xml'
  };

  //Setup all of the services
  var services = options.services;
  for (var uri in services) {
    var svcObj = services[uri];

    //Setup the processor
    if (svcObj.processor instanceof MultiplexedProcessor) {
      //Multiplex processors have pre embedded processor/handler pairs, save as is
      svcObj.processor = svcObj.processor;
    } else {
      //For historical reasons Node.js supports processors passed in directly or via the
      //  IDL Compiler generated class housing the processor. Also, the options property
      //  for a Processor has been called both cls and processor at different times. We
      //  support any of the four possibilities here.
      var processor = (svcObj.processor) ? (svcObj.processor.Processor || svcObj.processor) :
                                           (svcObj.cls.Processor || svcObj.cls);
      //Processors can be supplied as constructed objects with handlers already embedded,
      //  if a handler is provided we construct a new processor, if not we use the processor
      //  object directly
      if (svcObj.handler) {
        svcObj.processor = new processor(svcObj.handler);
      } else {
        svcObj.processor = processor;
      }
    }
    svcObj.transport = svcObj.transport ? svcObj.transport : TBufferedTransport;
    svcObj.protocol = svcObj.protocol ? svcObj.protocol : TBinaryProtocol;
  }

  //Verify CORS requirements
  function VerifyCORSAndSetHeaders(request, response) {
    if (request.headers.origin && options.cors) {
      if (options.cors["*"] || options.cors[request.headers.origin]) {
        //Allow, origin allowed
        response.setHeader("access-control-allow-origin", request.headers.origin);
        response.setHeader("access-control-allow-methods", "GET, POST, OPTIONS");
        response.setHeader("access-control-allow-headers", "content-type, accept");
        response.setHeader("access-control-max-age", "60");
        return true;
      } else {
        //Disallow, origin denied
        return false;
      }
    }
    //Allow, CORS is not in use
    return true;
  }


  //Handle OPTIONS method (CORS)
  ///////////////////////////////////////////////////
  function processOptions(request, response) {
    if (VerifyCORSAndSetHeaders(request, response)) {
      response.writeHead("204", "No Content", {"content-length": 0});
    } else {
      response.writeHead("403", "Origin " + request.headers.origin + " not allowed", {});
    }
    response.end();
  }


  //Handle POST methods (TXHRTransport)
  ///////////////////////////////////////////////////
  function processPost(request, response) {
    //Lookup service
    var uri = url.parse(request.url).pathname;
    var svc = services[uri];
    if (!svc) {
      response.writeHead("403", "No Apache Thrift Service at " + uri, {});
      response.end();
      return;
    }

    //Verify CORS requirements
    if (!VerifyCORSAndSetHeaders(request, response)) {
      response.writeHead("403", "Origin " + request.headers.origin + " not allowed", {});
      response.end();
      return;
    }

    //Process XHR payload
    request.on('data', svc.transport.receiver(function(transportWithData) {
      var input = new svc.protocol(transportWithData);
      var output = new svc.protocol(new svc.transport(undefined, function(buf) {
        try {
          response.writeHead(200);
          response.end(buf);
        } catch (err) {
          response.writeHead(500);
          response.end();
        }
      }));

      try {
        svc.processor.process(input, output);
        transportWithData.commitPosition();
      } catch (err) {
        if (err instanceof InputBufferUnderrunError) {
          transportWithData.rollbackPosition();
        } else {
          response.writeHead(500);
          response.end();
        }
      }
    }));
  }


  //Handle GET methods (Static Page Server)
  ///////////////////////////////////////////////////
  function processGet(request, response) {
    //Undefined or empty base directory means do not serve static files
    if (!baseDir || "" === baseDir) {
      response.writeHead(404);
      response.end();
      return;
    }

    //Verify CORS requirements
    if (!VerifyCORSAndSetHeaders(request, response)) {
      response.writeHead("403", "Origin " + request.headers.origin + " not allowed", {});
      response.end();
      return;
    }

    //Locate the file requested and send it
    var uri = url.parse(request.url).pathname;
    var filename = path.resolve(path.join(baseDir, uri));

    //Ensure the basedir path is not able to be escaped
    if (filename.indexOf(baseDir) != 0) {
      response.writeHead(400, "Invalid request path", {});
      response.end();
      return;
    }

    fs.exists(filename, function(exists) {
      if(!exists) {
        response.writeHead(404);
        response.end();
        return;
      }

      if (fs.statSync(filename).isDirectory()) {
        filename += '/index.html';
      }

      fs.readFile(filename, "binary", function(err, file) {
        if (err) {
          response.writeHead(500);
          response.end(err + "\n");
          return;
        }
        var headers = {};
        var contentType = contentTypesByExtension[path.extname(filename)];
        if (contentType) {
          headers["Content-Type"] = contentType;
        }
        for (var k in options.headers) {
          headers[k] = options.headers[k];
        }
        response.writeHead(200, headers);
        response.write(file, "binary");
        response.end();
      });
    });
  }


  //Handle WebSocket calls (TWebSocketTransport)
  ///////////////////////////////////////////////////
  function processWS(data, socket, svc, binEncoding) {
    svc.transport.receiver(function(transportWithData) {
      var input = new svc.protocol(transportWithData);
      var output = new svc.protocol(new svc.transport(undefined, function(buf) {
        try {
          var frame = wsFrame.encode(buf, null, binEncoding);
          socket.write(frame);
        } catch (err) {
          //TODO: Add better error processing
        }
      }));

      try {
        svc.processor.process(input, output);
        transportWithData.commitPosition();
      }
      catch (err) {
        if (err instanceof InputBufferUnderrunError) {
          transportWithData.rollbackPosition();
        }
        else {
          //TODO: Add better error processing
        }
      }
    })(data);
  }

  //Create the server (HTTP or HTTPS)
  var server = null;
  if (options.tls) {
    server = https.createServer(options.tls);
  } else {
    server = http.createServer();
  }

  //Wire up listeners for upgrade(to WebSocket) & request methods for:
  //   - GET static files,
  //   - POST XHR Thrift services
  //   - OPTIONS CORS requests
  server.on('request', function(request, response) {
    if (request.method === 'POST') {
      processPost(request, response);
    } else if (request.method === 'GET') {
      processGet(request, response);
    } else if (request.method === 'OPTIONS') {
      processOptions(request, response);
    } else {
      response.writeHead(500);
      response.end();
    }
  }).on('upgrade', function(request, socket, head) {
    //Lookup service
    var svc;
    try {
      svc = services[Object.keys(services)[0]];
    } catch(e) {
      socket.write("HTTP/1.1 403 No Apache Thrift Service available\r\n\r\n");
      return;
    }
    //Perform upgrade
    var hash = crypto.createHash("sha1");
    hash.update(request.headers['sec-websocket-key'] + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
    socket.write("HTTP/1.1 101 Switching Protocols\r\n" +
                   "Upgrade: websocket\r\n" +
                   "Connection: Upgrade\r\n" +
                   "Sec-WebSocket-Accept: " + hash.digest("base64") + "\r\n" +
                   "Sec-WebSocket-Origin: " + request.headers.origin + "\r\n" +
                   "Sec-WebSocket-Location: ws://" + request.headers.host + request.url + "\r\n" +
                   "\r\n");
    //Handle WebSocket traffic
    var data = null;
    socket.on('data', function(frame) {
      try {
        while (frame) {
          var result = wsFrame.decode(frame);
          //Prepend any existing decoded data
          if (data) {
            if (result.data) {
              var newData = new Buffer(data.length + result.data.length);
              data.copy(newData);
              result.data.copy(newData, data.length);
              result.data = newData;
            } else {
              result.data = data;
            }
            data = null;
          }
          //If this completes a message process it
          if (result.FIN) {
            processWS(result.data, socket, svc, result.binEncoding);
          } else {
            data = result.data;
          }
          //Prepare next frame for decoding (if any)
          frame = result.nextFrame;
        }
      } catch(e) {
        log.error('TWebSocketTransport Exception: ' + e);
        socket.destroy();
      }
    });
  });

  //Return the server
  return server;
};


/***/ }),

/***/ 5455:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(1669);
var WebSocket = __webpack_require__(7030);
var EventEmitter = __webpack_require__(8614).EventEmitter;
var thrift = __webpack_require__(5406);

var TBufferedTransport = __webpack_require__(8869);
var TJSONProtocol = __webpack_require__(5086);
var InputBufferUnderrunError = __webpack_require__(3590);

var createClient = __webpack_require__(6243);
var jsEnv = __webpack_require__(3818);
exports.WSConnection = WSConnection;

/**
 * @class
 * @name WSConnectOptions
 * @property {string} transport - The Thrift layered transport to use (TBufferedTransport, etc).
 * @property {string} protocol - The Thrift serialization protocol to use (TJSONProtocol, etc.).
 * @property {string} path - The URL path to connect to (e.g. "/", "/mySvc", "/thrift/quoteSvc", etc.).
 * @property {object} headers - A standard Node.js header hash, an object hash containing key/value
 *        pairs where the key is the header name string and the value is the header value string.
 * @property {boolean} secure - True causes the connection to use wss, otherwise ws is used.
 * @property {object} wsOptions - Options passed on to WebSocket.
 * @example
 *     //Use a secured websocket connection
 *     //  uses the buffered transport layer, uses the JSON protocol and directs RPC traffic
 *     //  to wss://thrift.example.com:9090/hello
 *     var thrift = require('thrift');
 *     var options = {
 *        transport: thrift.TBufferedTransport,
 *        protocol: thrift.TJSONProtocol,
 *        path: "/hello",
 *        secure: true
 *     };
 *     var con = thrift.createWSConnection("thrift.example.com", 9090, options);
 *     con.open()
 *     var client = thrift.createWSClient(myService, connection);
 *     client.myServiceFunction();
 *     con.close()
 */

/**
 * Initializes a Thrift WSConnection instance (use createWSConnection() rather than
 *    instantiating directly).
 * @constructor
 * @param {string} host - The host name or IP to connect to.
 * @param {number} port - The TCP port to connect to.
 * @param {WSConnectOptions} options - The configuration options to use.
 * @throws {error} Exceptions other than ttransport.InputBufferUnderrunError are rethrown
 * @event {error} The "error" event is fired when a Node.js error event occurs during
 *     request or response processing, in which case the node error is passed on. An "error"
 *     event may also be fired when the connection can not map a response back to the
 *     appropriate client (an internal error), generating a TApplicationException.
 * @classdesc WSConnection objects provide Thrift end point transport
 *     semantics implemented using Websockets.
 * @see {@link createWSConnection}
 */
function WSConnection(host, port, options) {
  //Initialize the emitter base object
  EventEmitter.call(this);

  //Set configuration
  this.options = options || {};
  this.host = host;
  this.port = port;
  this.secure = this.options.secure || false;
  this.transport = this.options.transport || TBufferedTransport;
  this.protocol = this.options.protocol || TJSONProtocol;
  this.path = this.options.path;
  this.send_pending = [];

  //The sequence map is used to map seqIDs back to the
  //  calling client in multiplexed scenarios
  this.seqId2Service = {};

  //Prepare WebSocket options
  this.wsOptions = {
    host: this.host,
    port: this.port || 80,
    path: this.options.path || '/',
    headers: this.options.headers || {}
  };
  for (var attrname in this.options.wsOptions) {
    this.wsOptions[attrname] = this.options.wsOptions[attrname];
  }
};
util.inherits(WSConnection, EventEmitter);

WSConnection.prototype.__reset = function() {
  this.socket = null; //The web socket
  this.send_pending = []; //Buffers/Callback pairs waiting to be sent
};

WSConnection.prototype.__onOpen = function() {
  this.emit("open");
  if (this.send_pending.length > 0) {
    //If the user made calls before the connection was fully
    //open, send them now
    this.send_pending.forEach(function(data) {
      this.socket.send(data);
    }, this);
    this.send_pending = [];
  }
};

WSConnection.prototype.__onClose = function(evt) {
  this.emit("close");
  this.__reset();
};

WSConnection.prototype.__decodeCallback = function(transport_with_data) {
  var proto = new this.protocol(transport_with_data);
  try {
    while (true) {
      var header = proto.readMessageBegin();
      var dummy_seqid = header.rseqid * -1;
      var client = this.client;
      //The Multiplexed Protocol stores a hash of seqid to service names
      //  in seqId2Service. If the SeqId is found in the hash we need to
      //  lookup the appropriate client for this call.
      //  The client var is a single client object when not multiplexing,
      //  when using multiplexing it is a service name keyed hash of client
      //  objects.
      //NOTE: The 2 way interdependencies between protocols, transports,
      //  connections and clients in the Node.js implementation are irregular
      //  and make the implementation difficult to extend and maintain. We
      //  should bring this stuff inline with typical thrift I/O stack
      //  operation soon.
      //  --ra
      var service_name = this.seqId2Service[header.rseqid];
      if (service_name) {
        client = this.client[service_name];
        delete this.seqId2Service[header.rseqid];
      }
      /*jshint -W083 */
      client._reqs[dummy_seqid] = function(err, success) {
        transport_with_data.commitPosition();
        var clientCallback = client._reqs[header.rseqid];
        delete client._reqs[header.rseqid];
        if (clientCallback) {
          clientCallback(err, success);
        }
      };
      /*jshint +W083 */
      if (client['recv_' + header.fname]) {
        client['recv_' + header.fname](proto, header.mtype, dummy_seqid);
      } else {
        delete client._reqs[dummy_seqid];
        this.emit("error",
          new thrift.TApplicationException(
            thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
            "Received a response to an unknown RPC function"));
      }
    }
  } catch (e) {
    if (e instanceof InputBufferUnderrunError) {
      transport_with_data.rollbackPosition();
    } else {
      throw e;
    }
  }
};

WSConnection.prototype.__onData = function(data) {
  if (Object.prototype.toString.call(data) === "[object ArrayBuffer]") {
    data = new Uint8Array(data);
  }
  var buf = new Buffer(data);
  this.transport.receiver(this.__decodeCallback.bind(this))(buf);

};

WSConnection.prototype.__onMessage = function(evt) {
  this.__onData(evt.data);
};

WSConnection.prototype.__onError = function(evt) {
  this.emit("error", evt);
  this.socket.close();
};

/**
 * Returns true if the transport is open
 * @readonly
 * @returns {boolean}
 */
WSConnection.prototype.isOpen = function() {
  return this.socket && this.socket.readyState === this.socket.OPEN;
};

/**
 * Opens the transport connection
 */
WSConnection.prototype.open = function() {
  //If OPEN/CONNECTING/CLOSING ignore additional opens
  if (this.socket && this.socket.readyState !== this.socket.CLOSED) {
    return;
  }
  //If there is no socket or the socket is closed:
  if (jsEnv.isBrowser) {
    this.socket = new WebSocket(this.uri());
  } else {
    this.socket = new WebSocket(this.uri(), "", this.wsOptions);
  }
  this.socket.binaryType = 'arraybuffer';
  this.socket.onopen = this.__onOpen.bind(this);
  this.socket.onmessage = this.__onMessage.bind(this);
  this.socket.onerror = this.__onError.bind(this);
  this.socket.onclose = this.__onClose.bind(this);
};

/**
 * Closes the transport connection
 */
WSConnection.prototype.close = function() {
  this.socket.close();
};

/**
 * Return URI for the connection
 * @returns {string} URI
 */
WSConnection.prototype.uri = function() {
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';
  var path = this.path || '/';
  var host = this.host;

  // avoid port if default for schema
  if (this.port && (('wss' === schema && this.port !== 443) ||
    ('ws' === schema && this.port !== 80))) {
    port = ':' + this.port;
  }

  return schema + '://' + host + port + path;
};

/**
 * Writes Thrift message data to the connection
 * @param {Buffer} data - A Node.js Buffer containing the data to write
 * @returns {void} No return value.
 * @event {error} the "error" event is raised upon request failure passing the
 *     Node.js error object to the listener.
 */
WSConnection.prototype.write = function(data) {
  if (this.isOpen()) {
    //Send data and register a callback to invoke the client callback
    this.socket.send(data);
  } else {
    //Queue the send to go out __onOpen
    this.send_pending.push(data);
  }
};

/**
 * Creates a new WSConnection object, used by Thrift clients to connect
 *    to Thrift HTTP based servers.
 * @param {string} host - The host name or IP to connect to.
 * @param {number} port - The TCP port to connect to.
 * @param {WSConnectOptions} options - The configuration options to use.
 * @returns {WSConnection} The connection object.
 * @see {@link WSConnectOptions}
 */
exports.createWSConnection = function(host, port, options) {
  return new WSConnection(host, port, options);
};

exports.createWSClient = createClient;


/***/ }),

/***/ 4050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var util = __webpack_require__(1669);
var EventEmitter = __webpack_require__(8614).EventEmitter;
var thrift = __webpack_require__(5406);

var TBufferedTransport = __webpack_require__(8869);
var TJSONProtocol = __webpack_require__(5086);
var InputBufferUnderrunError = __webpack_require__(3590);

var createClient = __webpack_require__(6243);

exports.XHRConnection = XHRConnection;

/**
 * Constructor Function for the XHR Connection.
 * If you do not specify a host and port then XHRConnection will default to the
 * host and port of the page from which this javascript is served.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc TXHRConnection objects provide Thrift end point transport
 *     semantics implemented using XHR.
 * @example
 *     var transport = new Thrift.TXHRConnection('localhost', 9099, {});
 */
function XHRConnection(host, port, options) {
  this.options = options || {};
  this.wpos = 0;
  this.rpos = 0;
  this.useCORS = (options && options.useCORS);
  this.send_buf = '';
  this.recv_buf = '';
  this.transport = options.transport || TBufferedTransport;
  this.protocol = options.protocol || TJSONProtocol;
  this.headers = options.headers || {};

  host = host || window.location.host;
  port = port || window.location.port;
  var prefix = options.https ? 'https://' : 'http://';
  var path = options.path || '/';

  if (port === '') {
    port = undefined;
  }

  if (!port || port === 80 || port === '80') {
    this.url = prefix + host + path;
  } else {
    this.url = prefix + host + ':' + port + path;
  }

  //The sequence map is used to map seqIDs back to the
  //  calling client in multiplexed scenarios
  this.seqId2Service = {};
};

util.inherits(XHRConnection, EventEmitter);

/**
* Gets the browser specific XmlHttpRequest Object.
* @returns {object} the browser XHR interface object
*/
XHRConnection.prototype.getXmlHttpRequestObject = function() {
  try { return new XMLHttpRequest(); } catch (e1) { }
  try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }
  try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }

  throw "Your browser doesn't support XHR.";
};

/**
 * Sends the current XRH request if the transport was created with a URL
 * and the async parameter is false. If the transport was not created with
 * a URL, or the async parameter is True and no callback is provided, or
 * the URL is an empty string, the current send buffer is returned.
 * @param {object} async - If true the current send buffer is returned.
 * @param {object} callback - Optional async completion callback
 * @returns {undefined|string} Nothing or the current send buffer.
 * @throws {string} If XHR fails.
 */
XHRConnection.prototype.flush = function() {
  var self = this;
  if (this.url === undefined || this.url === '') {
    return this.send_buf;
  }

  var xreq = this.getXmlHttpRequestObject();

  if (xreq.overrideMimeType) {
    xreq.overrideMimeType('application/json');
  }

  xreq.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      self.setRecvBuffer(this.responseText);
    }
  };

  xreq.open('POST', this.url, true);

  Object.keys(this.headers).forEach(function(headerKey) {
    xreq.setRequestHeader(headerKey, self.headers[headerKey]);
  });

  xreq.send(this.send_buf);
};

/**
 * Sets the buffer to provide the protocol when deserializing.
 * @param {string} buf - The buffer to supply the protocol.
 */
XHRConnection.prototype.setRecvBuffer = function(buf) {
  this.recv_buf = buf;
  this.recv_buf_sz = this.recv_buf.length;
  this.wpos = this.recv_buf.length;
  this.rpos = 0;

  if (Object.prototype.toString.call(buf) == "[object ArrayBuffer]") {
    var data = new Uint8Array(buf);
  }
  var thing = new Buffer(data || buf);

  this.transport.receiver(this.__decodeCallback.bind(this))(thing);

};

XHRConnection.prototype.__decodeCallback = function(transport_with_data) {
  var proto = new this.protocol(transport_with_data);
  try {
    while (true) {
      var header = proto.readMessageBegin();
      var dummy_seqid = header.rseqid * -1;
      var client = this.client;
      //The Multiplexed Protocol stores a hash of seqid to service names
      //  in seqId2Service. If the SeqId is found in the hash we need to
      //  lookup the appropriate client for this call.
      //  The client var is a single client object when not multiplexing,
      //  when using multiplexing it is a service name keyed hash of client
      //  objects.
      //NOTE: The 2 way interdependencies between protocols, transports,
      //  connections and clients in the Node.js implementation are irregular
      //  and make the implementation difficult to extend and maintain. We
      //  should bring this stuff inline with typical thrift I/O stack
      //  operation soon.
      //  --ra
      var service_name = this.seqId2Service[header.rseqid];
      if (service_name) {
        client = this.client[service_name];
        delete this.seqId2Service[header.rseqid];
      }
      /*jshint -W083 */
      client._reqs[dummy_seqid] = function(err, success) {
        transport_with_data.commitPosition();
        var clientCallback = client._reqs[header.rseqid];
        delete client._reqs[header.rseqid];
        if (clientCallback) {
          clientCallback(err, success);
        }
      };
      /*jshint +W083 */
      if (client['recv_' + header.fname]) {
        client['recv_' + header.fname](proto, header.mtype, dummy_seqid);
      } else {
        delete client._reqs[dummy_seqid];
        this.emit("error",
          new thrift.TApplicationException(
            thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
            "Received a response to an unknown RPC function"));
      }
    }
  } catch (e) {
    if (e instanceof InputBufferUnderrunError) {
      transport_with_data.rollbackPosition();
    } else {
      throw e;
    }
  }
};

/**
 * Returns true if the transport is open, XHR always returns true.
 * @readonly
 * @returns {boolean} Always True.
 */
XHRConnection.prototype.isOpen = function() {
  return true;
};

/**
 * Opens the transport connection, with XHR this is a nop.
 */
XHRConnection.prototype.open = function() {};

/**
 * Closes the transport connection, with XHR this is a nop.
 */
XHRConnection.prototype.close = function() {};

/**
 * Returns the specified number of characters from the response
 * buffer.
 * @param {number} len - The number of characters to return.
 * @returns {string} Characters sent by the server.
 */
XHRConnection.prototype.read = function(len) {
  var avail = this.wpos - this.rpos;

  if (avail === 0) {
    return '';
  }

  var give = len;

  if (avail < len) {
    give = avail;
  }

  var ret = this.read_buf.substr(this.rpos, give);
  this.rpos += give;

  //clear buf when complete?
  return ret;
};

/**
 * Returns the entire response buffer.
 * @returns {string} Characters sent by the server.
 */
XHRConnection.prototype.readAll = function() {
  return this.recv_buf;
};

/**
 * Sets the send buffer to buf.
 * @param {string} buf - The buffer to send.
 */
XHRConnection.prototype.write = function(buf) {
  this.send_buf = buf;
  this.flush();
};

/**
 * Returns the send buffer.
 * @readonly
 * @returns {string} The send buffer.
 */
XHRConnection.prototype.getSendBuffer = function() {
  return this.send_buf;
};

/**
 * Creates a new TXHRTransport object, used by Thrift clients to connect
 *    to Thrift HTTP based servers.
 * @param {string} host - The host name or IP to connect to.
 * @param {number} port - The TCP port to connect to.
 * @param {XHRConnectOptions} options - The configuration options to use.
 * @returns {XHRConnection} The connection object.
 * @see {@link XHRConnectOptions}
 */
exports.createXHRConnection = function(host, port, options) {
  return new XHRConnection(host, port, options);
};

exports.createXHRClient = createClient;


/***/ }),

/***/ 8777:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WebSocket = __webpack_require__(8762);

WebSocket.Server = __webpack_require__(9284);
WebSocket.Receiver = __webpack_require__(2957);
WebSocket.Sender = __webpack_require__(7330);

module.exports = WebSocket;


/***/ }),

/***/ 977:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat (list, totalLength) {
  const target = Buffer.allocUnsafe(totalLength);
  var offset = 0;

  for (var i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(target, offset);
    offset += buf.length;
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask (source, mask, output, offset, length) {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask (buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

try {
  const bufferUtil = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'bufferutil'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    mask (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    unmask (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    },
    concat
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = { concat, mask: _mask, unmask: _unmask };
}


/***/ }),

/***/ 1872:
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ 62:
/***/ ((module) => {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was dispatched
   */
  constructor (type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor (data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being closed
   * @param {String} reason A human-readable string explaining why the connection is closing
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor (code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor (target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor (error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} method A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @public
   */
  addEventListener (method, listener) {
    if (typeof listener !== 'function') return;

    function onMessage (data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose (code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError (error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen () {
      listener.call(this, new OpenEvent(this));
    }

    if (method === 'message') {
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} method A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener (method, listener) {
    const listeners = this.listeners(method);

    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(method, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ 1503:
/***/ ((module) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push (dest, name, elem) {
  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);
  else dest[name] = [elem];
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse (header) {
  const offers = {};

  if (header === undefined || header === '') return offers;

  var params = {};
  var mustUnescape = false;
  var isEscaping = false;
  var inQuotes = false;
  var extensionName;
  var paramName;
  var start = -1;
  var end = -1;

  for (var i = 0; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20/* ' ' */|| code === 0x09/* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b/* ';' */ || code === 0x2c/* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = {};
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = {};
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d/* '=' */&& start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22/* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c/* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        var value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = {};
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, {});
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format (extensions) {
  return Object.keys(extensions).map((extension) => {
    var configurations = extensions[extension];
    if (!Array.isArray(configurations)) configurations = [configurations];
    return configurations.map((params) => {
      return [extension].concat(Object.keys(params).map((k) => {
        var values = params[k];
        if (!Array.isArray(values)) values = [values];
        return values.map((v) => v === true ? k : `${k}=${v}`).join('; ');
      })).join('; ');
    }).join(', ');
  }).join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 5196:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Limiter = __webpack_require__(3009);
const zlib = __webpack_require__(8761);

const bufferUtil = __webpack_require__(977);
const constants = __webpack_require__(1872);

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const EMPTY_BLOCK = Buffer.from([0x00]);

const kPerMessageDeflate = Symbol('permessage-deflate');
const kWriteInProgress = Symbol('write-in-progress');
const kPendingClose = Symbol('pending-close');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling
   *     of server context takeover
   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge
   *     disabling of client context takeover
   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support
   *     for, or request, a custom client window size
   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate
   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate
   * @param {Number} options.threshold Size (in bytes) below which messages
   *     should not be compressed
   * @param {Number} options.concurrencyLimit The number of concurrent calls to
   *     zlib
   * @param {Boolean} isServer Create the instance in either server or client
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor (options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold = this._options.threshold !== undefined
      ? this._options.threshold
      : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency = this._options.concurrencyLimit !== undefined
        ? this._options.concurrencyLimit
        : 10;
      zlibLimiter = new Limiter({ concurrency });
    }
  }

  /**
   * @type {String}
   */
  static get extensionName () {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer () {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept (configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup () {
    if (this._inflate) {
      if (this._inflate[kWriteInProgress]) {
        this._inflate[kPendingClose] = true;
      } else {
        this._inflate.close();
        this._inflate = null;
      }
    }
    if (this._deflate) {
      if (this._deflate[kWriteInProgress]) {
        this._deflate[kPendingClose] = true;
      } else {
        this._deflate.close();
        this._deflate = null;
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer (offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient (response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams (configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        var value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited by async-limiter.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress (data, fin, callback) {
    zlibLimiter.push((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited by async-limiter.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress (data, fin, callback) {
    zlibLimiter.push((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress (data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== 'number'
        ? zlib.Z_DEFAULT_WINDOWBITS
        : this.params[key];

      this._inflate = zlib.createInflateRaw(
        Object.assign({}, this._options.zlibInflateOptions, { windowBits })
      );
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;
    this._inflate[kWriteInProgress] = true;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (
        (fin && this.params[`${endpoint}_no_context_takeover`]) ||
        this._inflate[kPendingClose]
      ) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kWriteInProgress] = false;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress (data, fin, callback) {
    if (!data || data.length === 0) {
      process.nextTick(callback, null, EMPTY_BLOCK);
      return;
    }

    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== 'number'
        ? zlib.Z_DEFAULT_WINDOWBITS
        : this.params[key];

      this._deflate = zlib.createDeflateRaw(
        Object.assign(
          // TODO deprecate memLevel/level and recommend zlibDeflateOptions instead
          {
            memLevel: this._options.memLevel,
            level: this._options.level
          },
          this._options.zlibDeflateOptions,
          { windowBits }
        )
      );

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use
      // it is made after it has already been closed. This cannot happen here,
      // so we only add a listener for the `'data'` event.
      //
      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kWriteInProgress] = true;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      var data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      if (
        (fin && this.params[`${endpoint}_no_context_takeover`]) ||
        this._deflate[kPendingClose]
      ) {
        this._deflate.close();
        this._deflate = null;
      } else {
        this._deflate[kWriteInProgress] = false;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData (chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData (chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][constants.kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError (err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[constants.kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 2957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(2413);

const PerMessageDeflate = __webpack_require__(5196);
const bufferUtil = __webpack_require__(977);
const validation = __webpack_require__(6746);
const constants = __webpack_require__(1872);

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends stream.Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} binaryType The type for binary data
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor (binaryType, extensions, maxPayload) {
    super();

    this._binaryType = binaryType || constants.BINARY_TYPES[0];
    this[constants.kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   */
  _write (chunk, encoding, cb) {
    if (this._opcode === 0x08) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume (n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];

      if (n >= buf.length) {
        this._buffers.shift().copy(dst, dst.length - n);
      } else {
        buf.copy(dst, dst.length - n, 0, n);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop (cb) {
    var err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default: // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo () {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16 () {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64 () {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength () {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask () {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData (cb) {
    var data = constants.EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) bufferUtil.unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress (data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(error(RangeError, 'Max payload size exceeded', false, 1009));
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage () {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        var data;

        if (this._binaryType === 'nodebuffer') {
          data = toBuffer(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(toBuffer(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = toBuffer(fragments, messageLength);

        if (!validation.isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage (data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!validation.isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!validation.isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }

      return;
    }

    if (this._opcode === 0x09) this.emit('ping', data);
    else this.emit('pong', data);

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error (ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[constants.kStatusCode] = statusCode;
  return err;
}

/**
 * Makes a buffer from a list of fragments.
 *
 * @param {Buffer[]} fragments The list of fragments composing the message
 * @param {Number} messageLength The length of the message
 * @return {Buffer}
 * @private
 */
function toBuffer (fragments, messageLength) {
  if (fragments.length === 1) return fragments[0];
  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);
  return constants.EMPTY_BUFFER;
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 */
function toArrayBuffer (buf) {
  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}


/***/ }),

/***/ 7330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const crypto = __webpack_require__(6417);

const PerMessageDeflate = __webpack_require__(5196);
const bufferUtil = __webpack_require__(977);
const validation = __webpack_require__(6746);
const constants = __webpack_require__(1872);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
  constructor (socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame (data, options) {
    const merge = data.length < 1024 || (options.mask && options.readOnly);
    var offset = options.mask ? 6 : 2;
    var payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) {
      target[1] = payloadLength;
      if (merge) {
        data.copy(target, offset);
        return [target];
      }

      return [target, data];
    }

    const mask = crypto.randomBytes(4);

    target[1] = payloadLength | 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      bufferUtil.mask(data, mask, target, offset, data.length);
      return [target];
    }

    bufferUtil.mask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close (code, data, mask, cb) {
    var buf;

    if (code === undefined) {
      buf = constants.EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !validation.isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose (data, mask, cb) {
    this.sendFrame(Sender.frame(data, {
      fin: true,
      rsv1: false,
      opcode: 0x08,
      mask,
      readOnly: false
    }), cb);
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  ping (data, mask, cb) {
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    if (this._deflating) {
      this.enqueue([this.doPing, data, mask, readOnly, cb]);
    } else {
      this.doPing(data, mask, readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPing (data, mask, readOnly, cb) {
    this.sendFrame(Sender.frame(data, {
      fin: true,
      rsv1: false,
      opcode: 0x09,
      mask,
      readOnly
    }), cb);
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  pong (data, mask, cb) {
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    if (this._deflating) {
      this.enqueue([this.doPong, data, mask, readOnly, cb]);
    } else {
      this.doPong(data, mask, readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPong (data, mask, readOnly, cb) {
    this.sendFrame(Sender.frame(data, {
      fin: true,
      rsv1: false,
      opcode: 0x0a,
      mask,
      readOnly
    }), cb);
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  send (data, options, cb) {
    var opcode = options.binary ? 2 : 1;
    var rsv1 = options.compress;
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        data = viewToBuffer(data);
      } else {
        data = Buffer.from(data);
        readOnly = false;
      }
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = data.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(Sender.frame(data, {
        fin: options.fin,
        rsv1: false,
        opcode,
        mask: options.mask,
        readOnly
      }), cb);
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} compress Specifies whether or not to compress `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @param {Function} cb Callback
   * @private
   */
  dispatch (data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this._deflating = false;
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue () {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      params[0].apply(this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue (params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} cb Callback
   * @private
   */
  sendFrame (list, cb) {
    if (list.length === 2) {
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Converts an `ArrayBuffer` view into a buffer.
 *
 * @param {(DataView|TypedArray)} view The view to convert
 * @return {Buffer} Converted view
 * @private
 */
function viewToBuffer (view) {
  const buf = Buffer.from(view.buffer);

  if (view.byteLength !== view.buffer.byteLength) {
    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
  }

  return buf;
}


/***/ }),

/***/ 6746:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


try {
  const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

  exports.isValidUTF8 = typeof isValidUTF8 === 'object'
    ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
    : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1013 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),

/***/ 9284:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(8614);
const crypto = __webpack_require__(6417);
const http = __webpack_require__(8605);
const url = __webpack_require__(8835);

const PerMessageDeflate = __webpack_require__(5196);
const extension = __webpack_require__(1503);
const constants = __webpack_require__(1872);
const WebSocket = __webpack_require__(8762);

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient An hook to reject connections
   * @param {Function} options.handleProtocols An hook to handle protocols
   * @param {String} options.path Accept only connections matching this path
   * @param {Boolean} options.noServer Enable no server mode
   * @param {Boolean} options.clientTracking Specifies whether or not to track clients
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Function} callback A listener for the `listening` event
   */
  constructor (options, callback) {
    super();

    options = Object.assign({
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null
    }, options);

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(options.port, options.host, options.backlog, callback);
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, (ws) => {
            this.emit('connection', ws, req);
          });
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address () {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close (cb) {
    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) return server.close(cb);
    }

    if (cb) cb();
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle (req) {
    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {
      return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade (req, socket, head, cb) {
    socket.on('error', socketOnError);

    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !req.headers['sec-websocket-key'] || (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(
          req.headers['sec-websocket-extensions']
        );

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.connection.authorized || req.connection.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @private
   */
  completeUpgrade (extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    const key = crypto.createHash('sha1')
      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${key}`
    ];

    const ws = new WebSocket(null);
    var protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.split(',').map(trim);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws.protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when called
 * @private
 */
function addListeners (server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners () {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError () {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake (socket, code, message, headers) {
  if (socket.writable) {
    message = message || http.STATUS_CODES[code];
    headers = Object.assign({
      'Connection': 'close',
      'Content-type': 'text/html',
      'Content-Length': Buffer.byteLength(message)
    }, headers);

    socket.write(
      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\r\n') +
      '\r\n\r\n' +
      message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}

/**
 * Remove whitespace characters from both ends of a string.
 *
 * @param {String} str The string
 * @return {String} A new string representing `str` stripped of whitespace
 *     characters from both its beginning and end
 * @private
 */
function trim(str) {
  return str.trim();
}


/***/ }),

/***/ 8762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(8614);
const crypto = __webpack_require__(6417);
const https = __webpack_require__(7211);
const http = __webpack_require__(8605);
const net = __webpack_require__(1631);
const tls = __webpack_require__(4016);
const url = __webpack_require__(8835);

const PerMessageDeflate = __webpack_require__(5196);
const EventTarget = __webpack_require__(62);
const extension = __webpack_require__(1503);
const constants = __webpack_require__(1872);
const Receiver = __webpack_require__(2957);
const Sender = __webpack_require__(7330);

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const kWebSocket = constants.kWebSocket;
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.Url|url.URL)} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
  constructor (address, protocols, options) {
    super();

    this.readyState = WebSocket.CONNECTING;
    this.protocol = '';

    this._binaryType = constants.BINARY_TYPES[0];
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._closeCode = 1006;
    this._extensions = {};
    this._isServer = true;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient.call(this, address, protocols, options);
    }
  }

  get CONNECTING () { return WebSocket.CONNECTING; }
  get CLOSING () { return WebSocket.CLOSING; }
  get CLOSED () { return WebSocket.CLOSED; }
  get OPEN () { return WebSocket.OPEN; }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the required
   * default "blob" type (instead we define a custom "nodebuffer" type).
   *
   * @type {String}
   */
  get binaryType () {
    return this._binaryType;
  }

  set binaryType (type) {
    if (constants.BINARY_TYPES.indexOf(type) < 0) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount () {
    if (!this._socket) return 0;

    //
    // `socket.bufferSize` is `undefined` if the socket is closed.
    //
    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions () {
    return Object.keys(this._extensions).join();
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} maxPayload The maximum allowed message size
   * @private
   */
  setSocket (socket, head, maxPayload) {
    const receiver = new Receiver(
      this._binaryType,
      this._extensions,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose () {
    this.readyState = WebSocket.CLOSED;

    if (!this._socket) {
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} code Status code explaining why the connection is closing
   * @param {String} data A string explaining why the connection is closing
   * @public
   */
  close (code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this.readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (this._socket.writable) {
        if (this._closeFrameReceived) this._socket.end();

        //
        // Ensure that the connection is closed even if the closing handshake
        // fails.
        //
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
    });
  }

  /**
   * Send a ping.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the ping is sent
   * @public
   */
  ping (data, mask, cb) {
    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();
    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the pong is sent
   * @public
   */
  pong (data, mask, cb) {
    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();
    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback which is executed when data is written out
   * @public
   */
  send (data, options, cb) {
    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (this.readyState !== WebSocket.OPEN) {
      const err = new Error(
        `WebSocket is not open: readyState ${this.readyState} ` +
          `(${readyStates[this.readyState]})`
      );

      if (cb) return cb(err);
      throw err;
    }

    if (typeof data === 'number') data = data.toString();

    const opts = Object.assign({
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true
    }, options);

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate () {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this.readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  WebSocket[readyStates[i]] = i;
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get () {
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set (listener) {
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = EventTarget.addEventListener;
WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {(String|url.Url|url.URL)} address The URL to which to connect
 * @param {String} protocols The subprotocols
 * @param {Object} options Connection options
 * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
 * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request
 * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header
 * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header
 * @private
 */
function initAsClient (address, protocols, options) {
  options = Object.assign({
    protocolVersion: protocolVersions[1],
    perMessageDeflate: true
  }, options, {
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    auth: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  });

  if (protocolVersions.indexOf(options.protocolVersion) === -1) {
    throw new RangeError(
      `Unsupported protocol version: ${options.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  this._isServer = false;

  var parsedUrl;

  if (typeof address === 'object' && address.href !== undefined) {
    parsedUrl = address;
    this.url = address.href;
  } else {
    parsedUrl = url.parse(address);
    this.url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${this.url}`);
  }

  const isSecure = parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const key = crypto.randomBytes(16).toString('base64');
  const httpObj = isSecure ? https : http;
  const path = parsedUrl.search
    ? `${parsedUrl.pathname || '/'}${parsedUrl.search}`
    : parsedUrl.pathname || '/';
  var perMessageDeflate;

  options.createConnection = isSecure ? tlsConnect : netConnect;
  options.port = parsedUrl.port || (isSecure ? 443 : 80);
  options.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  options.headers = Object.assign({
    'Sec-WebSocket-Version': options.protocolVersion,
    'Sec-WebSocket-Key': key,
    'Connection': 'Upgrade',
    'Upgrade': 'websocket'
  }, options.headers);
  options.path = path;

  if (options.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      options.perMessageDeflate !== true ? options.perMessageDeflate : {},
      false
    );
    options.headers['Sec-WebSocket-Extensions'] = extension.format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    options.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (options.origin) {
    if (options.protocolVersion < 13) {
      options.headers['Sec-WebSocket-Origin'] = options.origin;
    } else {
      options.headers.Origin = options.origin;
    }
  }
  if (parsedUrl.auth) {
    options.auth = parsedUrl.auth;
  } else if (parsedUrl.username || parsedUrl.password) {
    options.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = path.split(':');

    if (options.agent == null && process.versions.modules < 57) {
      //
      // Setting `socketPath` in conjunction with `createConnection` without an
      // agent throws an error on Node.js < 8. Work around the issue by using a
      // different property.
      //
      options._socketPath = parts[0];
    } else {
      options.socketPath = parts[0];
    }

    options.path = parts[1];
  }

  var req = this._req = httpObj.get(options);

  if (options.handshakeTimeout) {
    req.setTimeout(
      options.handshakeTimeout,
      () => abortHandshake(this, req, 'Opening handshake has timed out')
    );
  }

  req.on('error', (err) => {
    if (this._req.aborted) return;

    req = this._req = null;
    this.readyState = WebSocket.CLOSING;
    this.emit('error', err);
    this.emitClose();
  });

  req.on('response', (res) => {
    if (this.emit('unexpected-response', req, res)) return;

    abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);
  });

  req.on('upgrade', (res, socket, head) => {
    this.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (this.readyState !== WebSocket.CONNECTING) return;

    req = this._req = null;

    const digest = crypto.createHash('sha1')
      .update(key + constants.GUID, 'binary')
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(this, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    var protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && protList.indexOf(serverProt) === -1) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(this, socket, protError);
      return;
    }

    if (serverProt) this.protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = extension.parse(
          res.headers['sec-websocket-extensions']
        );

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(
            extensions[PerMessageDeflate.extensionName]
          );
          this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(this, socket, 'Invalid Sec-WebSocket-Extensions header');
        return;
      }
    }

    this.setSocket(socket, head, 0);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect (options) {
  options.path = options.socketPath || options._socketPath || undefined;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect (options) {
  options.path = options.socketPath || options._socketPath || undefined;
  options.servername = options.servername || options.host;
  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake (websocket, stream, message) {
  websocket.readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude (code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain () {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError (err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket.readyState = WebSocket.CLOSING;
  websocket._closeCode = err[constants.kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish () {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage (data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing (data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, constants.NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong (data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose () {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket.readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData (chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd () {
  const websocket = this[kWebSocket];

  websocket.readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError () {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', constants.NOOP);

  if (websocket) {
    websocket.readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 4221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(7392);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);

const common_ttypes = __webpack_require__(2818);
const completion_hints_ttypes = __webpack_require__(4494);
const serialized_result_set_ttypes = __webpack_require__(3962);
const extension_functions_ttypes = __webpack_require__(1396);


const ttypes = __webpack_require__(2607);
//HELPER FUNCTIONS AND STRUCTURES

const Heavy_connect_args = class {
  constructor(args) {
    this.user = null;
    this.passwd = null;
    this.dbname = null;
    if (args) {
      if (args.user !== undefined && args.user !== null) {
        this.user = args.user;
      }
      if (args.passwd !== undefined && args.passwd !== null) {
        this.passwd = args.passwd;
      }
      if (args.dbname !== undefined && args.dbname !== null) {
        this.dbname = args.dbname;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.user = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.passwd = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.dbname = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_connect_args');
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRING, 1);
      output.writeString(this.user);
      output.writeFieldEnd();
    }
    if (this.passwd !== null && this.passwd !== undefined) {
      output.writeFieldBegin('passwd', Thrift.Type.STRING, 2);
      output.writeString(this.passwd);
      output.writeFieldEnd();
    }
    if (this.dbname !== null && this.dbname !== undefined) {
      output.writeFieldBegin('dbname', Thrift.Type.STRING, 3);
      output.writeString(this.dbname);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_connect_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_connect_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_krb5_connect_args = class {
  constructor(args) {
    this.inputToken = null;
    this.dbname = null;
    if (args) {
      if (args.inputToken !== undefined && args.inputToken !== null) {
        this.inputToken = args.inputToken;
      }
      if (args.dbname !== undefined && args.dbname !== null) {
        this.dbname = args.dbname;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.inputToken = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dbname = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_krb5_connect_args');
    if (this.inputToken !== null && this.inputToken !== undefined) {
      output.writeFieldBegin('inputToken', Thrift.Type.STRING, 1);
      output.writeString(this.inputToken);
      output.writeFieldEnd();
    }
    if (this.dbname !== null && this.dbname !== undefined) {
      output.writeFieldBegin('dbname', Thrift.Type.STRING, 2);
      output.writeString(this.dbname);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_krb5_connect_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TKrb5Session(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TKrb5Session();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_krb5_connect_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_disconnect_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_disconnect_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_disconnect_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_disconnect_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_switch_database_args = class {
  constructor(args) {
    this.session = null;
    this.dbname = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dbname !== undefined && args.dbname !== null) {
        this.dbname = args.dbname;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dbname = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_switch_database_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dbname !== null && this.dbname !== undefined) {
      output.writeFieldBegin('dbname', Thrift.Type.STRING, 2);
      output.writeString(this.dbname);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_switch_database_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_switch_database_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clone_session_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clone_session_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clone_session_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clone_session_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_server_status_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_server_status_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_server_status_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TServerStatus(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TServerStatus();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_server_status_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_status_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_status_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_status_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TServerStatus]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3206 = input.readListBegin();
          const _size205 = _rtmp3206.size || 0;
          for (let _i207 = 0; _i207 < _size205; ++_i207) {
            let elem208 = null;
            elem208 = new ttypes.TServerStatus();
            elem208.read(input);
            this.success.push(elem208);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_status_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter209 in this.success) {
        if (this.success.hasOwnProperty(iter209)) {
          iter209 = this.success[iter209];
          iter209.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_hardware_info_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_hardware_info_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_hardware_info_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TClusterHardwareInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TClusterHardwareInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_hardware_info_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3211 = input.readListBegin();
          const _size210 = _rtmp3211.size || 0;
          for (let _i212 = 0; _i212 < _size210; ++_i212) {
            let elem213 = null;
            elem213 = input.readString();
            this.success.push(elem213);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter214 in this.success) {
        if (this.success.hasOwnProperty(iter214)) {
          iter214 = this.success[iter214];
          output.writeString(iter214);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_for_database_args = class {
  constructor(args) {
    this.session = null;
    this.database_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.database_name !== undefined && args.database_name !== null) {
        this.database_name = args.database_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.database_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_for_database_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.database_name !== null && this.database_name !== undefined) {
      output.writeFieldBegin('database_name', Thrift.Type.STRING, 2);
      output.writeString(this.database_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_for_database_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3216 = input.readListBegin();
          const _size215 = _rtmp3216.size || 0;
          for (let _i217 = 0; _i217 < _size215; ++_i217) {
            let elem218 = null;
            elem218 = input.readString();
            this.success.push(elem218);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_for_database_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter219 in this.success) {
        if (this.success.hasOwnProperty(iter219)) {
          iter219 = this.success[iter219];
          output.writeString(iter219);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_physical_tables_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_physical_tables_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_physical_tables_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3221 = input.readListBegin();
          const _size220 = _rtmp3221.size || 0;
          for (let _i222 = 0; _i222 < _size220; ++_i222) {
            let elem223 = null;
            elem223 = input.readString();
            this.success.push(elem223);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_physical_tables_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter224 in this.success) {
        if (this.success.hasOwnProperty(iter224)) {
          iter224 = this.success[iter224];
          output.writeString(iter224);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_views_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_views_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_views_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3226 = input.readListBegin();
          const _size225 = _rtmp3226.size || 0;
          for (let _i227 = 0; _i227 < _size225; ++_i227) {
            let elem228 = null;
            elem228 = input.readString();
            this.success.push(elem228);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_views_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter229 in this.success) {
        if (this.success.hasOwnProperty(iter229)) {
          iter229 = this.success[iter229];
          output.writeString(iter229);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_meta_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_meta_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_tables_meta_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TTableMeta]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3231 = input.readListBegin();
          const _size230 = _rtmp3231.size || 0;
          for (let _i232 = 0; _i232 < _size230; ++_i232) {
            let elem233 = null;
            elem233 = new ttypes.TTableMeta();
            elem233.read(input);
            this.success.push(elem233);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_tables_meta_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter234 in this.success) {
        if (this.success.hasOwnProperty(iter234)) {
          iter234 = this.success[iter234];
          iter234.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_details_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_details_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_details_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableDetails(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableDetails();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_details_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_details_for_database_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.database_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.database_name !== undefined && args.database_name !== null) {
        this.database_name = args.database_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.database_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_details_for_database_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.database_name !== null && this.database_name !== undefined) {
      output.writeFieldBegin('database_name', Thrift.Type.STRING, 3);
      output.writeString(this.database_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_details_for_database_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableDetails(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableDetails();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_details_for_database_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_internal_table_details_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.include_system_columns = true;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.include_system_columns !== undefined && args.include_system_columns !== null) {
        this.include_system_columns = args.include_system_columns;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.include_system_columns = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_internal_table_details_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.include_system_columns !== null && this.include_system_columns !== undefined) {
      output.writeFieldBegin('include_system_columns', Thrift.Type.BOOL, 3);
      output.writeBool(this.include_system_columns);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_internal_table_details_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableDetails(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableDetails();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_internal_table_details_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_internal_table_details_for_database_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.database_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.database_name !== undefined && args.database_name !== null) {
        this.database_name = args.database_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.database_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_internal_table_details_for_database_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.database_name !== null && this.database_name !== undefined) {
      output.writeFieldBegin('database_name', Thrift.Type.STRING, 3);
      output.writeString(this.database_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_internal_table_details_for_database_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableDetails(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableDetails();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_internal_table_details_for_database_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_users_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_users_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_users_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3236 = input.readListBegin();
          const _size235 = _rtmp3236.size || 0;
          for (let _i237 = 0; _i237 < _size235; ++_i237) {
            let elem238 = null;
            elem238 = input.readString();
            this.success.push(elem238);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_users_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter239 in this.success) {
        if (this.success.hasOwnProperty(iter239)) {
          iter239 = this.success[iter239];
          output.writeString(iter239);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_databases_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_databases_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_databases_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDBInfo]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3241 = input.readListBegin();
          const _size240 = _rtmp3241.size || 0;
          for (let _i242 = 0; _i242 < _size240; ++_i242) {
            let elem243 = null;
            elem243 = new ttypes.TDBInfo();
            elem243.read(input);
            this.success.push(elem243);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_databases_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter244 in this.success) {
        if (this.success.hasOwnProperty(iter244)) {
          iter244 = this.success[iter244];
          iter244.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_version_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_version_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_version_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_version_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_heap_profile_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_heap_profile_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_heap_profile_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_heap_profile_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_stop_heap_profile_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_stop_heap_profile_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_stop_heap_profile_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_stop_heap_profile_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_heap_profile_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_heap_profile_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_heap_profile_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_heap_profile_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_memory_args = class {
  constructor(args) {
    this.session = null;
    this.memory_level = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.memory_level !== undefined && args.memory_level !== null) {
        this.memory_level = args.memory_level;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.memory_level = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_memory_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.memory_level !== null && this.memory_level !== undefined) {
      output.writeFieldBegin('memory_level', Thrift.Type.STRING, 2);
      output.writeString(this.memory_level);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_memory_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TNodeMemoryInfo]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3246 = input.readListBegin();
          const _size245 = _rtmp3246.size || 0;
          for (let _i247 = 0; _i247 < _size245; ++_i247) {
            let elem248 = null;
            elem248 = new ttypes.TNodeMemoryInfo();
            elem248.read(input);
            this.success.push(elem248);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_memory_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter249 in this.success) {
        if (this.success.hasOwnProperty(iter249)) {
          iter249 = this.success[iter249];
          iter249.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clear_cpu_memory_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clear_cpu_memory_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clear_cpu_memory_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clear_cpu_memory_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clear_gpu_memory_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clear_gpu_memory_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_clear_gpu_memory_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_clear_gpu_memory_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_cur_session_args = class {
  constructor(args) {
    this.parent_session = null;
    this.leaf_session = null;
    this.start_time_str = null;
    this.label = null;
    this.for_running_query_kernel = null;
    if (args) {
      if (args.parent_session !== undefined && args.parent_session !== null) {
        this.parent_session = args.parent_session;
      }
      if (args.leaf_session !== undefined && args.leaf_session !== null) {
        this.leaf_session = args.leaf_session;
      }
      if (args.start_time_str !== undefined && args.start_time_str !== null) {
        this.start_time_str = args.start_time_str;
      }
      if (args.label !== undefined && args.label !== null) {
        this.label = args.label;
      }
      if (args.for_running_query_kernel !== undefined && args.for_running_query_kernel !== null) {
        this.for_running_query_kernel = args.for_running_query_kernel;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.parent_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.leaf_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.start_time_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.label = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.for_running_query_kernel = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_cur_session_args');
    if (this.parent_session !== null && this.parent_session !== undefined) {
      output.writeFieldBegin('parent_session', Thrift.Type.STRING, 1);
      output.writeString(this.parent_session);
      output.writeFieldEnd();
    }
    if (this.leaf_session !== null && this.leaf_session !== undefined) {
      output.writeFieldBegin('leaf_session', Thrift.Type.STRING, 2);
      output.writeString(this.leaf_session);
      output.writeFieldEnd();
    }
    if (this.start_time_str !== null && this.start_time_str !== undefined) {
      output.writeFieldBegin('start_time_str', Thrift.Type.STRING, 3);
      output.writeString(this.start_time_str);
      output.writeFieldEnd();
    }
    if (this.label !== null && this.label !== undefined) {
      output.writeFieldBegin('label', Thrift.Type.STRING, 4);
      output.writeString(this.label);
      output.writeFieldEnd();
    }
    if (this.for_running_query_kernel !== null && this.for_running_query_kernel !== undefined) {
      output.writeFieldBegin('for_running_query_kernel', Thrift.Type.BOOL, 5);
      output.writeBool(this.for_running_query_kernel);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_cur_session_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_cur_session_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_invalidate_cur_session_args = class {
  constructor(args) {
    this.parent_session = null;
    this.leaf_session = null;
    this.start_time_str = null;
    this.label = null;
    this.for_running_query_kernel = null;
    if (args) {
      if (args.parent_session !== undefined && args.parent_session !== null) {
        this.parent_session = args.parent_session;
      }
      if (args.leaf_session !== undefined && args.leaf_session !== null) {
        this.leaf_session = args.leaf_session;
      }
      if (args.start_time_str !== undefined && args.start_time_str !== null) {
        this.start_time_str = args.start_time_str;
      }
      if (args.label !== undefined && args.label !== null) {
        this.label = args.label;
      }
      if (args.for_running_query_kernel !== undefined && args.for_running_query_kernel !== null) {
        this.for_running_query_kernel = args.for_running_query_kernel;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.parent_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.leaf_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.start_time_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.label = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.for_running_query_kernel = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_invalidate_cur_session_args');
    if (this.parent_session !== null && this.parent_session !== undefined) {
      output.writeFieldBegin('parent_session', Thrift.Type.STRING, 1);
      output.writeString(this.parent_session);
      output.writeFieldEnd();
    }
    if (this.leaf_session !== null && this.leaf_session !== undefined) {
      output.writeFieldBegin('leaf_session', Thrift.Type.STRING, 2);
      output.writeString(this.leaf_session);
      output.writeFieldEnd();
    }
    if (this.start_time_str !== null && this.start_time_str !== undefined) {
      output.writeFieldBegin('start_time_str', Thrift.Type.STRING, 3);
      output.writeString(this.start_time_str);
      output.writeFieldEnd();
    }
    if (this.label !== null && this.label !== undefined) {
      output.writeFieldBegin('label', Thrift.Type.STRING, 4);
      output.writeString(this.label);
      output.writeFieldEnd();
    }
    if (this.for_running_query_kernel !== null && this.for_running_query_kernel !== undefined) {
      output.writeFieldBegin('for_running_query_kernel', Thrift.Type.BOOL, 5);
      output.writeBool(this.for_running_query_kernel);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_invalidate_cur_session_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_invalidate_cur_session_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epoch_args = class {
  constructor(args) {
    this.session = null;
    this.db_id = null;
    this.table_id = null;
    this.new_epoch = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.new_epoch !== undefined && args.new_epoch !== null) {
        this.new_epoch = args.new_epoch;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.new_epoch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epoch_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 3);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.new_epoch !== null && this.new_epoch !== undefined) {
      output.writeFieldBegin('new_epoch', Thrift.Type.I32, 4);
      output.writeI32(this.new_epoch);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epoch_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epoch_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epoch_by_name_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.new_epoch = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.new_epoch !== undefined && args.new_epoch !== null) {
        this.new_epoch = args.new_epoch;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.new_epoch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epoch_by_name_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.new_epoch !== null && this.new_epoch !== undefined) {
      output.writeFieldBegin('new_epoch', Thrift.Type.I32, 3);
      output.writeI32(this.new_epoch);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epoch_by_name_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epoch_by_name_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epoch_args = class {
  constructor(args) {
    this.session = null;
    this.db_id = null;
    this.table_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epoch_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 3);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epoch_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epoch_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epoch_by_name_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epoch_by_name_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epoch_by_name_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epoch_by_name_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epochs_args = class {
  constructor(args) {
    this.session = null;
    this.db_id = null;
    this.table_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epochs_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 3);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_epochs_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TTableEpochInfo]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3251 = input.readListBegin();
          const _size250 = _rtmp3251.size || 0;
          for (let _i252 = 0; _i252 < _size250; ++_i252) {
            let elem253 = null;
            elem253 = new ttypes.TTableEpochInfo();
            elem253.read(input);
            this.success.push(elem253);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_epochs_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter254 in this.success) {
        if (this.success.hasOwnProperty(iter254)) {
          iter254 = this.success[iter254];
          iter254.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epochs_args = class {
  constructor(args) {
    this.session = null;
    this.db_id = null;
    this.table_epochs = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_epochs !== undefined && args.table_epochs !== null) {
        this.table_epochs = Thrift.copyList(args.table_epochs, [ttypes.TTableEpochInfo]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.table_epochs = [];
          const _rtmp3256 = input.readListBegin();
          const _size255 = _rtmp3256.size || 0;
          for (let _i257 = 0; _i257 < _size255; ++_i257) {
            let elem258 = null;
            elem258 = new ttypes.TTableEpochInfo();
            elem258.read(input);
            this.table_epochs.push(elem258);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epochs_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_epochs !== null && this.table_epochs !== undefined) {
      output.writeFieldBegin('table_epochs', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.table_epochs.length);
      for (let iter259 in this.table_epochs) {
        if (this.table_epochs.hasOwnProperty(iter259)) {
          iter259 = this.table_epochs[iter259];
          iter259.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_table_epochs_result = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_table_epochs_result');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_session_info_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_session_info_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_session_info_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TSessionInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TSessionInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_session_info_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_queries_info_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_queries_info_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_queries_info_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TQueryInfo]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3261 = input.readListBegin();
          const _size260 = _rtmp3261.size || 0;
          for (let _i262 = 0; _i262 < _size260; ++_i262) {
            let elem263 = null;
            elem263 = new ttypes.TQueryInfo();
            elem263.read(input);
            this.success.push(elem263);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_queries_info_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter264 in this.success) {
        if (this.success.hasOwnProperty(iter264)) {
          iter264 = this.success[iter264];
          iter264.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_leaf_info_args = class {
  constructor(args) {
    this.session = null;
    this.leaf_info = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.leaf_info !== undefined && args.leaf_info !== null) {
        this.leaf_info = new ttypes.TLeafInfo(args.leaf_info);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.leaf_info = new ttypes.TLeafInfo();
          this.leaf_info.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_leaf_info_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.leaf_info !== null && this.leaf_info !== undefined) {
      output.writeFieldBegin('leaf_info', Thrift.Type.STRUCT, 2);
      this.leaf_info.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_leaf_info_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_leaf_info_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    this.column_format = null;
    this.nonce = null;
    this.first_n = -1;
    this.at_most_n = -1;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
      if (args.column_format !== undefined && args.column_format !== null) {
        this.column_format = args.column_format;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
      if (args.first_n !== undefined && args.first_n !== null) {
        this.first_n = args.first_n;
      }
      if (args.at_most_n !== undefined && args.at_most_n !== null) {
        this.at_most_n = args.at_most_n;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.column_format = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.first_n = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.at_most_n = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    if (this.column_format !== null && this.column_format !== undefined) {
      output.writeFieldBegin('column_format', Thrift.Type.BOOL, 3);
      output.writeBool(this.column_format);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 4);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    if (this.first_n !== null && this.first_n !== undefined) {
      output.writeFieldBegin('first_n', Thrift.Type.I32, 5);
      output.writeI32(this.first_n);
      output.writeFieldEnd();
    }
    if (this.at_most_n !== null && this.at_most_n !== undefined) {
      output.writeFieldBegin('at_most_n', Thrift.Type.I32, 6);
      output.writeI32(this.at_most_n);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TQueryResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TQueryResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_df_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    this.device_type = null;
    this.device_id = 0;
    this.first_n = -1;
    this.transport_method = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
      if (args.device_type !== undefined && args.device_type !== null) {
        this.device_type = args.device_type;
      }
      if (args.device_id !== undefined && args.device_id !== null) {
        this.device_id = args.device_id;
      }
      if (args.first_n !== undefined && args.first_n !== null) {
        this.first_n = args.first_n;
      }
      if (args.transport_method !== undefined && args.transport_method !== null) {
        this.transport_method = args.transport_method;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.device_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.device_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.first_n = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.transport_method = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_df_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    if (this.device_type !== null && this.device_type !== undefined) {
      output.writeFieldBegin('device_type', Thrift.Type.I32, 3);
      output.writeI32(this.device_type);
      output.writeFieldEnd();
    }
    if (this.device_id !== null && this.device_id !== undefined) {
      output.writeFieldBegin('device_id', Thrift.Type.I32, 4);
      output.writeI32(this.device_id);
      output.writeFieldEnd();
    }
    if (this.first_n !== null && this.first_n !== undefined) {
      output.writeFieldBegin('first_n', Thrift.Type.I32, 5);
      output.writeI32(this.first_n);
      output.writeFieldEnd();
    }
    if (this.transport_method !== null && this.transport_method !== undefined) {
      output.writeFieldBegin('transport_method', Thrift.Type.I32, 6);
      output.writeI32(this.transport_method);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_df_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TDataFrame(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TDataFrame();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_df_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_gdf_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    this.device_id = 0;
    this.first_n = -1;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
      if (args.device_id !== undefined && args.device_id !== null) {
        this.device_id = args.device_id;
      }
      if (args.first_n !== undefined && args.first_n !== null) {
        this.first_n = args.first_n;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.device_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.first_n = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_gdf_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    if (this.device_id !== null && this.device_id !== undefined) {
      output.writeFieldBegin('device_id', Thrift.Type.I32, 3);
      output.writeI32(this.device_id);
      output.writeFieldEnd();
    }
    if (this.first_n !== null && this.first_n !== undefined) {
      output.writeFieldBegin('first_n', Thrift.Type.I32, 4);
      output.writeI32(this.first_n);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_execute_gdf_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TDataFrame(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TDataFrame();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_execute_gdf_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_deallocate_df_args = class {
  constructor(args) {
    this.session = null;
    this.df = null;
    this.device_type = null;
    this.device_id = 0;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.df !== undefined && args.df !== null) {
        this.df = new ttypes.TDataFrame(args.df);
      }
      if (args.device_type !== undefined && args.device_type !== null) {
        this.device_type = args.device_type;
      }
      if (args.device_id !== undefined && args.device_id !== null) {
        this.device_id = args.device_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.df = new ttypes.TDataFrame();
          this.df.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.device_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.device_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_deallocate_df_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.df !== null && this.df !== undefined) {
      output.writeFieldBegin('df', Thrift.Type.STRUCT, 2);
      this.df.write(output);
      output.writeFieldEnd();
    }
    if (this.device_type !== null && this.device_type !== undefined) {
      output.writeFieldBegin('device_type', Thrift.Type.I32, 3);
      output.writeI32(this.device_type);
      output.writeFieldEnd();
    }
    if (this.device_id !== null && this.device_id !== undefined) {
      output.writeFieldBegin('device_id', Thrift.Type.I32, 4);
      output.writeI32(this.device_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_deallocate_df_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_deallocate_df_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_interrupt_args = class {
  constructor(args) {
    this.query_session = null;
    this.interrupt_session = null;
    if (args) {
      if (args.query_session !== undefined && args.query_session !== null) {
        this.query_session = args.query_session;
      }
      if (args.interrupt_session !== undefined && args.interrupt_session !== null) {
        this.interrupt_session = args.interrupt_session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.query_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.interrupt_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_interrupt_args');
    if (this.query_session !== null && this.query_session !== undefined) {
      output.writeFieldBegin('query_session', Thrift.Type.STRING, 1);
      output.writeString(this.query_session);
      output.writeFieldEnd();
    }
    if (this.interrupt_session !== null && this.interrupt_session !== undefined) {
      output.writeFieldBegin('interrupt_session', Thrift.Type.STRING, 2);
      output.writeString(this.interrupt_session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_interrupt_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_interrupt_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_validate_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_validate_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_sql_validate_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TColumnType]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3266 = input.readListBegin();
          const _size265 = _rtmp3266.size || 0;
          for (let _i267 = 0; _i267 < _size265; ++_i267) {
            let elem268 = null;
            elem268 = new ttypes.TColumnType();
            elem268.read(input);
            this.success.push(elem268);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_sql_validate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter269 in this.success) {
        if (this.success.hasOwnProperty(iter269)) {
          iter269 = this.success[iter269];
          iter269.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_completion_hints_args = class {
  constructor(args) {
    this.session = null;
    this.sql = null;
    this.cursor = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.sql !== undefined && args.sql !== null) {
        this.sql = args.sql;
      }
      if (args.cursor !== undefined && args.cursor !== null) {
        this.cursor = args.cursor;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sql = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.cursor = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_completion_hints_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.sql !== null && this.sql !== undefined) {
      output.writeFieldBegin('sql', Thrift.Type.STRING, 2);
      output.writeString(this.sql);
      output.writeFieldEnd();
    }
    if (this.cursor !== null && this.cursor !== undefined) {
      output.writeFieldBegin('cursor', Thrift.Type.I32, 3);
      output.writeI32(this.cursor);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_completion_hints_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [completion_hints_ttypes.TCompletionHint]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3271 = input.readListBegin();
          const _size270 = _rtmp3271.size || 0;
          for (let _i272 = 0; _i272 < _size270; ++_i272) {
            let elem273 = null;
            elem273 = new completion_hints_ttypes.TCompletionHint();
            elem273.read(input);
            this.success.push(elem273);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_completion_hints_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter274 in this.success) {
        if (this.success.hasOwnProperty(iter274)) {
          iter274 = this.success[iter274];
          iter274.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_execution_mode_args = class {
  constructor(args) {
    this.session = null;
    this.mode = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.mode !== undefined && args.mode !== null) {
        this.mode = args.mode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.mode = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_execution_mode_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.mode !== null && this.mode !== undefined) {
      output.writeFieldBegin('mode', Thrift.Type.I32, 2);
      output.writeI32(this.mode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_execution_mode_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_execution_mode_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_render_vega_args = class {
  constructor(args) {
    this.session = null;
    this.widget_id = null;
    this.vega_json = null;
    this.compression_level = null;
    this.nonce = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.widget_id !== undefined && args.widget_id !== null) {
        this.widget_id = args.widget_id;
      }
      if (args.vega_json !== undefined && args.vega_json !== null) {
        this.vega_json = args.vega_json;
      }
      if (args.compression_level !== undefined && args.compression_level !== null) {
        this.compression_level = args.compression_level;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.widget_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.vega_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.compression_level = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_render_vega_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.widget_id !== null && this.widget_id !== undefined) {
      output.writeFieldBegin('widget_id', Thrift.Type.I64, 2);
      output.writeI64(this.widget_id);
      output.writeFieldEnd();
    }
    if (this.vega_json !== null && this.vega_json !== undefined) {
      output.writeFieldBegin('vega_json', Thrift.Type.STRING, 3);
      output.writeString(this.vega_json);
      output.writeFieldEnd();
    }
    if (this.compression_level !== null && this.compression_level !== undefined) {
      output.writeFieldBegin('compression_level', Thrift.Type.I32, 4);
      output.writeI32(this.compression_level);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 5);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_render_vega_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TRenderResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TRenderResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_render_vega_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_result_row_for_pixel_args = class {
  constructor(args) {
    this.session = null;
    this.widget_id = null;
    this.pixel = null;
    this.table_col_names = null;
    this.column_format = null;
    this.pixelRadius = null;
    this.nonce = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.widget_id !== undefined && args.widget_id !== null) {
        this.widget_id = args.widget_id;
      }
      if (args.pixel !== undefined && args.pixel !== null) {
        this.pixel = new ttypes.TPixel(args.pixel);
      }
      if (args.table_col_names !== undefined && args.table_col_names !== null) {
        this.table_col_names = Thrift.copyMap(args.table_col_names, [Thrift.copyList, null]);
      }
      if (args.column_format !== undefined && args.column_format !== null) {
        this.column_format = args.column_format;
      }
      if (args.pixelRadius !== undefined && args.pixelRadius !== null) {
        this.pixelRadius = args.pixelRadius;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.widget_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.pixel = new ttypes.TPixel();
          this.pixel.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.MAP) {
          this.table_col_names = {};
          const _rtmp3276 = input.readMapBegin();
          const _size275 = _rtmp3276.size || 0;
          for (let _i277 = 0; _i277 < _size275; ++_i277) {
            let key278 = null;
            let val279 = null;
            key278 = input.readString();
            val279 = [];
            const _rtmp3281 = input.readListBegin();
            const _size280 = _rtmp3281.size || 0;
            for (let _i282 = 0; _i282 < _size280; ++_i282) {
              let elem283 = null;
              elem283 = input.readString();
              val279.push(elem283);
            }
            input.readListEnd();
            this.table_col_names[key278] = val279;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.column_format = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.pixelRadius = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_result_row_for_pixel_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.widget_id !== null && this.widget_id !== undefined) {
      output.writeFieldBegin('widget_id', Thrift.Type.I64, 2);
      output.writeI64(this.widget_id);
      output.writeFieldEnd();
    }
    if (this.pixel !== null && this.pixel !== undefined) {
      output.writeFieldBegin('pixel', Thrift.Type.STRUCT, 3);
      this.pixel.write(output);
      output.writeFieldEnd();
    }
    if (this.table_col_names !== null && this.table_col_names !== undefined) {
      output.writeFieldBegin('table_col_names', Thrift.Type.MAP, 4);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.table_col_names));
      for (let kiter284 in this.table_col_names) {
        if (this.table_col_names.hasOwnProperty(kiter284)) {
          let viter285 = this.table_col_names[kiter284];
          output.writeString(kiter284);
          output.writeListBegin(Thrift.Type.STRING, viter285.length);
          for (let iter286 in viter285) {
            if (viter285.hasOwnProperty(iter286)) {
              iter286 = viter285[iter286];
              output.writeString(iter286);
            }
          }
          output.writeListEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.column_format !== null && this.column_format !== undefined) {
      output.writeFieldBegin('column_format', Thrift.Type.BOOL, 5);
      output.writeBool(this.column_format);
      output.writeFieldEnd();
    }
    if (this.pixelRadius !== null && this.pixelRadius !== undefined) {
      output.writeFieldBegin('pixelRadius', Thrift.Type.I32, 6);
      output.writeI32(this.pixelRadius);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 7);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_result_row_for_pixel_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TPixelTableRowResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TPixelTableRowResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_result_row_for_pixel_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_custom_expression_args = class {
  constructor(args) {
    this.session = null;
    this.custom_expression = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.custom_expression !== undefined && args.custom_expression !== null) {
        this.custom_expression = new ttypes.TCustomExpression(args.custom_expression);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.custom_expression = new ttypes.TCustomExpression();
          this.custom_expression.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_custom_expression_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.custom_expression !== null && this.custom_expression !== undefined) {
      output.writeFieldBegin('custom_expression', Thrift.Type.STRUCT, 2);
      this.custom_expression.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_custom_expression_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_custom_expression_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_custom_expressions_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_custom_expressions_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_custom_expressions_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TCustomExpression]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3288 = input.readListBegin();
          const _size287 = _rtmp3288.size || 0;
          for (let _i289 = 0; _i289 < _size287; ++_i289) {
            let elem290 = null;
            elem290 = new ttypes.TCustomExpression();
            elem290.read(input);
            this.success.push(elem290);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_custom_expressions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter291 in this.success) {
        if (this.success.hasOwnProperty(iter291)) {
          iter291 = this.success[iter291];
          iter291.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_update_custom_expression_args = class {
  constructor(args) {
    this.session = null;
    this.id = null;
    this.expression_json = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.expression_json !== undefined && args.expression_json !== null) {
        this.expression_json = args.expression_json;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.expression_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_update_custom_expression_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.I32, 2);
      output.writeI32(this.id);
      output.writeFieldEnd();
    }
    if (this.expression_json !== null && this.expression_json !== undefined) {
      output.writeFieldBegin('expression_json', Thrift.Type.STRING, 3);
      output.writeString(this.expression_json);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_update_custom_expression_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_update_custom_expression_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_custom_expressions_args = class {
  constructor(args) {
    this.session = null;
    this.custom_expression_ids = null;
    this.do_soft_delete = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.custom_expression_ids !== undefined && args.custom_expression_ids !== null) {
        this.custom_expression_ids = Thrift.copyList(args.custom_expression_ids, [null]);
      }
      if (args.do_soft_delete !== undefined && args.do_soft_delete !== null) {
        this.do_soft_delete = args.do_soft_delete;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.custom_expression_ids = [];
          const _rtmp3293 = input.readListBegin();
          const _size292 = _rtmp3293.size || 0;
          for (let _i294 = 0; _i294 < _size292; ++_i294) {
            let elem295 = null;
            elem295 = input.readI32();
            this.custom_expression_ids.push(elem295);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.do_soft_delete = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_custom_expressions_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.custom_expression_ids !== null && this.custom_expression_ids !== undefined) {
      output.writeFieldBegin('custom_expression_ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.custom_expression_ids.length);
      for (let iter296 in this.custom_expression_ids) {
        if (this.custom_expression_ids.hasOwnProperty(iter296)) {
          iter296 = this.custom_expression_ids[iter296];
          output.writeI32(iter296);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.do_soft_delete !== null && this.do_soft_delete !== undefined) {
      output.writeFieldBegin('do_soft_delete', Thrift.Type.BOOL, 3);
      output.writeBool(this.do_soft_delete);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_custom_expressions_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_custom_expressions_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboard_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TDashboard(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TDashboard();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboard_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboards_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboards_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboards_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDashboard]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3298 = input.readListBegin();
          const _size297 = _rtmp3298.size || 0;
          for (let _i299 = 0; _i299 < _size297; ++_i299) {
            let elem300 = null;
            elem300 = new ttypes.TDashboard();
            elem300.read(input);
            this.success.push(elem300);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboards_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter301 in this.success) {
        if (this.success.hasOwnProperty(iter301)) {
          iter301 = this.success[iter301];
          iter301.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_name = null;
    this.dashboard_state = null;
    this.image_hash = null;
    this.dashboard_metadata = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_name !== undefined && args.dashboard_name !== null) {
        this.dashboard_name = args.dashboard_name;
      }
      if (args.dashboard_state !== undefined && args.dashboard_state !== null) {
        this.dashboard_state = args.dashboard_state;
      }
      if (args.image_hash !== undefined && args.image_hash !== null) {
        this.image_hash = args.image_hash;
      }
      if (args.dashboard_metadata !== undefined && args.dashboard_metadata !== null) {
        this.dashboard_metadata = args.dashboard_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.image_hash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_name !== null && this.dashboard_name !== undefined) {
      output.writeFieldBegin('dashboard_name', Thrift.Type.STRING, 2);
      output.writeString(this.dashboard_name);
      output.writeFieldEnd();
    }
    if (this.dashboard_state !== null && this.dashboard_state !== undefined) {
      output.writeFieldBegin('dashboard_state', Thrift.Type.STRING, 3);
      output.writeString(this.dashboard_state);
      output.writeFieldEnd();
    }
    if (this.image_hash !== null && this.image_hash !== undefined) {
      output.writeFieldBegin('image_hash', Thrift.Type.STRING, 4);
      output.writeString(this.image_hash);
      output.writeFieldEnd();
    }
    if (this.dashboard_metadata !== null && this.dashboard_metadata !== undefined) {
      output.writeFieldBegin('dashboard_metadata', Thrift.Type.STRING, 5);
      output.writeString(this.dashboard_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_dashboard_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_dashboard_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_replace_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    this.dashboard_name = null;
    this.dashboard_owner = null;
    this.dashboard_state = null;
    this.image_hash = null;
    this.dashboard_metadata = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
      if (args.dashboard_name !== undefined && args.dashboard_name !== null) {
        this.dashboard_name = args.dashboard_name;
      }
      if (args.dashboard_owner !== undefined && args.dashboard_owner !== null) {
        this.dashboard_owner = args.dashboard_owner;
      }
      if (args.dashboard_state !== undefined && args.dashboard_state !== null) {
        this.dashboard_state = args.dashboard_state;
      }
      if (args.image_hash !== undefined && args.image_hash !== null) {
        this.image_hash = args.image_hash;
      }
      if (args.dashboard_metadata !== undefined && args.dashboard_metadata !== null) {
        this.dashboard_metadata = args.dashboard_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_owner = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.image_hash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_replace_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    if (this.dashboard_name !== null && this.dashboard_name !== undefined) {
      output.writeFieldBegin('dashboard_name', Thrift.Type.STRING, 3);
      output.writeString(this.dashboard_name);
      output.writeFieldEnd();
    }
    if (this.dashboard_owner !== null && this.dashboard_owner !== undefined) {
      output.writeFieldBegin('dashboard_owner', Thrift.Type.STRING, 4);
      output.writeString(this.dashboard_owner);
      output.writeFieldEnd();
    }
    if (this.dashboard_state !== null && this.dashboard_state !== undefined) {
      output.writeFieldBegin('dashboard_state', Thrift.Type.STRING, 5);
      output.writeString(this.dashboard_state);
      output.writeFieldEnd();
    }
    if (this.image_hash !== null && this.image_hash !== undefined) {
      output.writeFieldBegin('image_hash', Thrift.Type.STRING, 6);
      output.writeString(this.image_hash);
      output.writeFieldEnd();
    }
    if (this.dashboard_metadata !== null && this.dashboard_metadata !== undefined) {
      output.writeFieldBegin('dashboard_metadata', Thrift.Type.STRING, 7);
      output.writeString(this.dashboard_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_replace_dashboard_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_replace_dashboard_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_dashboard_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_dashboard_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_share_dashboards_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_ids = null;
    this.groups = null;
    this.permissions = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_ids !== undefined && args.dashboard_ids !== null) {
        this.dashboard_ids = Thrift.copyList(args.dashboard_ids, [null]);
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [null]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.dashboard_ids = [];
          const _rtmp3303 = input.readListBegin();
          const _size302 = _rtmp3303.size || 0;
          for (let _i304 = 0; _i304 < _size302; ++_i304) {
            let elem305 = null;
            elem305 = input.readI32();
            this.dashboard_ids.push(elem305);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp3307 = input.readListBegin();
          const _size306 = _rtmp3307.size || 0;
          for (let _i308 = 0; _i308 < _size306; ++_i308) {
            let elem309 = null;
            elem309 = input.readString();
            this.groups.push(elem309);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_share_dashboards_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_ids !== null && this.dashboard_ids !== undefined) {
      output.writeFieldBegin('dashboard_ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.dashboard_ids.length);
      for (let iter310 in this.dashboard_ids) {
        if (this.dashboard_ids.hasOwnProperty(iter310)) {
          iter310 = this.dashboard_ids[iter310];
          output.writeI32(iter310);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.groups.length);
      for (let iter311 in this.groups) {
        if (this.groups.hasOwnProperty(iter311)) {
          iter311 = this.groups[iter311];
          output.writeString(iter311);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 4);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_share_dashboards_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_share_dashboards_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_dashboards_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_ids = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_ids !== undefined && args.dashboard_ids !== null) {
        this.dashboard_ids = Thrift.copyList(args.dashboard_ids, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.dashboard_ids = [];
          const _rtmp3313 = input.readListBegin();
          const _size312 = _rtmp3313.size || 0;
          for (let _i314 = 0; _i314 < _size312; ++_i314) {
            let elem315 = null;
            elem315 = input.readI32();
            this.dashboard_ids.push(elem315);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_dashboards_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_ids !== null && this.dashboard_ids !== undefined) {
      output.writeFieldBegin('dashboard_ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.dashboard_ids.length);
      for (let iter316 in this.dashboard_ids) {
        if (this.dashboard_ids.hasOwnProperty(iter316)) {
          iter316 = this.dashboard_ids[iter316];
          output.writeI32(iter316);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_delete_dashboards_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_delete_dashboards_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_share_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    this.groups = null;
    this.objects = null;
    this.permissions = null;
    this.grant_role = false;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [null]);
      }
      if (args.objects !== undefined && args.objects !== null) {
        this.objects = Thrift.copyList(args.objects, [null]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
      if (args.grant_role !== undefined && args.grant_role !== null) {
        this.grant_role = args.grant_role;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp3318 = input.readListBegin();
          const _size317 = _rtmp3318.size || 0;
          for (let _i319 = 0; _i319 < _size317; ++_i319) {
            let elem320 = null;
            elem320 = input.readString();
            this.groups.push(elem320);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.objects = [];
          const _rtmp3322 = input.readListBegin();
          const _size321 = _rtmp3322.size || 0;
          for (let _i323 = 0; _i323 < _size321; ++_i323) {
            let elem324 = null;
            elem324 = input.readString();
            this.objects.push(elem324);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.grant_role = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_share_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.groups.length);
      for (let iter325 in this.groups) {
        if (this.groups.hasOwnProperty(iter325)) {
          iter325 = this.groups[iter325];
          output.writeString(iter325);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.objects !== null && this.objects !== undefined) {
      output.writeFieldBegin('objects', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.objects.length);
      for (let iter326 in this.objects) {
        if (this.objects.hasOwnProperty(iter326)) {
          iter326 = this.objects[iter326];
          output.writeString(iter326);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 5);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    if (this.grant_role !== null && this.grant_role !== undefined) {
      output.writeFieldBegin('grant_role', Thrift.Type.BOOL, 6);
      output.writeBool(this.grant_role);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_share_dashboard_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_share_dashboard_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_unshare_dashboard_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    this.groups = null;
    this.objects = null;
    this.permissions = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [null]);
      }
      if (args.objects !== undefined && args.objects !== null) {
        this.objects = Thrift.copyList(args.objects, [null]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp3328 = input.readListBegin();
          const _size327 = _rtmp3328.size || 0;
          for (let _i329 = 0; _i329 < _size327; ++_i329) {
            let elem330 = null;
            elem330 = input.readString();
            this.groups.push(elem330);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.objects = [];
          const _rtmp3332 = input.readListBegin();
          const _size331 = _rtmp3332.size || 0;
          for (let _i333 = 0; _i333 < _size331; ++_i333) {
            let elem334 = null;
            elem334 = input.readString();
            this.objects.push(elem334);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_unshare_dashboard_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.groups.length);
      for (let iter335 in this.groups) {
        if (this.groups.hasOwnProperty(iter335)) {
          iter335 = this.groups[iter335];
          output.writeString(iter335);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.objects !== null && this.objects !== undefined) {
      output.writeFieldBegin('objects', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.objects.length);
      for (let iter336 in this.objects) {
        if (this.objects.hasOwnProperty(iter336)) {
          iter336 = this.objects[iter336];
          output.writeString(iter336);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 5);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_unshare_dashboard_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_unshare_dashboard_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_unshare_dashboards_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_ids = null;
    this.groups = null;
    this.permissions = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_ids !== undefined && args.dashboard_ids !== null) {
        this.dashboard_ids = Thrift.copyList(args.dashboard_ids, [null]);
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = Thrift.copyList(args.groups, [null]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.dashboard_ids = [];
          const _rtmp3338 = input.readListBegin();
          const _size337 = _rtmp3338.size || 0;
          for (let _i339 = 0; _i339 < _size337; ++_i339) {
            let elem340 = null;
            elem340 = input.readI32();
            this.dashboard_ids.push(elem340);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.groups = [];
          const _rtmp3342 = input.readListBegin();
          const _size341 = _rtmp3342.size || 0;
          for (let _i343 = 0; _i343 < _size341; ++_i343) {
            let elem344 = null;
            elem344 = input.readString();
            this.groups.push(elem344);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_unshare_dashboards_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_ids !== null && this.dashboard_ids !== undefined) {
      output.writeFieldBegin('dashboard_ids', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.dashboard_ids.length);
      for (let iter345 in this.dashboard_ids) {
        if (this.dashboard_ids.hasOwnProperty(iter345)) {
          iter345 = this.dashboard_ids[iter345];
          output.writeI32(iter345);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.groups.length);
      for (let iter346 in this.groups) {
        if (this.groups.hasOwnProperty(iter346)) {
          iter346 = this.groups[iter346];
          output.writeString(iter346);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 4);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_unshare_dashboards_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_unshare_dashboards_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboard_grantees_args = class {
  constructor(args) {
    this.session = null;
    this.dashboard_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboard_grantees_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 2);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_dashboard_grantees_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDashboardGrantees]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3348 = input.readListBegin();
          const _size347 = _rtmp3348.size || 0;
          for (let _i349 = 0; _i349 < _size347; ++_i349) {
            let elem350 = null;
            elem350 = new ttypes.TDashboardGrantees();
            elem350.read(input);
            this.success.push(elem350);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_dashboard_grantees_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter351 in this.success) {
        if (this.success.hasOwnProperty(iter351)) {
          iter351 = this.success[iter351];
          iter351.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_link_view_args = class {
  constructor(args) {
    this.session = null;
    this.link = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.link !== undefined && args.link !== null) {
        this.link = args.link;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.link = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_link_view_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.link !== null && this.link !== undefined) {
      output.writeFieldBegin('link', Thrift.Type.STRING, 2);
      output.writeString(this.link);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_link_view_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TFrontendView(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TFrontendView();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_link_view_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_link_args = class {
  constructor(args) {
    this.session = null;
    this.view_state = null;
    this.view_metadata = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.view_state !== undefined && args.view_state !== null) {
        this.view_state = args.view_state;
      }
      if (args.view_metadata !== undefined && args.view_metadata !== null) {
        this.view_metadata = args.view_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.view_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.view_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_link_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.view_state !== null && this.view_state !== undefined) {
      output.writeFieldBegin('view_state', Thrift.Type.STRING, 2);
      output.writeString(this.view_state);
      output.writeFieldEnd();
    }
    if (this.view_metadata !== null && this.view_metadata !== undefined) {
      output.writeFieldBegin('view_metadata', Thrift.Type.STRING, 3);
      output.writeString(this.view_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_link_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_link_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.rows = null;
    this.column_names = [];
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.rows !== undefined && args.rows !== null) {
        this.rows = Thrift.copyList(args.rows, [ttypes.TRow]);
      }
      if (args.column_names !== undefined && args.column_names !== null) {
        this.column_names = Thrift.copyList(args.column_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.rows = [];
          const _rtmp3353 = input.readListBegin();
          const _size352 = _rtmp3353.size || 0;
          for (let _i354 = 0; _i354 < _size352; ++_i354) {
            let elem355 = null;
            elem355 = new ttypes.TRow();
            elem355.read(input);
            this.rows.push(elem355);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.column_names = [];
          const _rtmp3357 = input.readListBegin();
          const _size356 = _rtmp3357.size || 0;
          for (let _i358 = 0; _i358 < _size356; ++_i358) {
            let elem359 = null;
            elem359 = input.readString();
            this.column_names.push(elem359);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.rows !== null && this.rows !== undefined) {
      output.writeFieldBegin('rows', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.rows.length);
      for (let iter360 in this.rows) {
        if (this.rows.hasOwnProperty(iter360)) {
          iter360 = this.rows[iter360];
          iter360.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.column_names !== null && this.column_names !== undefined) {
      output.writeFieldBegin('column_names', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.column_names.length);
      for (let iter361 in this.column_names) {
        if (this.column_names.hasOwnProperty(iter361)) {
          iter361 = this.column_names[iter361];
          output.writeString(iter361);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_columnar_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.cols = null;
    this.column_names = [];
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.cols !== undefined && args.cols !== null) {
        this.cols = Thrift.copyList(args.cols, [ttypes.TColumn]);
      }
      if (args.column_names !== undefined && args.column_names !== null) {
        this.column_names = Thrift.copyList(args.column_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.cols = [];
          const _rtmp3363 = input.readListBegin();
          const _size362 = _rtmp3363.size || 0;
          for (let _i364 = 0; _i364 < _size362; ++_i364) {
            let elem365 = null;
            elem365 = new ttypes.TColumn();
            elem365.read(input);
            this.cols.push(elem365);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.column_names = [];
          const _rtmp3367 = input.readListBegin();
          const _size366 = _rtmp3367.size || 0;
          for (let _i368 = 0; _i368 < _size366; ++_i368) {
            let elem369 = null;
            elem369 = input.readString();
            this.column_names.push(elem369);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_columnar_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.cols !== null && this.cols !== undefined) {
      output.writeFieldBegin('cols', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.cols.length);
      for (let iter370 in this.cols) {
        if (this.cols.hasOwnProperty(iter370)) {
          iter370 = this.cols[iter370];
          iter370.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.column_names !== null && this.column_names !== undefined) {
      output.writeFieldBegin('column_names', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.column_names.length);
      for (let iter371 in this.column_names) {
        if (this.column_names.hasOwnProperty(iter371)) {
          iter371 = this.column_names[iter371];
          output.writeString(iter371);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_columnar_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_columnar_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_arrow_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.arrow_stream = null;
    this.use_column_names = false;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.arrow_stream !== undefined && args.arrow_stream !== null) {
        this.arrow_stream = args.arrow_stream;
      }
      if (args.use_column_names !== undefined && args.use_column_names !== null) {
        this.use_column_names = args.use_column_names;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.arrow_stream = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.use_column_names = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_arrow_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.arrow_stream !== null && this.arrow_stream !== undefined) {
      output.writeFieldBegin('arrow_stream', Thrift.Type.STRING, 3);
      output.writeBinary(this.arrow_stream);
      output.writeFieldEnd();
    }
    if (this.use_column_names !== null && this.use_column_names !== undefined) {
      output.writeFieldBegin('use_column_names', Thrift.Type.BOOL, 4);
      output.writeBool(this.use_column_names);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_binary_arrow_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_binary_arrow_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.rows = null;
    this.column_names = [];
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.rows !== undefined && args.rows !== null) {
        this.rows = Thrift.copyList(args.rows, [ttypes.TStringRow]);
      }
      if (args.column_names !== undefined && args.column_names !== null) {
        this.column_names = Thrift.copyList(args.column_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.rows = [];
          const _rtmp3373 = input.readListBegin();
          const _size372 = _rtmp3373.size || 0;
          for (let _i374 = 0; _i374 < _size372; ++_i374) {
            let elem375 = null;
            elem375 = new ttypes.TStringRow();
            elem375.read(input);
            this.rows.push(elem375);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.column_names = [];
          const _rtmp3377 = input.readListBegin();
          const _size376 = _rtmp3377.size || 0;
          for (let _i378 = 0; _i378 < _size376; ++_i378) {
            let elem379 = null;
            elem379 = input.readString();
            this.column_names.push(elem379);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.rows !== null && this.rows !== undefined) {
      output.writeFieldBegin('rows', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.rows.length);
      for (let iter380 in this.rows) {
        if (this.rows.hasOwnProperty(iter380)) {
          iter380 = this.rows[iter380];
          iter380.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.column_names !== null && this.column_names !== undefined) {
      output.writeFieldBegin('column_names', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.column_names.length);
      for (let iter381 in this.column_names) {
        if (this.column_names.hasOwnProperty(iter381)) {
          iter381 = this.column_names[iter381];
          output.writeString(iter381);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_load_table_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_load_table_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_detect_column_types_args = class {
  constructor(args) {
    this.session = null;
    this.file_name = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.file_name !== undefined && args.file_name !== null) {
        this.file_name = args.file_name;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.file_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_detect_column_types_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.file_name !== null && this.file_name !== undefined) {
      output.writeFieldBegin('file_name', Thrift.Type.STRING, 2);
      output.writeString(this.file_name);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 3);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_detect_column_types_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TDetectResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TDetectResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_detect_column_types_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_table_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.row_desc = null;
    this.create_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.create_params !== undefined && args.create_params !== null) {
        this.create_params = new ttypes.TCreateParams(args.create_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp3383 = input.readListBegin();
          const _size382 = _rtmp3383.size || 0;
          for (let _i384 = 0; _i384 < _size382; ++_i384) {
            let elem385 = null;
            elem385 = new ttypes.TColumnType();
            elem385.read(input);
            this.row_desc.push(elem385);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.create_params = new ttypes.TCreateParams();
          this.create_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_table_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter386 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter386)) {
          iter386 = this.row_desc[iter386];
          iter386.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.create_params !== null && this.create_params !== undefined) {
      output.writeFieldBegin('create_params', Thrift.Type.STRUCT, 4);
      this.create_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_create_table_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_create_table_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_table_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.file_name = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.file_name !== undefined && args.file_name !== null) {
        this.file_name = args.file_name;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.file_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_table_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.file_name !== null && this.file_name !== undefined) {
      output.writeFieldBegin('file_name', Thrift.Type.STRING, 3);
      output.writeString(this.file_name);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 4);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_table_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_table_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_geo_table_args = class {
  constructor(args) {
    this.session = null;
    this.table_name = null;
    this.file_name = null;
    this.copy_params = null;
    this.row_desc = null;
    this.create_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.file_name !== undefined && args.file_name !== null) {
        this.file_name = args.file_name;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.create_params !== undefined && args.create_params !== null) {
        this.create_params = new ttypes.TCreateParams(args.create_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.file_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp3388 = input.readListBegin();
          const _size387 = _rtmp3388.size || 0;
          for (let _i389 = 0; _i389 < _size387; ++_i389) {
            let elem390 = null;
            elem390 = new ttypes.TColumnType();
            elem390.read(input);
            this.row_desc.push(elem390);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.create_params = new ttypes.TCreateParams();
          this.create_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_geo_table_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 2);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.file_name !== null && this.file_name !== undefined) {
      output.writeFieldBegin('file_name', Thrift.Type.STRING, 3);
      output.writeString(this.file_name);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 4);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter391 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter391)) {
          iter391 = this.row_desc[iter391];
          iter391.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.create_params !== null && this.create_params !== undefined) {
      output.writeFieldBegin('create_params', Thrift.Type.STRUCT, 6);
      this.create_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_geo_table_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_geo_table_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_table_status_args = class {
  constructor(args) {
    this.session = null;
    this.import_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.import_id !== undefined && args.import_id !== null) {
        this.import_id = args.import_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.import_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_table_status_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.import_id !== null && this.import_id !== undefined) {
      output.writeFieldBegin('import_id', Thrift.Type.STRING, 2);
      output.writeString(this.import_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_import_table_status_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TImportStatus(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TImportStatus();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_import_table_status_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_first_geo_file_in_archive_args = class {
  constructor(args) {
    this.session = null;
    this.archive_path = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.archive_path !== undefined && args.archive_path !== null) {
        this.archive_path = args.archive_path;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.archive_path = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_first_geo_file_in_archive_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.archive_path !== null && this.archive_path !== undefined) {
      output.writeFieldBegin('archive_path', Thrift.Type.STRING, 2);
      output.writeString(this.archive_path);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 3);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_first_geo_file_in_archive_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_first_geo_file_in_archive_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_files_in_archive_args = class {
  constructor(args) {
    this.session = null;
    this.archive_path = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.archive_path !== undefined && args.archive_path !== null) {
        this.archive_path = args.archive_path;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.archive_path = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_files_in_archive_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.archive_path !== null && this.archive_path !== undefined) {
      output.writeFieldBegin('archive_path', Thrift.Type.STRING, 2);
      output.writeString(this.archive_path);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 3);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_files_in_archive_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3393 = input.readListBegin();
          const _size392 = _rtmp3393.size || 0;
          for (let _i394 = 0; _i394 < _size392; ++_i394) {
            let elem395 = null;
            elem395 = input.readString();
            this.success.push(elem395);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_files_in_archive_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter396 in this.success) {
        if (this.success.hasOwnProperty(iter396)) {
          iter396 = this.success[iter396];
          output.writeString(iter396);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_layers_in_geo_file_args = class {
  constructor(args) {
    this.session = null;
    this.file_name = null;
    this.copy_params = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.file_name !== undefined && args.file_name !== null) {
        this.file_name = args.file_name;
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.file_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_layers_in_geo_file_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.file_name !== null && this.file_name !== undefined) {
      output.writeFieldBegin('file_name', Thrift.Type.STRING, 2);
      output.writeString(this.file_name);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 3);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_layers_in_geo_file_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TGeoFileLayerInfo]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3398 = input.readListBegin();
          const _size397 = _rtmp3398.size || 0;
          for (let _i399 = 0; _i399 < _size397; ++_i399) {
            let elem400 = null;
            elem400 = new ttypes.TGeoFileLayerInfo();
            elem400.read(input);
            this.success.push(elem400);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_layers_in_geo_file_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter401 in this.success) {
        if (this.success.hasOwnProperty(iter401)) {
          iter401 = this.success[iter401];
          iter401.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_query_get_outer_fragment_count_args = class {
  constructor(args) {
    this.session = null;
    this.query = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.query !== undefined && args.query !== null) {
        this.query = args.query;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_query_get_outer_fragment_count_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.query !== null && this.query !== undefined) {
      output.writeFieldBegin('query', Thrift.Type.STRING, 2);
      output.writeString(this.query);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_query_get_outer_fragment_count_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_query_get_outer_fragment_count_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_check_table_consistency_args = class {
  constructor(args) {
    this.session = null;
    this.table_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_check_table_consistency_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 2);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_check_table_consistency_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TTableMeta(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TTableMeta();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_check_table_consistency_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_query_args = class {
  constructor(args) {
    this.leaf_session = null;
    this.parent_session = null;
    this.query_ra = null;
    this.start_time_str = null;
    this.just_explain = null;
    this.outer_fragment_indices = null;
    if (args) {
      if (args.leaf_session !== undefined && args.leaf_session !== null) {
        this.leaf_session = args.leaf_session;
      }
      if (args.parent_session !== undefined && args.parent_session !== null) {
        this.parent_session = args.parent_session;
      }
      if (args.query_ra !== undefined && args.query_ra !== null) {
        this.query_ra = args.query_ra;
      }
      if (args.start_time_str !== undefined && args.start_time_str !== null) {
        this.start_time_str = args.start_time_str;
      }
      if (args.just_explain !== undefined && args.just_explain !== null) {
        this.just_explain = args.just_explain;
      }
      if (args.outer_fragment_indices !== undefined && args.outer_fragment_indices !== null) {
        this.outer_fragment_indices = Thrift.copyList(args.outer_fragment_indices, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.leaf_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.parent_session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.query_ra = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.start_time_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.just_explain = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.outer_fragment_indices = [];
          const _rtmp3403 = input.readListBegin();
          const _size402 = _rtmp3403.size || 0;
          for (let _i404 = 0; _i404 < _size402; ++_i404) {
            let elem405 = null;
            elem405 = input.readI64();
            this.outer_fragment_indices.push(elem405);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_query_args');
    if (this.leaf_session !== null && this.leaf_session !== undefined) {
      output.writeFieldBegin('leaf_session', Thrift.Type.STRING, 1);
      output.writeString(this.leaf_session);
      output.writeFieldEnd();
    }
    if (this.parent_session !== null && this.parent_session !== undefined) {
      output.writeFieldBegin('parent_session', Thrift.Type.STRING, 2);
      output.writeString(this.parent_session);
      output.writeFieldEnd();
    }
    if (this.query_ra !== null && this.query_ra !== undefined) {
      output.writeFieldBegin('query_ra', Thrift.Type.STRING, 3);
      output.writeString(this.query_ra);
      output.writeFieldEnd();
    }
    if (this.start_time_str !== null && this.start_time_str !== undefined) {
      output.writeFieldBegin('start_time_str', Thrift.Type.STRING, 4);
      output.writeString(this.start_time_str);
      output.writeFieldEnd();
    }
    if (this.just_explain !== null && this.just_explain !== undefined) {
      output.writeFieldBegin('just_explain', Thrift.Type.BOOL, 5);
      output.writeBool(this.just_explain);
      output.writeFieldEnd();
    }
    if (this.outer_fragment_indices !== null && this.outer_fragment_indices !== undefined) {
      output.writeFieldBegin('outer_fragment_indices', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.I64, this.outer_fragment_indices.length);
      for (let iter406 in this.outer_fragment_indices) {
        if (this.outer_fragment_indices.hasOwnProperty(iter406)) {
          iter406 = this.outer_fragment_indices[iter406];
          output.writeI64(iter406);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_query_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TPendingQuery(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TPendingQuery();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_query_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_execute_query_step_args = class {
  constructor(args) {
    this.pending_query = null;
    this.subquery_id = null;
    this.start_time_str = null;
    if (args) {
      if (args.pending_query !== undefined && args.pending_query !== null) {
        this.pending_query = new ttypes.TPendingQuery(args.pending_query);
      }
      if (args.subquery_id !== undefined && args.subquery_id !== null) {
        this.subquery_id = args.subquery_id;
      }
      if (args.start_time_str !== undefined && args.start_time_str !== null) {
        this.start_time_str = args.start_time_str;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.pending_query = new ttypes.TPendingQuery();
          this.pending_query.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.subquery_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.start_time_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_execute_query_step_args');
    if (this.pending_query !== null && this.pending_query !== undefined) {
      output.writeFieldBegin('pending_query', Thrift.Type.STRUCT, 1);
      this.pending_query.write(output);
      output.writeFieldEnd();
    }
    if (this.subquery_id !== null && this.subquery_id !== undefined) {
      output.writeFieldBegin('subquery_id', Thrift.Type.I64, 2);
      output.writeI64(this.subquery_id);
      output.writeFieldEnd();
    }
    if (this.start_time_str !== null && this.start_time_str !== undefined) {
      output.writeFieldBegin('start_time_str', Thrift.Type.STRING, 3);
      output.writeString(this.start_time_str);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_execute_query_step_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TStepResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TStepResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_execute_query_step_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_broadcast_serialized_rows_args = class {
  constructor(args) {
    this.serialized_rows = null;
    this.row_desc = null;
    this.query_id = null;
    this.subquery_id = null;
    this.is_final_subquery_result = null;
    if (args) {
      if (args.serialized_rows !== undefined && args.serialized_rows !== null) {
        this.serialized_rows = new serialized_result_set_ttypes.TSerializedRows(args.serialized_rows);
      }
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.query_id !== undefined && args.query_id !== null) {
        this.query_id = args.query_id;
      }
      if (args.subquery_id !== undefined && args.subquery_id !== null) {
        this.subquery_id = args.subquery_id;
      }
      if (args.is_final_subquery_result !== undefined && args.is_final_subquery_result !== null) {
        this.is_final_subquery_result = args.is_final_subquery_result;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.serialized_rows = new serialized_result_set_ttypes.TSerializedRows();
          this.serialized_rows.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp3408 = input.readListBegin();
          const _size407 = _rtmp3408.size || 0;
          for (let _i409 = 0; _i409 < _size407; ++_i409) {
            let elem410 = null;
            elem410 = new ttypes.TColumnType();
            elem410.read(input);
            this.row_desc.push(elem410);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.query_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.subquery_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.is_final_subquery_result = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_broadcast_serialized_rows_args');
    if (this.serialized_rows !== null && this.serialized_rows !== undefined) {
      output.writeFieldBegin('serialized_rows', Thrift.Type.STRUCT, 1);
      this.serialized_rows.write(output);
      output.writeFieldEnd();
    }
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter411 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter411)) {
          iter411 = this.row_desc[iter411];
          iter411.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.query_id !== null && this.query_id !== undefined) {
      output.writeFieldBegin('query_id', Thrift.Type.I64, 3);
      output.writeI64(this.query_id);
      output.writeFieldEnd();
    }
    if (this.subquery_id !== null && this.subquery_id !== undefined) {
      output.writeFieldBegin('subquery_id', Thrift.Type.I64, 4);
      output.writeI64(this.subquery_id);
      output.writeFieldEnd();
    }
    if (this.is_final_subquery_result !== null && this.is_final_subquery_result !== undefined) {
      output.writeFieldBegin('is_final_subquery_result', Thrift.Type.BOOL, 5);
      output.writeBool(this.is_final_subquery_result);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_broadcast_serialized_rows_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_broadcast_serialized_rows_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_render_query_args = class {
  constructor(args) {
    this.session = null;
    this.widget_id = null;
    this.node_idx = null;
    this.vega_json = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.widget_id !== undefined && args.widget_id !== null) {
        this.widget_id = args.widget_id;
      }
      if (args.node_idx !== undefined && args.node_idx !== null) {
        this.node_idx = args.node_idx;
      }
      if (args.vega_json !== undefined && args.vega_json !== null) {
        this.vega_json = args.vega_json;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.widget_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I16) {
          this.node_idx = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.vega_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_render_query_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.widget_id !== null && this.widget_id !== undefined) {
      output.writeFieldBegin('widget_id', Thrift.Type.I64, 2);
      output.writeI64(this.widget_id);
      output.writeFieldEnd();
    }
    if (this.node_idx !== null && this.node_idx !== undefined) {
      output.writeFieldBegin('node_idx', Thrift.Type.I16, 3);
      output.writeI16(this.node_idx);
      output.writeFieldEnd();
    }
    if (this.vega_json !== null && this.vega_json !== undefined) {
      output.writeFieldBegin('vega_json', Thrift.Type.STRING, 4);
      output.writeString(this.vega_json);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_start_render_query_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TPendingRenderQuery(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TPendingRenderQuery();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_start_render_query_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_execute_next_render_step_args = class {
  constructor(args) {
    this.pending_render = null;
    this.merged_data = null;
    if (args) {
      if (args.pending_render !== undefined && args.pending_render !== null) {
        this.pending_render = new ttypes.TPendingRenderQuery(args.pending_render);
      }
      if (args.merged_data !== undefined && args.merged_data !== null) {
        this.merged_data = Thrift.copyMap(args.merged_data, [Thrift.copyMap, Thrift.copyMap, Thrift.copyMap, Thrift.copyList, ttypes.TRenderDatum]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.pending_render = new ttypes.TPendingRenderQuery();
          this.pending_render.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.merged_data = {};
          const _rtmp3413 = input.readMapBegin();
          const _size412 = _rtmp3413.size || 0;
          for (let _i414 = 0; _i414 < _size412; ++_i414) {
            let key415 = null;
            let val416 = null;
            key415 = input.readString();
            val416 = {};
            const _rtmp3418 = input.readMapBegin();
            const _size417 = _rtmp3418.size || 0;
            for (let _i419 = 0; _i419 < _size417; ++_i419) {
              let key420 = null;
              let val421 = null;
              key420 = input.readString();
              val421 = {};
              const _rtmp3423 = input.readMapBegin();
              const _size422 = _rtmp3423.size || 0;
              for (let _i424 = 0; _i424 < _size422; ++_i424) {
                let key425 = null;
                let val426 = null;
                key425 = input.readString();
                val426 = {};
                const _rtmp3428 = input.readMapBegin();
                const _size427 = _rtmp3428.size || 0;
                for (let _i429 = 0; _i429 < _size427; ++_i429) {
                  let key430 = null;
                  let val431 = null;
                  key430 = input.readString();
                  val431 = [];
                  const _rtmp3433 = input.readListBegin();
                  const _size432 = _rtmp3433.size || 0;
                  for (let _i434 = 0; _i434 < _size432; ++_i434) {
                    let elem435 = null;
                    elem435 = new ttypes.TRenderDatum();
                    elem435.read(input);
                    val431.push(elem435);
                  }
                  input.readListEnd();
                  val426[key430] = val431;
                }
                input.readMapEnd();
                val421[key425] = val426;
              }
              input.readMapEnd();
              val416[key420] = val421;
            }
            input.readMapEnd();
            this.merged_data[key415] = val416;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_execute_next_render_step_args');
    if (this.pending_render !== null && this.pending_render !== undefined) {
      output.writeFieldBegin('pending_render', Thrift.Type.STRUCT, 1);
      this.pending_render.write(output);
      output.writeFieldEnd();
    }
    if (this.merged_data !== null && this.merged_data !== undefined) {
      output.writeFieldBegin('merged_data', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.merged_data));
      for (let kiter436 in this.merged_data) {
        if (this.merged_data.hasOwnProperty(kiter436)) {
          let viter437 = this.merged_data[kiter436];
          output.writeString(kiter436);
          output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(viter437));
          for (let kiter438 in viter437) {
            if (viter437.hasOwnProperty(kiter438)) {
              let viter439 = viter437[kiter438];
              output.writeString(kiter438);
              output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(viter439));
              for (let kiter440 in viter439) {
                if (viter439.hasOwnProperty(kiter440)) {
                  let viter441 = viter439[kiter440];
                  output.writeString(kiter440);
                  output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter441));
                  for (let kiter442 in viter441) {
                    if (viter441.hasOwnProperty(kiter442)) {
                      let viter443 = viter441[kiter442];
                      output.writeString(kiter442);
                      output.writeListBegin(Thrift.Type.STRUCT, viter443.length);
                      for (let iter444 in viter443) {
                        if (viter443.hasOwnProperty(iter444)) {
                          iter444 = viter443[iter444];
                          iter444.write(output);
                        }
                      }
                      output.writeListEnd();
                    }
                  }
                  output.writeMapEnd();
                }
              }
              output.writeMapEnd();
            }
          }
          output.writeMapEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_execute_next_render_step_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TRenderStepResult(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TRenderStepResult();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_execute_next_render_step_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_insert_data_args = class {
  constructor(args) {
    this.session = null;
    this.insert_data = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.insert_data !== undefined && args.insert_data !== null) {
        this.insert_data = new ttypes.TInsertData(args.insert_data);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.insert_data = new ttypes.TInsertData();
          this.insert_data.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_insert_data_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.insert_data !== null && this.insert_data !== undefined) {
      output.writeFieldBegin('insert_data', Thrift.Type.STRUCT, 2);
      this.insert_data.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_insert_data_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_insert_data_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_insert_chunks_args = class {
  constructor(args) {
    this.session = null;
    this.insert_chunks = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.insert_chunks !== undefined && args.insert_chunks !== null) {
        this.insert_chunks = new ttypes.TInsertChunks(args.insert_chunks);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.insert_chunks = new ttypes.TInsertChunks();
          this.insert_chunks.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_insert_chunks_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.insert_chunks !== null && this.insert_chunks !== undefined) {
      output.writeFieldBegin('insert_chunks', Thrift.Type.STRUCT, 2);
      this.insert_chunks.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_insert_chunks_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_insert_chunks_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_checkpoint_args = class {
  constructor(args) {
    this.session = null;
    this.table_id = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_checkpoint_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 2);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_checkpoint_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_checkpoint_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_roles_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_roles_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_roles_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3446 = input.readListBegin();
          const _size445 = _rtmp3446.size || 0;
          for (let _i447 = 0; _i447 < _size445; ++_i447) {
            let elem448 = null;
            elem448 = input.readString();
            this.success.push(elem448);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_roles_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter449 in this.success) {
        if (this.success.hasOwnProperty(iter449)) {
          iter449 = this.success[iter449];
          output.writeString(iter449);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_db_objects_for_grantee_args = class {
  constructor(args) {
    this.session = null;
    this.roleName = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.roleName !== undefined && args.roleName !== null) {
        this.roleName = args.roleName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.roleName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_db_objects_for_grantee_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.roleName !== null && this.roleName !== undefined) {
      output.writeFieldBegin('roleName', Thrift.Type.STRING, 2);
      output.writeString(this.roleName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_db_objects_for_grantee_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDBObject]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3451 = input.readListBegin();
          const _size450 = _rtmp3451.size || 0;
          for (let _i452 = 0; _i452 < _size450; ++_i452) {
            let elem453 = null;
            elem453 = new ttypes.TDBObject();
            elem453.read(input);
            this.success.push(elem453);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_db_objects_for_grantee_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter454 in this.success) {
        if (this.success.hasOwnProperty(iter454)) {
          iter454 = this.success[iter454];
          iter454.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_db_object_privs_args = class {
  constructor(args) {
    this.session = null;
    this.objectName = null;
    this.type = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.objectName !== undefined && args.objectName !== null) {
        this.objectName = args.objectName;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.objectName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_db_object_privs_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.objectName !== null && this.objectName !== undefined) {
      output.writeFieldBegin('objectName', Thrift.Type.STRING, 2);
      output.writeString(this.objectName);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_db_object_privs_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ttypes.TDBObject]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3456 = input.readListBegin();
          const _size455 = _rtmp3456.size || 0;
          for (let _i457 = 0; _i457 < _size455; ++_i457) {
            let elem458 = null;
            elem458 = new ttypes.TDBObject();
            elem458.read(input);
            this.success.push(elem458);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_db_object_privs_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter459 in this.success) {
        if (this.success.hasOwnProperty(iter459)) {
          iter459 = this.success[iter459];
          iter459.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_roles_for_user_args = class {
  constructor(args) {
    this.session = null;
    this.userName = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.userName !== undefined && args.userName !== null) {
        this.userName = args.userName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_roles_for_user_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.userName !== null && this.userName !== undefined) {
      output.writeFieldBegin('userName', Thrift.Type.STRING, 2);
      output.writeString(this.userName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_roles_for_user_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3461 = input.readListBegin();
          const _size460 = _rtmp3461.size || 0;
          for (let _i462 = 0; _i462 < _size460; ++_i462) {
            let elem463 = null;
            elem463 = input.readString();
            this.success.push(elem463);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_roles_for_user_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter464 in this.success) {
        if (this.success.hasOwnProperty(iter464)) {
          iter464 = this.success[iter464];
          output.writeString(iter464);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_effective_roles_for_user_args = class {
  constructor(args) {
    this.session = null;
    this.userName = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.userName !== undefined && args.userName !== null) {
        this.userName = args.userName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_effective_roles_for_user_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.userName !== null && this.userName !== undefined) {
      output.writeFieldBegin('userName', Thrift.Type.STRING, 2);
      output.writeString(this.userName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_all_effective_roles_for_user_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3466 = input.readListBegin();
          const _size465 = _rtmp3466.size || 0;
          for (let _i467 = 0; _i467 < _size465; ++_i467) {
            let elem468 = null;
            elem468 = input.readString();
            this.success.push(elem468);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_all_effective_roles_for_user_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter469 in this.success) {
        if (this.success.hasOwnProperty(iter469)) {
          iter469 = this.success[iter469];
          output.writeString(iter469);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_has_role_args = class {
  constructor(args) {
    this.session = null;
    this.granteeName = null;
    this.roleName = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.granteeName !== undefined && args.granteeName !== null) {
        this.granteeName = args.granteeName;
      }
      if (args.roleName !== undefined && args.roleName !== null) {
        this.roleName = args.roleName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.granteeName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.roleName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_has_role_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.granteeName !== null && this.granteeName !== undefined) {
      output.writeFieldBegin('granteeName', Thrift.Type.STRING, 2);
      output.writeString(this.granteeName);
      output.writeFieldEnd();
    }
    if (this.roleName !== null && this.roleName !== undefined) {
      output.writeFieldBegin('roleName', Thrift.Type.STRING, 3);
      output.writeString(this.roleName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_has_role_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_has_role_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_has_object_privilege_args = class {
  constructor(args) {
    this.session = null;
    this.granteeName = null;
    this.ObjectName = null;
    this.objectType = null;
    this.permissions = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.granteeName !== undefined && args.granteeName !== null) {
        this.granteeName = args.granteeName;
      }
      if (args.ObjectName !== undefined && args.ObjectName !== null) {
        this.ObjectName = args.ObjectName;
      }
      if (args.objectType !== undefined && args.objectType !== null) {
        this.objectType = args.objectType;
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDBObjectPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.granteeName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.ObjectName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.objectType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDBObjectPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_has_object_privilege_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.granteeName !== null && this.granteeName !== undefined) {
      output.writeFieldBegin('granteeName', Thrift.Type.STRING, 2);
      output.writeString(this.granteeName);
      output.writeFieldEnd();
    }
    if (this.ObjectName !== null && this.ObjectName !== undefined) {
      output.writeFieldBegin('ObjectName', Thrift.Type.STRING, 3);
      output.writeString(this.ObjectName);
      output.writeFieldEnd();
    }
    if (this.objectType !== null && this.objectType !== undefined) {
      output.writeFieldBegin('objectType', Thrift.Type.I32, 4);
      output.writeI32(this.objectType);
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 5);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_has_object_privilege_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_has_object_privilege_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_license_key_args = class {
  constructor(args) {
    this.session = null;
    this.key = null;
    this.nonce = '';
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_license_key_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 3);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_set_license_key_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TLicenseInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TLicenseInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_set_license_key_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_license_claims_args = class {
  constructor(args) {
    this.session = null;
    this.nonce = '';
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_license_claims_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 2);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_license_claims_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ttypes.TLicenseInfo(args.success);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ttypes.TLicenseInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_license_claims_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_device_parameters_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_device_parameters_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_device_parameters_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3471 = input.readMapBegin();
          const _size470 = _rtmp3471.size || 0;
          for (let _i472 = 0; _i472 < _size470; ++_i472) {
            let key473 = null;
            let val474 = null;
            key473 = input.readString();
            val474 = input.readString();
            this.success[key473] = val474;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_device_parameters_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter475 in this.success) {
        if (this.success.hasOwnProperty(kiter475)) {
          let viter476 = this.success[kiter475];
          output.writeString(kiter475);
          output.writeString(viter476);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_register_runtime_extension_functions_args = class {
  constructor(args) {
    this.session = null;
    this.udfs = null;
    this.udtfs = null;
    this.device_ir_map = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.udfs !== undefined && args.udfs !== null) {
        this.udfs = Thrift.copyList(args.udfs, [extension_functions_ttypes.TUserDefinedFunction]);
      }
      if (args.udtfs !== undefined && args.udtfs !== null) {
        this.udtfs = Thrift.copyList(args.udtfs, [extension_functions_ttypes.TUserDefinedTableFunction]);
      }
      if (args.device_ir_map !== undefined && args.device_ir_map !== null) {
        this.device_ir_map = Thrift.copyMap(args.device_ir_map, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.udfs = [];
          const _rtmp3478 = input.readListBegin();
          const _size477 = _rtmp3478.size || 0;
          for (let _i479 = 0; _i479 < _size477; ++_i479) {
            let elem480 = null;
            elem480 = new extension_functions_ttypes.TUserDefinedFunction();
            elem480.read(input);
            this.udfs.push(elem480);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.udtfs = [];
          const _rtmp3482 = input.readListBegin();
          const _size481 = _rtmp3482.size || 0;
          for (let _i483 = 0; _i483 < _size481; ++_i483) {
            let elem484 = null;
            elem484 = new extension_functions_ttypes.TUserDefinedTableFunction();
            elem484.read(input);
            this.udtfs.push(elem484);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.MAP) {
          this.device_ir_map = {};
          const _rtmp3486 = input.readMapBegin();
          const _size485 = _rtmp3486.size || 0;
          for (let _i487 = 0; _i487 < _size485; ++_i487) {
            let key488 = null;
            let val489 = null;
            key488 = input.readString();
            val489 = input.readString();
            this.device_ir_map[key488] = val489;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_register_runtime_extension_functions_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.udfs !== null && this.udfs !== undefined) {
      output.writeFieldBegin('udfs', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.udfs.length);
      for (let iter490 in this.udfs) {
        if (this.udfs.hasOwnProperty(iter490)) {
          iter490 = this.udfs[iter490];
          iter490.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.udtfs !== null && this.udtfs !== undefined) {
      output.writeFieldBegin('udtfs', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.udtfs.length);
      for (let iter491 in this.udtfs) {
        if (this.udtfs.hasOwnProperty(iter491)) {
          iter491 = this.udtfs[iter491];
          iter491.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.device_ir_map !== null && this.device_ir_map !== undefined) {
      output.writeFieldBegin('device_ir_map', Thrift.Type.MAP, 4);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.device_ir_map));
      for (let kiter492 in this.device_ir_map) {
        if (this.device_ir_map.hasOwnProperty(kiter492)) {
          let viter493 = this.device_ir_map[kiter492];
          output.writeString(kiter492);
          output.writeString(viter493);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_register_runtime_extension_functions_result = class {
  constructor(args) {
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_register_runtime_extension_functions_result');
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_function_names_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_function_names_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_function_names_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3495 = input.readListBegin();
          const _size494 = _rtmp3495.size || 0;
          for (let _i496 = 0; _i496 < _size494; ++_i496) {
            let elem497 = null;
            elem497 = input.readString();
            this.success.push(elem497);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_function_names_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter498 in this.success) {
        if (this.success.hasOwnProperty(iter498)) {
          iter498 = this.success[iter498];
          output.writeString(iter498);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_runtime_table_function_names_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_runtime_table_function_names_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_runtime_table_function_names_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3500 = input.readListBegin();
          const _size499 = _rtmp3500.size || 0;
          for (let _i501 = 0; _i501 < _size499; ++_i501) {
            let elem502 = null;
            elem502 = input.readString();
            this.success.push(elem502);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_runtime_table_function_names_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter503 in this.success) {
        if (this.success.hasOwnProperty(iter503)) {
          iter503 = this.success[iter503];
          output.writeString(iter503);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_function_details_args = class {
  constructor(args) {
    this.session = null;
    this.udtf_names = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.udtf_names !== undefined && args.udtf_names !== null) {
        this.udtf_names = Thrift.copyList(args.udtf_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.udtf_names = [];
          const _rtmp3505 = input.readListBegin();
          const _size504 = _rtmp3505.size || 0;
          for (let _i506 = 0; _i506 < _size504; ++_i506) {
            let elem507 = null;
            elem507 = input.readString();
            this.udtf_names.push(elem507);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_function_details_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.udtf_names !== null && this.udtf_names !== undefined) {
      output.writeFieldBegin('udtf_names', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.udtf_names.length);
      for (let iter508 in this.udtf_names) {
        if (this.udtf_names.hasOwnProperty(iter508)) {
          iter508 = this.udtf_names[iter508];
          output.writeString(iter508);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_table_function_details_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [extension_functions_ttypes.TUserDefinedTableFunction]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3510 = input.readListBegin();
          const _size509 = _rtmp3510.size || 0;
          for (let _i511 = 0; _i511 < _size509; ++_i511) {
            let elem512 = null;
            elem512 = new extension_functions_ttypes.TUserDefinedTableFunction();
            elem512.read(input);
            this.success.push(elem512);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_table_function_details_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter513 in this.success) {
        if (this.success.hasOwnProperty(iter513)) {
          iter513 = this.success[iter513];
          iter513.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_function_names_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_function_names_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_function_names_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3515 = input.readListBegin();
          const _size514 = _rtmp3515.size || 0;
          for (let _i516 = 0; _i516 < _size514; ++_i516) {
            let elem517 = null;
            elem517 = input.readString();
            this.success.push(elem517);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_function_names_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter518 in this.success) {
        if (this.success.hasOwnProperty(iter518)) {
          iter518 = this.success[iter518];
          output.writeString(iter518);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_runtime_function_names_args = class {
  constructor(args) {
    this.session = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_runtime_function_names_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_runtime_function_names_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3520 = input.readListBegin();
          const _size519 = _rtmp3520.size || 0;
          for (let _i521 = 0; _i521 < _size519; ++_i521) {
            let elem522 = null;
            elem522 = input.readString();
            this.success.push(elem522);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_runtime_function_names_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter523 in this.success) {
        if (this.success.hasOwnProperty(iter523)) {
          iter523 = this.success[iter523];
          output.writeString(iter523);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_function_details_args = class {
  constructor(args) {
    this.session = null;
    this.udf_names = null;
    if (args) {
      if (args.session !== undefined && args.session !== null) {
        this.session = args.session;
      }
      if (args.udf_names !== undefined && args.udf_names !== null) {
        this.udf_names = Thrift.copyList(args.udf_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.session = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.udf_names = [];
          const _rtmp3525 = input.readListBegin();
          const _size524 = _rtmp3525.size || 0;
          for (let _i526 = 0; _i526 < _size524; ++_i526) {
            let elem527 = null;
            elem527 = input.readString();
            this.udf_names.push(elem527);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_function_details_args');
    if (this.session !== null && this.session !== undefined) {
      output.writeFieldBegin('session', Thrift.Type.STRING, 1);
      output.writeString(this.session);
      output.writeFieldEnd();
    }
    if (this.udf_names !== null && this.udf_names !== undefined) {
      output.writeFieldBegin('udf_names', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.udf_names.length);
      for (let iter528 in this.udf_names) {
        if (this.udf_names.hasOwnProperty(iter528)) {
          iter528 = this.udf_names[iter528];
          output.writeString(iter528);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const Heavy_get_function_details_result = class {
  constructor(args) {
    this.success = null;
    this.e = null;
    if (args instanceof ttypes.TDBException) {
        this.e = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [extension_functions_ttypes.TUserDefinedFunction]);
      }
      if (args.e !== undefined && args.e !== null) {
        this.e = args.e;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3530 = input.readListBegin();
          const _size529 = _rtmp3530.size || 0;
          for (let _i531 = 0; _i531 < _size529; ++_i531) {
            let elem532 = null;
            elem532 = new extension_functions_ttypes.TUserDefinedFunction();
            elem532.read(input);
            this.success.push(elem532);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.e = new ttypes.TDBException();
          this.e.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Heavy_get_function_details_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter533 in this.success) {
        if (this.success.hasOwnProperty(iter533)) {
          iter533 = this.success[iter533];
          iter533.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.e !== null && this.e !== undefined) {
      output.writeFieldBegin('e', Thrift.Type.STRUCT, 1);
      this.e.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const HeavyClient = exports.Client = class HeavyClient {
  constructor(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this._seqid = 0;
    this._reqs = {};
  }
  seqid () { return this._seqid; }
  new_seqid () { return this._seqid += 1; }

  connect (user, passwd, dbname) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_connect(user, passwd, dbname);
    });
  }

  send_connect (user, passwd, dbname) {
    const output = new this.pClass(this.output);
    const params = {
      user: user,
      passwd: passwd,
      dbname: dbname
    };
    const args = new Heavy_connect_args(params);
    try {
      output.writeMessageBegin('connect', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_connect (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_connect_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('connect failed: unknown result');
  }

  krb5_connect (inputToken, dbname) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_krb5_connect(inputToken, dbname);
    });
  }

  send_krb5_connect (inputToken, dbname) {
    const output = new this.pClass(this.output);
    const params = {
      inputToken: inputToken,
      dbname: dbname
    };
    const args = new Heavy_krb5_connect_args(params);
    try {
      output.writeMessageBegin('krb5_connect', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_krb5_connect (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_krb5_connect_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('krb5_connect failed: unknown result');
  }

  disconnect (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_disconnect(session);
    });
  }

  send_disconnect (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_disconnect_args(params);
    try {
      output.writeMessageBegin('disconnect', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_disconnect (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_disconnect_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  switch_database (session, dbname) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_switch_database(session, dbname);
    });
  }

  send_switch_database (session, dbname) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dbname: dbname
    };
    const args = new Heavy_switch_database_args(params);
    try {
      output.writeMessageBegin('switch_database', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_switch_database (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_switch_database_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  clone_session (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clone_session(session);
    });
  }

  send_clone_session (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_clone_session_args(params);
    try {
      output.writeMessageBegin('clone_session', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clone_session (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_clone_session_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('clone_session failed: unknown result');
  }

  get_server_status (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_server_status(session);
    });
  }

  send_get_server_status (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_server_status_args(params);
    try {
      output.writeMessageBegin('get_server_status', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_server_status (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_server_status_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_server_status failed: unknown result');
  }

  get_status (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_status(session);
    });
  }

  send_get_status (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_status_args(params);
    try {
      output.writeMessageBegin('get_status', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_status (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_status_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_status failed: unknown result');
  }

  get_hardware_info (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_hardware_info(session);
    });
  }

  send_get_hardware_info (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_hardware_info_args(params);
    try {
      output.writeMessageBegin('get_hardware_info', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_hardware_info (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_hardware_info_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_hardware_info failed: unknown result');
  }

  get_tables (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_tables(session);
    });
  }

  send_get_tables (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_tables_args(params);
    try {
      output.writeMessageBegin('get_tables', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_tables (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_tables_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_tables failed: unknown result');
  }

  get_tables_for_database (session, database_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_tables_for_database(session, database_name);
    });
  }

  send_get_tables_for_database (session, database_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      database_name: database_name
    };
    const args = new Heavy_get_tables_for_database_args(params);
    try {
      output.writeMessageBegin('get_tables_for_database', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_tables_for_database (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_tables_for_database_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_tables_for_database failed: unknown result');
  }

  get_physical_tables (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_physical_tables(session);
    });
  }

  send_get_physical_tables (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_physical_tables_args(params);
    try {
      output.writeMessageBegin('get_physical_tables', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_physical_tables (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_physical_tables_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_physical_tables failed: unknown result');
  }

  get_views (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_views(session);
    });
  }

  send_get_views (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_views_args(params);
    try {
      output.writeMessageBegin('get_views', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_views (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_views_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_views failed: unknown result');
  }

  get_tables_meta (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_tables_meta(session);
    });
  }

  send_get_tables_meta (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_tables_meta_args(params);
    try {
      output.writeMessageBegin('get_tables_meta', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_tables_meta (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_tables_meta_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_tables_meta failed: unknown result');
  }

  get_table_details (session, table_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_details(session, table_name);
    });
  }

  send_get_table_details (session, table_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name
    };
    const args = new Heavy_get_table_details_args(params);
    try {
      output.writeMessageBegin('get_table_details', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_details (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_details_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_details failed: unknown result');
  }

  get_table_details_for_database (session, table_name, database_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_details_for_database(session, table_name, database_name);
    });
  }

  send_get_table_details_for_database (session, table_name, database_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      database_name: database_name
    };
    const args = new Heavy_get_table_details_for_database_args(params);
    try {
      output.writeMessageBegin('get_table_details_for_database', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_details_for_database (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_details_for_database_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_details_for_database failed: unknown result');
  }

  get_internal_table_details (session, table_name, include_system_columns) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_internal_table_details(session, table_name, include_system_columns);
    });
  }

  send_get_internal_table_details (session, table_name, include_system_columns) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      include_system_columns: include_system_columns
    };
    const args = new Heavy_get_internal_table_details_args(params);
    try {
      output.writeMessageBegin('get_internal_table_details', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_internal_table_details (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_internal_table_details_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_internal_table_details failed: unknown result');
  }

  get_internal_table_details_for_database (session, table_name, database_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_internal_table_details_for_database(session, table_name, database_name);
    });
  }

  send_get_internal_table_details_for_database (session, table_name, database_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      database_name: database_name
    };
    const args = new Heavy_get_internal_table_details_for_database_args(params);
    try {
      output.writeMessageBegin('get_internal_table_details_for_database', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_internal_table_details_for_database (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_internal_table_details_for_database_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_internal_table_details_for_database failed: unknown result');
  }

  get_users (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_users(session);
    });
  }

  send_get_users (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_users_args(params);
    try {
      output.writeMessageBegin('get_users', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_users (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_users_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_users failed: unknown result');
  }

  get_databases (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_databases(session);
    });
  }

  send_get_databases (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_databases_args(params);
    try {
      output.writeMessageBegin('get_databases', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_databases (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_databases_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_databases failed: unknown result');
  }

  get_version () {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_version();
    });
  }

  send_get_version () {
    const output = new this.pClass(this.output);
    const args = new Heavy_get_version_args();
    try {
      output.writeMessageBegin('get_version', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_version (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_version_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_version failed: unknown result');
  }

  start_heap_profile (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_start_heap_profile(session);
    });
  }

  send_start_heap_profile (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_start_heap_profile_args(params);
    try {
      output.writeMessageBegin('start_heap_profile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_start_heap_profile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_start_heap_profile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  stop_heap_profile (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_stop_heap_profile(session);
    });
  }

  send_stop_heap_profile (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_stop_heap_profile_args(params);
    try {
      output.writeMessageBegin('stop_heap_profile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_stop_heap_profile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_stop_heap_profile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_heap_profile (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_heap_profile(session);
    });
  }

  send_get_heap_profile (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_heap_profile_args(params);
    try {
      output.writeMessageBegin('get_heap_profile', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_heap_profile (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_heap_profile_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_heap_profile failed: unknown result');
  }

  get_memory (session, memory_level) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_memory(session, memory_level);
    });
  }

  send_get_memory (session, memory_level) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      memory_level: memory_level
    };
    const args = new Heavy_get_memory_args(params);
    try {
      output.writeMessageBegin('get_memory', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_memory (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_memory_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_memory failed: unknown result');
  }

  clear_cpu_memory (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clear_cpu_memory(session);
    });
  }

  send_clear_cpu_memory (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_clear_cpu_memory_args(params);
    try {
      output.writeMessageBegin('clear_cpu_memory', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clear_cpu_memory (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_clear_cpu_memory_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  clear_gpu_memory (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_clear_gpu_memory(session);
    });
  }

  send_clear_gpu_memory (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_clear_gpu_memory_args(params);
    try {
      output.writeMessageBegin('clear_gpu_memory', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_clear_gpu_memory (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_clear_gpu_memory_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  set_cur_session (parent_session, leaf_session, start_time_str, label, for_running_query_kernel) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_cur_session(parent_session, leaf_session, start_time_str, label, for_running_query_kernel);
    });
  }

  send_set_cur_session (parent_session, leaf_session, start_time_str, label, for_running_query_kernel) {
    const output = new this.pClass(this.output);
    const params = {
      parent_session: parent_session,
      leaf_session: leaf_session,
      start_time_str: start_time_str,
      label: label,
      for_running_query_kernel: for_running_query_kernel
    };
    const args = new Heavy_set_cur_session_args(params);
    try {
      output.writeMessageBegin('set_cur_session', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_cur_session (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_cur_session_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  invalidate_cur_session (parent_session, leaf_session, start_time_str, label, for_running_query_kernel) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_invalidate_cur_session(parent_session, leaf_session, start_time_str, label, for_running_query_kernel);
    });
  }

  send_invalidate_cur_session (parent_session, leaf_session, start_time_str, label, for_running_query_kernel) {
    const output = new this.pClass(this.output);
    const params = {
      parent_session: parent_session,
      leaf_session: leaf_session,
      start_time_str: start_time_str,
      label: label,
      for_running_query_kernel: for_running_query_kernel
    };
    const args = new Heavy_invalidate_cur_session_args(params);
    try {
      output.writeMessageBegin('invalidate_cur_session', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_invalidate_cur_session (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_invalidate_cur_session_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  set_table_epoch (session, db_id, table_id, new_epoch) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_table_epoch(session, db_id, table_id, new_epoch);
    });
  }

  send_set_table_epoch (session, db_id, table_id, new_epoch) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      db_id: db_id,
      table_id: table_id,
      new_epoch: new_epoch
    };
    const args = new Heavy_set_table_epoch_args(params);
    try {
      output.writeMessageBegin('set_table_epoch', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_table_epoch (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_table_epoch_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  set_table_epoch_by_name (session, table_name, new_epoch) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_table_epoch_by_name(session, table_name, new_epoch);
    });
  }

  send_set_table_epoch_by_name (session, table_name, new_epoch) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      new_epoch: new_epoch
    };
    const args = new Heavy_set_table_epoch_by_name_args(params);
    try {
      output.writeMessageBegin('set_table_epoch_by_name', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_table_epoch_by_name (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_table_epoch_by_name_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_table_epoch (session, db_id, table_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_epoch(session, db_id, table_id);
    });
  }

  send_get_table_epoch (session, db_id, table_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      db_id: db_id,
      table_id: table_id
    };
    const args = new Heavy_get_table_epoch_args(params);
    try {
      output.writeMessageBegin('get_table_epoch', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_epoch (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_epoch_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_epoch failed: unknown result');
  }

  get_table_epoch_by_name (session, table_name) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_epoch_by_name(session, table_name);
    });
  }

  send_get_table_epoch_by_name (session, table_name) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name
    };
    const args = new Heavy_get_table_epoch_by_name_args(params);
    try {
      output.writeMessageBegin('get_table_epoch_by_name', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_epoch_by_name (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_epoch_by_name_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_epoch_by_name failed: unknown result');
  }

  get_table_epochs (session, db_id, table_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_epochs(session, db_id, table_id);
    });
  }

  send_get_table_epochs (session, db_id, table_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      db_id: db_id,
      table_id: table_id
    };
    const args = new Heavy_get_table_epochs_args(params);
    try {
      output.writeMessageBegin('get_table_epochs', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_epochs (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_epochs_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_epochs failed: unknown result');
  }

  set_table_epochs (session, db_id, table_epochs) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_table_epochs(session, db_id, table_epochs);
    });
  }

  send_set_table_epochs (session, db_id, table_epochs) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      db_id: db_id,
      table_epochs: table_epochs
    };
    const args = new Heavy_set_table_epochs_args(params);
    try {
      output.writeMessageBegin('set_table_epochs', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_table_epochs (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_table_epochs_result();
    result.read(input);
    input.readMessageEnd();

    callback(null);
  }

  get_session_info (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_session_info(session);
    });
  }

  send_get_session_info (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_session_info_args(params);
    try {
      output.writeMessageBegin('get_session_info', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_session_info (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_session_info_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_session_info failed: unknown result');
  }

  get_queries_info (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_queries_info(session);
    });
  }

  send_get_queries_info (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_queries_info_args(params);
    try {
      output.writeMessageBegin('get_queries_info', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_queries_info (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_queries_info_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_queries_info failed: unknown result');
  }

  set_leaf_info (session, leaf_info) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_leaf_info(session, leaf_info);
    });
  }

  send_set_leaf_info (session, leaf_info) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      leaf_info: leaf_info
    };
    const args = new Heavy_set_leaf_info_args(params);
    try {
      output.writeMessageBegin('set_leaf_info', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_leaf_info (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_leaf_info_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  sql_execute (session, query, column_format, nonce, first_n, at_most_n) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sql_execute(session, query, column_format, nonce, first_n, at_most_n);
    });
  }

  send_sql_execute (session, query, column_format, nonce, first_n, at_most_n) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query,
      column_format: column_format,
      nonce: nonce,
      first_n: first_n,
      at_most_n: at_most_n
    };
    const args = new Heavy_sql_execute_args(params);
    try {
      output.writeMessageBegin('sql_execute', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sql_execute (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_sql_execute_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sql_execute failed: unknown result');
  }

  sql_execute_df (session, query, device_type, device_id, first_n, transport_method) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sql_execute_df(session, query, device_type, device_id, first_n, transport_method);
    });
  }

  send_sql_execute_df (session, query, device_type, device_id, first_n, transport_method) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query,
      device_type: device_type,
      device_id: device_id,
      first_n: first_n,
      transport_method: transport_method
    };
    const args = new Heavy_sql_execute_df_args(params);
    try {
      output.writeMessageBegin('sql_execute_df', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sql_execute_df (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_sql_execute_df_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sql_execute_df failed: unknown result');
  }

  sql_execute_gdf (session, query, device_id, first_n) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sql_execute_gdf(session, query, device_id, first_n);
    });
  }

  send_sql_execute_gdf (session, query, device_id, first_n) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query,
      device_id: device_id,
      first_n: first_n
    };
    const args = new Heavy_sql_execute_gdf_args(params);
    try {
      output.writeMessageBegin('sql_execute_gdf', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sql_execute_gdf (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_sql_execute_gdf_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sql_execute_gdf failed: unknown result');
  }

  deallocate_df (session, df, device_type, device_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_deallocate_df(session, df, device_type, device_id);
    });
  }

  send_deallocate_df (session, df, device_type, device_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      df: df,
      device_type: device_type,
      device_id: device_id
    };
    const args = new Heavy_deallocate_df_args(params);
    try {
      output.writeMessageBegin('deallocate_df', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_deallocate_df (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_deallocate_df_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  interrupt (query_session, interrupt_session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_interrupt(query_session, interrupt_session);
    });
  }

  send_interrupt (query_session, interrupt_session) {
    const output = new this.pClass(this.output);
    const params = {
      query_session: query_session,
      interrupt_session: interrupt_session
    };
    const args = new Heavy_interrupt_args(params);
    try {
      output.writeMessageBegin('interrupt', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_interrupt (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_interrupt_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  sql_validate (session, query) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_sql_validate(session, query);
    });
  }

  send_sql_validate (session, query) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query
    };
    const args = new Heavy_sql_validate_args(params);
    try {
      output.writeMessageBegin('sql_validate', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_sql_validate (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_sql_validate_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('sql_validate failed: unknown result');
  }

  get_completion_hints (session, sql, cursor) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_completion_hints(session, sql, cursor);
    });
  }

  send_get_completion_hints (session, sql, cursor) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      sql: sql,
      cursor: cursor
    };
    const args = new Heavy_get_completion_hints_args(params);
    try {
      output.writeMessageBegin('get_completion_hints', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_completion_hints (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_completion_hints_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_completion_hints failed: unknown result');
  }

  set_execution_mode (session, mode) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_execution_mode(session, mode);
    });
  }

  send_set_execution_mode (session, mode) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      mode: mode
    };
    const args = new Heavy_set_execution_mode_args(params);
    try {
      output.writeMessageBegin('set_execution_mode', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_execution_mode (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_execution_mode_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  render_vega (session, widget_id, vega_json, compression_level, nonce) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_render_vega(session, widget_id, vega_json, compression_level, nonce);
    });
  }

  send_render_vega (session, widget_id, vega_json, compression_level, nonce) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      widget_id: widget_id,
      vega_json: vega_json,
      compression_level: compression_level,
      nonce: nonce
    };
    const args = new Heavy_render_vega_args(params);
    try {
      output.writeMessageBegin('render_vega', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_render_vega (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_render_vega_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('render_vega failed: unknown result');
  }

  get_result_row_for_pixel (session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_result_row_for_pixel(session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce);
    });
  }

  send_get_result_row_for_pixel (session, widget_id, pixel, table_col_names, column_format, pixelRadius, nonce) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      widget_id: widget_id,
      pixel: pixel,
      table_col_names: table_col_names,
      column_format: column_format,
      pixelRadius: pixelRadius,
      nonce: nonce
    };
    const args = new Heavy_get_result_row_for_pixel_args(params);
    try {
      output.writeMessageBegin('get_result_row_for_pixel', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_result_row_for_pixel (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_result_row_for_pixel_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_result_row_for_pixel failed: unknown result');
  }

  create_custom_expression (session, custom_expression) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_create_custom_expression(session, custom_expression);
    });
  }

  send_create_custom_expression (session, custom_expression) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      custom_expression: custom_expression
    };
    const args = new Heavy_create_custom_expression_args(params);
    try {
      output.writeMessageBegin('create_custom_expression', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_create_custom_expression (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_create_custom_expression_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('create_custom_expression failed: unknown result');
  }

  get_custom_expressions (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_custom_expressions(session);
    });
  }

  send_get_custom_expressions (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_custom_expressions_args(params);
    try {
      output.writeMessageBegin('get_custom_expressions', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_custom_expressions (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_custom_expressions_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_custom_expressions failed: unknown result');
  }

  update_custom_expression (session, id, expression_json) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_update_custom_expression(session, id, expression_json);
    });
  }

  send_update_custom_expression (session, id, expression_json) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      id: id,
      expression_json: expression_json
    };
    const args = new Heavy_update_custom_expression_args(params);
    try {
      output.writeMessageBegin('update_custom_expression', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_update_custom_expression (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_update_custom_expression_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  delete_custom_expressions (session, custom_expression_ids, do_soft_delete) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_delete_custom_expressions(session, custom_expression_ids, do_soft_delete);
    });
  }

  send_delete_custom_expressions (session, custom_expression_ids, do_soft_delete) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      custom_expression_ids: custom_expression_ids,
      do_soft_delete: do_soft_delete
    };
    const args = new Heavy_delete_custom_expressions_args(params);
    try {
      output.writeMessageBegin('delete_custom_expressions', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_delete_custom_expressions (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_delete_custom_expressions_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_dashboard (session, dashboard_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_dashboard(session, dashboard_id);
    });
  }

  send_get_dashboard (session, dashboard_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id
    };
    const args = new Heavy_get_dashboard_args(params);
    try {
      output.writeMessageBegin('get_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_dashboard failed: unknown result');
  }

  get_dashboards (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_dashboards(session);
    });
  }

  send_get_dashboards (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_dashboards_args(params);
    try {
      output.writeMessageBegin('get_dashboards', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_dashboards (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_dashboards_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_dashboards failed: unknown result');
  }

  create_dashboard (session, dashboard_name, dashboard_state, image_hash, dashboard_metadata) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_create_dashboard(session, dashboard_name, dashboard_state, image_hash, dashboard_metadata);
    });
  }

  send_create_dashboard (session, dashboard_name, dashboard_state, image_hash, dashboard_metadata) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_name: dashboard_name,
      dashboard_state: dashboard_state,
      image_hash: image_hash,
      dashboard_metadata: dashboard_metadata
    };
    const args = new Heavy_create_dashboard_args(params);
    try {
      output.writeMessageBegin('create_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_create_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_create_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('create_dashboard failed: unknown result');
  }

  replace_dashboard (session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_replace_dashboard(session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata);
    });
  }

  send_replace_dashboard (session, dashboard_id, dashboard_name, dashboard_owner, dashboard_state, image_hash, dashboard_metadata) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id,
      dashboard_name: dashboard_name,
      dashboard_owner: dashboard_owner,
      dashboard_state: dashboard_state,
      image_hash: image_hash,
      dashboard_metadata: dashboard_metadata
    };
    const args = new Heavy_replace_dashboard_args(params);
    try {
      output.writeMessageBegin('replace_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_replace_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_replace_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  delete_dashboard (session, dashboard_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_delete_dashboard(session, dashboard_id);
    });
  }

  send_delete_dashboard (session, dashboard_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id
    };
    const args = new Heavy_delete_dashboard_args(params);
    try {
      output.writeMessageBegin('delete_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_delete_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_delete_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  share_dashboards (session, dashboard_ids, groups, permissions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_share_dashboards(session, dashboard_ids, groups, permissions);
    });
  }

  send_share_dashboards (session, dashboard_ids, groups, permissions) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_ids: dashboard_ids,
      groups: groups,
      permissions: permissions
    };
    const args = new Heavy_share_dashboards_args(params);
    try {
      output.writeMessageBegin('share_dashboards', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_share_dashboards (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_share_dashboards_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  delete_dashboards (session, dashboard_ids) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_delete_dashboards(session, dashboard_ids);
    });
  }

  send_delete_dashboards (session, dashboard_ids) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_ids: dashboard_ids
    };
    const args = new Heavy_delete_dashboards_args(params);
    try {
      output.writeMessageBegin('delete_dashboards', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_delete_dashboards (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_delete_dashboards_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  share_dashboard (session, dashboard_id, groups, objects, permissions, grant_role) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_share_dashboard(session, dashboard_id, groups, objects, permissions, grant_role);
    });
  }

  send_share_dashboard (session, dashboard_id, groups, objects, permissions, grant_role) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id,
      groups: groups,
      objects: objects,
      permissions: permissions,
      grant_role: grant_role
    };
    const args = new Heavy_share_dashboard_args(params);
    try {
      output.writeMessageBegin('share_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_share_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_share_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  unshare_dashboard (session, dashboard_id, groups, objects, permissions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_unshare_dashboard(session, dashboard_id, groups, objects, permissions);
    });
  }

  send_unshare_dashboard (session, dashboard_id, groups, objects, permissions) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id,
      groups: groups,
      objects: objects,
      permissions: permissions
    };
    const args = new Heavy_unshare_dashboard_args(params);
    try {
      output.writeMessageBegin('unshare_dashboard', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_unshare_dashboard (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_unshare_dashboard_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  unshare_dashboards (session, dashboard_ids, groups, permissions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_unshare_dashboards(session, dashboard_ids, groups, permissions);
    });
  }

  send_unshare_dashboards (session, dashboard_ids, groups, permissions) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_ids: dashboard_ids,
      groups: groups,
      permissions: permissions
    };
    const args = new Heavy_unshare_dashboards_args(params);
    try {
      output.writeMessageBegin('unshare_dashboards', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_unshare_dashboards (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_unshare_dashboards_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_dashboard_grantees (session, dashboard_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_dashboard_grantees(session, dashboard_id);
    });
  }

  send_get_dashboard_grantees (session, dashboard_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      dashboard_id: dashboard_id
    };
    const args = new Heavy_get_dashboard_grantees_args(params);
    try {
      output.writeMessageBegin('get_dashboard_grantees', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_dashboard_grantees (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_dashboard_grantees_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_dashboard_grantees failed: unknown result');
  }

  get_link_view (session, link) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_link_view(session, link);
    });
  }

  send_get_link_view (session, link) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      link: link
    };
    const args = new Heavy_get_link_view_args(params);
    try {
      output.writeMessageBegin('get_link_view', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_link_view (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_link_view_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_link_view failed: unknown result');
  }

  create_link (session, view_state, view_metadata) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_create_link(session, view_state, view_metadata);
    });
  }

  send_create_link (session, view_state, view_metadata) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      view_state: view_state,
      view_metadata: view_metadata
    };
    const args = new Heavy_create_link_args(params);
    try {
      output.writeMessageBegin('create_link', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_create_link (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_create_link_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('create_link failed: unknown result');
  }

  load_table_binary (session, table_name, rows, column_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table_binary(session, table_name, rows, column_names);
    });
  }

  send_load_table_binary (session, table_name, rows, column_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      rows: rows,
      column_names: column_names
    };
    const args = new Heavy_load_table_binary_args(params);
    try {
      output.writeMessageBegin('load_table_binary', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table_binary (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_binary_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  load_table_binary_columnar (session, table_name, cols, column_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table_binary_columnar(session, table_name, cols, column_names);
    });
  }

  send_load_table_binary_columnar (session, table_name, cols, column_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      cols: cols,
      column_names: column_names
    };
    const args = new Heavy_load_table_binary_columnar_args(params);
    try {
      output.writeMessageBegin('load_table_binary_columnar', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table_binary_columnar (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_binary_columnar_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  load_table_binary_arrow (session, table_name, arrow_stream, use_column_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table_binary_arrow(session, table_name, arrow_stream, use_column_names);
    });
  }

  send_load_table_binary_arrow (session, table_name, arrow_stream, use_column_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      arrow_stream: arrow_stream,
      use_column_names: use_column_names
    };
    const args = new Heavy_load_table_binary_arrow_args(params);
    try {
      output.writeMessageBegin('load_table_binary_arrow', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table_binary_arrow (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_binary_arrow_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  load_table (session, table_name, rows, column_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_load_table(session, table_name, rows, column_names);
    });
  }

  send_load_table (session, table_name, rows, column_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      rows: rows,
      column_names: column_names
    };
    const args = new Heavy_load_table_args(params);
    try {
      output.writeMessageBegin('load_table', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_load_table (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_load_table_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  detect_column_types (session, file_name, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_detect_column_types(session, file_name, copy_params);
    });
  }

  send_detect_column_types (session, file_name, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      file_name: file_name,
      copy_params: copy_params
    };
    const args = new Heavy_detect_column_types_args(params);
    try {
      output.writeMessageBegin('detect_column_types', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_detect_column_types (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_detect_column_types_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('detect_column_types failed: unknown result');
  }

  create_table (session, table_name, row_desc, create_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_create_table(session, table_name, row_desc, create_params);
    });
  }

  send_create_table (session, table_name, row_desc, create_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      row_desc: row_desc,
      create_params: create_params
    };
    const args = new Heavy_create_table_args(params);
    try {
      output.writeMessageBegin('create_table', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_create_table (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_create_table_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  import_table (session, table_name, file_name, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_import_table(session, table_name, file_name, copy_params);
    });
  }

  send_import_table (session, table_name, file_name, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      file_name: file_name,
      copy_params: copy_params
    };
    const args = new Heavy_import_table_args(params);
    try {
      output.writeMessageBegin('import_table', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_import_table (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_import_table_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  import_geo_table (session, table_name, file_name, copy_params, row_desc, create_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_import_geo_table(session, table_name, file_name, copy_params, row_desc, create_params);
    });
  }

  send_import_geo_table (session, table_name, file_name, copy_params, row_desc, create_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_name: table_name,
      file_name: file_name,
      copy_params: copy_params,
      row_desc: row_desc,
      create_params: create_params
    };
    const args = new Heavy_import_geo_table_args(params);
    try {
      output.writeMessageBegin('import_geo_table', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_import_geo_table (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_import_geo_table_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  import_table_status (session, import_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_import_table_status(session, import_id);
    });
  }

  send_import_table_status (session, import_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      import_id: import_id
    };
    const args = new Heavy_import_table_status_args(params);
    try {
      output.writeMessageBegin('import_table_status', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_import_table_status (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_import_table_status_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('import_table_status failed: unknown result');
  }

  get_first_geo_file_in_archive (session, archive_path, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_first_geo_file_in_archive(session, archive_path, copy_params);
    });
  }

  send_get_first_geo_file_in_archive (session, archive_path, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      archive_path: archive_path,
      copy_params: copy_params
    };
    const args = new Heavy_get_first_geo_file_in_archive_args(params);
    try {
      output.writeMessageBegin('get_first_geo_file_in_archive', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_first_geo_file_in_archive (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_first_geo_file_in_archive_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_first_geo_file_in_archive failed: unknown result');
  }

  get_all_files_in_archive (session, archive_path, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_all_files_in_archive(session, archive_path, copy_params);
    });
  }

  send_get_all_files_in_archive (session, archive_path, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      archive_path: archive_path,
      copy_params: copy_params
    };
    const args = new Heavy_get_all_files_in_archive_args(params);
    try {
      output.writeMessageBegin('get_all_files_in_archive', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_all_files_in_archive (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_all_files_in_archive_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_all_files_in_archive failed: unknown result');
  }

  get_layers_in_geo_file (session, file_name, copy_params) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_layers_in_geo_file(session, file_name, copy_params);
    });
  }

  send_get_layers_in_geo_file (session, file_name, copy_params) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      file_name: file_name,
      copy_params: copy_params
    };
    const args = new Heavy_get_layers_in_geo_file_args(params);
    try {
      output.writeMessageBegin('get_layers_in_geo_file', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_layers_in_geo_file (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_layers_in_geo_file_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_layers_in_geo_file failed: unknown result');
  }

  query_get_outer_fragment_count (session, query) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_query_get_outer_fragment_count(session, query);
    });
  }

  send_query_get_outer_fragment_count (session, query) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      query: query
    };
    const args = new Heavy_query_get_outer_fragment_count_args(params);
    try {
      output.writeMessageBegin('query_get_outer_fragment_count', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_query_get_outer_fragment_count (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_query_get_outer_fragment_count_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('query_get_outer_fragment_count failed: unknown result');
  }

  check_table_consistency (session, table_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_check_table_consistency(session, table_id);
    });
  }

  send_check_table_consistency (session, table_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_id: table_id
    };
    const args = new Heavy_check_table_consistency_args(params);
    try {
      output.writeMessageBegin('check_table_consistency', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_check_table_consistency (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_check_table_consistency_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('check_table_consistency failed: unknown result');
  }

  start_query (leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_start_query(leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices);
    });
  }

  send_start_query (leaf_session, parent_session, query_ra, start_time_str, just_explain, outer_fragment_indices) {
    const output = new this.pClass(this.output);
    const params = {
      leaf_session: leaf_session,
      parent_session: parent_session,
      query_ra: query_ra,
      start_time_str: start_time_str,
      just_explain: just_explain,
      outer_fragment_indices: outer_fragment_indices
    };
    const args = new Heavy_start_query_args(params);
    try {
      output.writeMessageBegin('start_query', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_start_query (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_start_query_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('start_query failed: unknown result');
  }

  execute_query_step (pending_query, subquery_id, start_time_str) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_execute_query_step(pending_query, subquery_id, start_time_str);
    });
  }

  send_execute_query_step (pending_query, subquery_id, start_time_str) {
    const output = new this.pClass(this.output);
    const params = {
      pending_query: pending_query,
      subquery_id: subquery_id,
      start_time_str: start_time_str
    };
    const args = new Heavy_execute_query_step_args(params);
    try {
      output.writeMessageBegin('execute_query_step', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_execute_query_step (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_execute_query_step_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('execute_query_step failed: unknown result');
  }

  broadcast_serialized_rows (serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_broadcast_serialized_rows(serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result);
    });
  }

  send_broadcast_serialized_rows (serialized_rows, row_desc, query_id, subquery_id, is_final_subquery_result) {
    const output = new this.pClass(this.output);
    const params = {
      serialized_rows: serialized_rows,
      row_desc: row_desc,
      query_id: query_id,
      subquery_id: subquery_id,
      is_final_subquery_result: is_final_subquery_result
    };
    const args = new Heavy_broadcast_serialized_rows_args(params);
    try {
      output.writeMessageBegin('broadcast_serialized_rows', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_broadcast_serialized_rows (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_broadcast_serialized_rows_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  start_render_query (session, widget_id, node_idx, vega_json) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_start_render_query(session, widget_id, node_idx, vega_json);
    });
  }

  send_start_render_query (session, widget_id, node_idx, vega_json) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      widget_id: widget_id,
      node_idx: node_idx,
      vega_json: vega_json
    };
    const args = new Heavy_start_render_query_args(params);
    try {
      output.writeMessageBegin('start_render_query', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_start_render_query (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_start_render_query_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('start_render_query failed: unknown result');
  }

  execute_next_render_step (pending_render, merged_data) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_execute_next_render_step(pending_render, merged_data);
    });
  }

  send_execute_next_render_step (pending_render, merged_data) {
    const output = new this.pClass(this.output);
    const params = {
      pending_render: pending_render,
      merged_data: merged_data
    };
    const args = new Heavy_execute_next_render_step_args(params);
    try {
      output.writeMessageBegin('execute_next_render_step', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_execute_next_render_step (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_execute_next_render_step_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('execute_next_render_step failed: unknown result');
  }

  insert_data (session, insert_data) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_insert_data(session, insert_data);
    });
  }

  send_insert_data (session, insert_data) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      insert_data: insert_data
    };
    const args = new Heavy_insert_data_args(params);
    try {
      output.writeMessageBegin('insert_data', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_insert_data (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_insert_data_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  insert_chunks (session, insert_chunks) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_insert_chunks(session, insert_chunks);
    });
  }

  send_insert_chunks (session, insert_chunks) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      insert_chunks: insert_chunks
    };
    const args = new Heavy_insert_chunks_args(params);
    try {
      output.writeMessageBegin('insert_chunks', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_insert_chunks (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_insert_chunks_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  checkpoint (session, table_id) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_checkpoint(session, table_id);
    });
  }

  send_checkpoint (session, table_id) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      table_id: table_id
    };
    const args = new Heavy_checkpoint_args(params);
    try {
      output.writeMessageBegin('checkpoint', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_checkpoint (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_checkpoint_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_roles (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_roles(session);
    });
  }

  send_get_roles (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_roles_args(params);
    try {
      output.writeMessageBegin('get_roles', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_roles (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_roles_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_roles failed: unknown result');
  }

  get_db_objects_for_grantee (session, roleName) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_db_objects_for_grantee(session, roleName);
    });
  }

  send_get_db_objects_for_grantee (session, roleName) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      roleName: roleName
    };
    const args = new Heavy_get_db_objects_for_grantee_args(params);
    try {
      output.writeMessageBegin('get_db_objects_for_grantee', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_db_objects_for_grantee (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_db_objects_for_grantee_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_db_objects_for_grantee failed: unknown result');
  }

  get_db_object_privs (session, objectName, type) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_db_object_privs(session, objectName, type);
    });
  }

  send_get_db_object_privs (session, objectName, type) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      objectName: objectName,
      type: type
    };
    const args = new Heavy_get_db_object_privs_args(params);
    try {
      output.writeMessageBegin('get_db_object_privs', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_db_object_privs (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_db_object_privs_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_db_object_privs failed: unknown result');
  }

  get_all_roles_for_user (session, userName) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_all_roles_for_user(session, userName);
    });
  }

  send_get_all_roles_for_user (session, userName) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      userName: userName
    };
    const args = new Heavy_get_all_roles_for_user_args(params);
    try {
      output.writeMessageBegin('get_all_roles_for_user', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_all_roles_for_user (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_all_roles_for_user_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_all_roles_for_user failed: unknown result');
  }

  get_all_effective_roles_for_user (session, userName) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_all_effective_roles_for_user(session, userName);
    });
  }

  send_get_all_effective_roles_for_user (session, userName) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      userName: userName
    };
    const args = new Heavy_get_all_effective_roles_for_user_args(params);
    try {
      output.writeMessageBegin('get_all_effective_roles_for_user', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_all_effective_roles_for_user (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_all_effective_roles_for_user_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_all_effective_roles_for_user failed: unknown result');
  }

  has_role (session, granteeName, roleName) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_has_role(session, granteeName, roleName);
    });
  }

  send_has_role (session, granteeName, roleName) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      granteeName: granteeName,
      roleName: roleName
    };
    const args = new Heavy_has_role_args(params);
    try {
      output.writeMessageBegin('has_role', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_has_role (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_has_role_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('has_role failed: unknown result');
  }

  has_object_privilege (session, granteeName, ObjectName, objectType, permissions) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_has_object_privilege(session, granteeName, ObjectName, objectType, permissions);
    });
  }

  send_has_object_privilege (session, granteeName, ObjectName, objectType, permissions) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      granteeName: granteeName,
      ObjectName: ObjectName,
      objectType: objectType,
      permissions: permissions
    };
    const args = new Heavy_has_object_privilege_args(params);
    try {
      output.writeMessageBegin('has_object_privilege', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_has_object_privilege (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_has_object_privilege_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('has_object_privilege failed: unknown result');
  }

  set_license_key (session, key, nonce) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_set_license_key(session, key, nonce);
    });
  }

  send_set_license_key (session, key, nonce) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      key: key,
      nonce: nonce
    };
    const args = new Heavy_set_license_key_args(params);
    try {
      output.writeMessageBegin('set_license_key', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_set_license_key (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_set_license_key_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('set_license_key failed: unknown result');
  }

  get_license_claims (session, nonce) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_license_claims(session, nonce);
    });
  }

  send_get_license_claims (session, nonce) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      nonce: nonce
    };
    const args = new Heavy_get_license_claims_args(params);
    try {
      output.writeMessageBegin('get_license_claims', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_license_claims (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_license_claims_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_license_claims failed: unknown result');
  }

  get_device_parameters (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_device_parameters(session);
    });
  }

  send_get_device_parameters (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_device_parameters_args(params);
    try {
      output.writeMessageBegin('get_device_parameters', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_device_parameters (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_device_parameters_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_device_parameters failed: unknown result');
  }

  register_runtime_extension_functions (session, udfs, udtfs, device_ir_map) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_register_runtime_extension_functions(session, udfs, udtfs, device_ir_map);
    });
  }

  send_register_runtime_extension_functions (session, udfs, udtfs, device_ir_map) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      udfs: udfs,
      udtfs: udtfs,
      device_ir_map: device_ir_map
    };
    const args = new Heavy_register_runtime_extension_functions_args(params);
    try {
      output.writeMessageBegin('register_runtime_extension_functions', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_register_runtime_extension_functions (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_register_runtime_extension_functions_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    callback(null);
  }

  get_table_function_names (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_function_names(session);
    });
  }

  send_get_table_function_names (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_table_function_names_args(params);
    try {
      output.writeMessageBegin('get_table_function_names', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_function_names (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_function_names_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_function_names failed: unknown result');
  }

  get_runtime_table_function_names (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_runtime_table_function_names(session);
    });
  }

  send_get_runtime_table_function_names (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_runtime_table_function_names_args(params);
    try {
      output.writeMessageBegin('get_runtime_table_function_names', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_runtime_table_function_names (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_runtime_table_function_names_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_runtime_table_function_names failed: unknown result');
  }

  get_table_function_details (session, udtf_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_table_function_details(session, udtf_names);
    });
  }

  send_get_table_function_details (session, udtf_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      udtf_names: udtf_names
    };
    const args = new Heavy_get_table_function_details_args(params);
    try {
      output.writeMessageBegin('get_table_function_details', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_table_function_details (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_table_function_details_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_table_function_details failed: unknown result');
  }

  get_function_names (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_function_names(session);
    });
  }

  send_get_function_names (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_function_names_args(params);
    try {
      output.writeMessageBegin('get_function_names', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_function_names (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_function_names_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_function_names failed: unknown result');
  }

  get_runtime_function_names (session) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_runtime_function_names(session);
    });
  }

  send_get_runtime_function_names (session) {
    const output = new this.pClass(this.output);
    const params = {
      session: session
    };
    const args = new Heavy_get_runtime_function_names_args(params);
    try {
      output.writeMessageBegin('get_runtime_function_names', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_runtime_function_names (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_runtime_function_names_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_runtime_function_names failed: unknown result');
  }

  get_function_details (session, udf_names) {
    this._seqid = this.new_seqid();
    const self = this;
    return new Promise((resolve, reject) => {
      self._reqs[self.seqid()] = (error, result) => {
        return error ? reject(error) : resolve(result);
      };
      self.send_get_function_details(session, udf_names);
    });
  }

  send_get_function_details (session, udf_names) {
    const output = new this.pClass(this.output);
    const params = {
      session: session,
      udf_names: udf_names
    };
    const args = new Heavy_get_function_details_args(params);
    try {
      output.writeMessageBegin('get_function_details', Thrift.MessageType.CALL, this.seqid());
      args.write(output);
      output.writeMessageEnd();
      return this.output.flush();
    }
    catch (e) {
      delete this._reqs[this.seqid()];
      if (typeof output.reset === 'function') {
        output.reset();
      }
      throw e;
    }
  }

  recv_get_function_details (input, mtype, rseqid) {
    const callback = this._reqs[rseqid] || function() {};
    delete this._reqs[rseqid];
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(input);
      input.readMessageEnd();
      return callback(x);
    }
    const result = new Heavy_get_function_details_result();
    result.read(input);
    input.readMessageEnd();

    if (null !== result.e) {
      return callback(result.e);
    }
    if (null !== result.success) {
      return callback(null, result.success);
    }
    return callback('get_function_details failed: unknown result');
  }
};
const HeavyProcessor = exports.Processor = class HeavyProcessor {
  constructor(handler) {
    this._handler = handler;
  }
  process (input, output) {
    const r = input.readMessageBegin();
    if (this['process_' + r.fname]) {
      return this['process_' + r.fname].call(this, r.rseqid, input, output);
    } else {
      input.skip(Thrift.Type.STRUCT);
      input.readMessageEnd();
      const x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname);
      output.writeMessageBegin(r.fname, Thrift.MessageType.EXCEPTION, r.rseqid);
      x.write(output);
      output.writeMessageEnd();
      output.flush();
    }
  }
  process_connect (seqid, input, output) {
    const args = new Heavy_connect_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.connect.length === 3) {
      Promise.resolve(this._handler.connect.bind(this._handler)(
        args.user,
        args.passwd,
        args.dbname
      )).then(result => {
        const result_obj = new Heavy_connect_result({success: result});
        output.writeMessageBegin("connect", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_connect_result(err);
          output.writeMessageBegin("connect", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("connect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.connect(args.user, args.passwd, args.dbname, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_connect_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("connect", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("connect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_krb5_connect (seqid, input, output) {
    const args = new Heavy_krb5_connect_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.krb5_connect.length === 2) {
      Promise.resolve(this._handler.krb5_connect.bind(this._handler)(
        args.inputToken,
        args.dbname
      )).then(result => {
        const result_obj = new Heavy_krb5_connect_result({success: result});
        output.writeMessageBegin("krb5_connect", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_krb5_connect_result(err);
          output.writeMessageBegin("krb5_connect", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("krb5_connect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.krb5_connect(args.inputToken, args.dbname, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_krb5_connect_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("krb5_connect", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("krb5_connect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_disconnect (seqid, input, output) {
    const args = new Heavy_disconnect_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.disconnect.length === 1) {
      Promise.resolve(this._handler.disconnect.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_disconnect_result({success: result});
        output.writeMessageBegin("disconnect", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_disconnect_result(err);
          output.writeMessageBegin("disconnect", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("disconnect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.disconnect(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_disconnect_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("disconnect", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("disconnect", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_switch_database (seqid, input, output) {
    const args = new Heavy_switch_database_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.switch_database.length === 2) {
      Promise.resolve(this._handler.switch_database.bind(this._handler)(
        args.session,
        args.dbname
      )).then(result => {
        const result_obj = new Heavy_switch_database_result({success: result});
        output.writeMessageBegin("switch_database", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_switch_database_result(err);
          output.writeMessageBegin("switch_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("switch_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.switch_database(args.session, args.dbname, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_switch_database_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("switch_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("switch_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clone_session (seqid, input, output) {
    const args = new Heavy_clone_session_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clone_session.length === 1) {
      Promise.resolve(this._handler.clone_session.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_clone_session_result({success: result});
        output.writeMessageBegin("clone_session", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_clone_session_result(err);
          output.writeMessageBegin("clone_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clone_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clone_session(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_clone_session_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clone_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clone_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_server_status (seqid, input, output) {
    const args = new Heavy_get_server_status_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_server_status.length === 1) {
      Promise.resolve(this._handler.get_server_status.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_server_status_result({success: result});
        output.writeMessageBegin("get_server_status", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_server_status_result(err);
          output.writeMessageBegin("get_server_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_server_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_server_status(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_server_status_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_server_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_server_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_status (seqid, input, output) {
    const args = new Heavy_get_status_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_status.length === 1) {
      Promise.resolve(this._handler.get_status.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_status_result({success: result});
        output.writeMessageBegin("get_status", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_status_result(err);
          output.writeMessageBegin("get_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_status(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_status_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_hardware_info (seqid, input, output) {
    const args = new Heavy_get_hardware_info_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_hardware_info.length === 1) {
      Promise.resolve(this._handler.get_hardware_info.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_hardware_info_result({success: result});
        output.writeMessageBegin("get_hardware_info", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_hardware_info_result(err);
          output.writeMessageBegin("get_hardware_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_hardware_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_hardware_info(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_hardware_info_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_hardware_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_hardware_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_tables (seqid, input, output) {
    const args = new Heavy_get_tables_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_tables.length === 1) {
      Promise.resolve(this._handler.get_tables.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_tables_result({success: result});
        output.writeMessageBegin("get_tables", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_tables_result(err);
          output.writeMessageBegin("get_tables", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_tables(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_tables_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_tables", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_tables_for_database (seqid, input, output) {
    const args = new Heavy_get_tables_for_database_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_tables_for_database.length === 2) {
      Promise.resolve(this._handler.get_tables_for_database.bind(this._handler)(
        args.session,
        args.database_name
      )).then(result => {
        const result_obj = new Heavy_get_tables_for_database_result({success: result});
        output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_tables_for_database_result(err);
          output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_tables_for_database(args.session, args.database_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_tables_for_database_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_physical_tables (seqid, input, output) {
    const args = new Heavy_get_physical_tables_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_physical_tables.length === 1) {
      Promise.resolve(this._handler.get_physical_tables.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_physical_tables_result({success: result});
        output.writeMessageBegin("get_physical_tables", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_physical_tables_result(err);
          output.writeMessageBegin("get_physical_tables", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_physical_tables", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_physical_tables(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_physical_tables_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_physical_tables", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_physical_tables", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_views (seqid, input, output) {
    const args = new Heavy_get_views_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_views.length === 1) {
      Promise.resolve(this._handler.get_views.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_views_result({success: result});
        output.writeMessageBegin("get_views", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_views_result(err);
          output.writeMessageBegin("get_views", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_views", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_views(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_views_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_views", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_views", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_tables_meta (seqid, input, output) {
    const args = new Heavy_get_tables_meta_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_tables_meta.length === 1) {
      Promise.resolve(this._handler.get_tables_meta.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_tables_meta_result({success: result});
        output.writeMessageBegin("get_tables_meta", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_tables_meta_result(err);
          output.writeMessageBegin("get_tables_meta", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables_meta", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_tables_meta(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_tables_meta_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_tables_meta", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_tables_meta", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_details (seqid, input, output) {
    const args = new Heavy_get_table_details_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_details.length === 2) {
      Promise.resolve(this._handler.get_table_details.bind(this._handler)(
        args.session,
        args.table_name
      )).then(result => {
        const result_obj = new Heavy_get_table_details_result({success: result});
        output.writeMessageBegin("get_table_details", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_table_details_result(err);
          output.writeMessageBegin("get_table_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_details(args.session, args.table_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_table_details_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_details_for_database (seqid, input, output) {
    const args = new Heavy_get_table_details_for_database_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_details_for_database.length === 3) {
      Promise.resolve(this._handler.get_table_details_for_database.bind(this._handler)(
        args.session,
        args.table_name,
        args.database_name
      )).then(result => {
        const result_obj = new Heavy_get_table_details_for_database_result({success: result});
        output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_table_details_for_database_result(err);
          output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_details_for_database(args.session, args.table_name, args.database_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_table_details_for_database_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_details_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_internal_table_details (seqid, input, output) {
    const args = new Heavy_get_internal_table_details_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_internal_table_details.length === 3) {
      Promise.resolve(this._handler.get_internal_table_details.bind(this._handler)(
        args.session,
        args.table_name,
        args.include_system_columns
      )).then(result => {
        const result_obj = new Heavy_get_internal_table_details_result({success: result});
        output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_internal_table_details_result(err);
          output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_internal_table_details(args.session, args.table_name, args.include_system_columns, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_internal_table_details_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_internal_table_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_internal_table_details_for_database (seqid, input, output) {
    const args = new Heavy_get_internal_table_details_for_database_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_internal_table_details_for_database.length === 3) {
      Promise.resolve(this._handler.get_internal_table_details_for_database.bind(this._handler)(
        args.session,
        args.table_name,
        args.database_name
      )).then(result => {
        const result_obj = new Heavy_get_internal_table_details_for_database_result({success: result});
        output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_internal_table_details_for_database_result(err);
          output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_internal_table_details_for_database(args.session, args.table_name, args.database_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_internal_table_details_for_database_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_internal_table_details_for_database", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_users (seqid, input, output) {
    const args = new Heavy_get_users_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_users.length === 1) {
      Promise.resolve(this._handler.get_users.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_users_result({success: result});
        output.writeMessageBegin("get_users", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_users_result(err);
          output.writeMessageBegin("get_users", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_users", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_users(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_users_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_users", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_users", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_databases (seqid, input, output) {
    const args = new Heavy_get_databases_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_databases.length === 1) {
      Promise.resolve(this._handler.get_databases.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_databases_result({success: result});
        output.writeMessageBegin("get_databases", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_databases_result(err);
          output.writeMessageBegin("get_databases", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_databases", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_databases(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_databases_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_databases", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_databases", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_version (seqid, input, output) {
    const args = new Heavy_get_version_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_version.length === 0) {
      Promise.resolve(this._handler.get_version.bind(this._handler)(
      )).then(result => {
        const result_obj = new Heavy_get_version_result({success: result});
        output.writeMessageBegin("get_version", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_version_result(err);
          output.writeMessageBegin("get_version", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_version", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_version((err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_version_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_version", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_version", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_start_heap_profile (seqid, input, output) {
    const args = new Heavy_start_heap_profile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.start_heap_profile.length === 1) {
      Promise.resolve(this._handler.start_heap_profile.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_start_heap_profile_result({success: result});
        output.writeMessageBegin("start_heap_profile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_start_heap_profile_result(err);
          output.writeMessageBegin("start_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.start_heap_profile(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_start_heap_profile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("start_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_stop_heap_profile (seqid, input, output) {
    const args = new Heavy_stop_heap_profile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.stop_heap_profile.length === 1) {
      Promise.resolve(this._handler.stop_heap_profile.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_stop_heap_profile_result({success: result});
        output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_stop_heap_profile_result(err);
          output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.stop_heap_profile(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_stop_heap_profile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("stop_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_heap_profile (seqid, input, output) {
    const args = new Heavy_get_heap_profile_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_heap_profile.length === 1) {
      Promise.resolve(this._handler.get_heap_profile.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_heap_profile_result({success: result});
        output.writeMessageBegin("get_heap_profile", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_heap_profile_result(err);
          output.writeMessageBegin("get_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_heap_profile(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_heap_profile_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_heap_profile", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_heap_profile", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_memory (seqid, input, output) {
    const args = new Heavy_get_memory_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_memory.length === 2) {
      Promise.resolve(this._handler.get_memory.bind(this._handler)(
        args.session,
        args.memory_level
      )).then(result => {
        const result_obj = new Heavy_get_memory_result({success: result});
        output.writeMessageBegin("get_memory", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_memory_result(err);
          output.writeMessageBegin("get_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_memory(args.session, args.memory_level, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_memory_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clear_cpu_memory (seqid, input, output) {
    const args = new Heavy_clear_cpu_memory_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clear_cpu_memory.length === 1) {
      Promise.resolve(this._handler.clear_cpu_memory.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_clear_cpu_memory_result({success: result});
        output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_clear_cpu_memory_result(err);
          output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clear_cpu_memory(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_clear_cpu_memory_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clear_cpu_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_clear_gpu_memory (seqid, input, output) {
    const args = new Heavy_clear_gpu_memory_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.clear_gpu_memory.length === 1) {
      Promise.resolve(this._handler.clear_gpu_memory.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_clear_gpu_memory_result({success: result});
        output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_clear_gpu_memory_result(err);
          output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.clear_gpu_memory(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_clear_gpu_memory_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("clear_gpu_memory", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_cur_session (seqid, input, output) {
    const args = new Heavy_set_cur_session_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_cur_session.length === 5) {
      Promise.resolve(this._handler.set_cur_session.bind(this._handler)(
        args.parent_session,
        args.leaf_session,
        args.start_time_str,
        args.label,
        args.for_running_query_kernel
      )).then(result => {
        const result_obj = new Heavy_set_cur_session_result({success: result});
        output.writeMessageBegin("set_cur_session", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_cur_session_result(err);
          output.writeMessageBegin("set_cur_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_cur_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_cur_session(args.parent_session, args.leaf_session, args.start_time_str, args.label, args.for_running_query_kernel, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_cur_session_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_cur_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_cur_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_invalidate_cur_session (seqid, input, output) {
    const args = new Heavy_invalidate_cur_session_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.invalidate_cur_session.length === 5) {
      Promise.resolve(this._handler.invalidate_cur_session.bind(this._handler)(
        args.parent_session,
        args.leaf_session,
        args.start_time_str,
        args.label,
        args.for_running_query_kernel
      )).then(result => {
        const result_obj = new Heavy_invalidate_cur_session_result({success: result});
        output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_invalidate_cur_session_result(err);
          output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.invalidate_cur_session(args.parent_session, args.leaf_session, args.start_time_str, args.label, args.for_running_query_kernel, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_invalidate_cur_session_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("invalidate_cur_session", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_table_epoch (seqid, input, output) {
    const args = new Heavy_set_table_epoch_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_table_epoch.length === 4) {
      Promise.resolve(this._handler.set_table_epoch.bind(this._handler)(
        args.session,
        args.db_id,
        args.table_id,
        args.new_epoch
      )).then(result => {
        const result_obj = new Heavy_set_table_epoch_result({success: result});
        output.writeMessageBegin("set_table_epoch", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_table_epoch_result(err);
          output.writeMessageBegin("set_table_epoch", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epoch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_table_epoch(args.session, args.db_id, args.table_id, args.new_epoch, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_table_epoch_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_table_epoch", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epoch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_table_epoch_by_name (seqid, input, output) {
    const args = new Heavy_set_table_epoch_by_name_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_table_epoch_by_name.length === 3) {
      Promise.resolve(this._handler.set_table_epoch_by_name.bind(this._handler)(
        args.session,
        args.table_name,
        args.new_epoch
      )).then(result => {
        const result_obj = new Heavy_set_table_epoch_by_name_result({success: result});
        output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_table_epoch_by_name_result(err);
          output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_table_epoch_by_name(args.session, args.table_name, args.new_epoch, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_table_epoch_by_name_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epoch_by_name", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_epoch (seqid, input, output) {
    const args = new Heavy_get_table_epoch_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_epoch.length === 3) {
      Promise.resolve(this._handler.get_table_epoch.bind(this._handler)(
        args.session,
        args.db_id,
        args.table_id
      )).then(result => {
        const result_obj = new Heavy_get_table_epoch_result({success: result});
        output.writeMessageBegin("get_table_epoch", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("get_table_epoch", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_epoch(args.session, args.db_id, args.table_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new Heavy_get_table_epoch_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_epoch", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_epoch", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_epoch_by_name (seqid, input, output) {
    const args = new Heavy_get_table_epoch_by_name_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_epoch_by_name.length === 2) {
      Promise.resolve(this._handler.get_table_epoch_by_name.bind(this._handler)(
        args.session,
        args.table_name
      )).then(result => {
        const result_obj = new Heavy_get_table_epoch_by_name_result({success: result});
        output.writeMessageBegin("get_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("get_table_epoch_by_name", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_epoch_by_name(args.session, args.table_name, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new Heavy_get_table_epoch_by_name_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_epoch_by_name", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_epoch_by_name", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_epochs (seqid, input, output) {
    const args = new Heavy_get_table_epochs_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_epochs.length === 3) {
      Promise.resolve(this._handler.get_table_epochs.bind(this._handler)(
        args.session,
        args.db_id,
        args.table_id
      )).then(result => {
        const result_obj = new Heavy_get_table_epochs_result({success: result});
        output.writeMessageBegin("get_table_epochs", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("get_table_epochs", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_epochs(args.session, args.db_id, args.table_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new Heavy_get_table_epochs_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_epochs", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_epochs", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_table_epochs (seqid, input, output) {
    const args = new Heavy_set_table_epochs_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_table_epochs.length === 3) {
      Promise.resolve(this._handler.set_table_epochs.bind(this._handler)(
        args.session,
        args.db_id,
        args.table_epochs
      )).then(result => {
        const result_obj = new Heavy_set_table_epochs_result({success: result});
        output.writeMessageBegin("set_table_epochs", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
        output.writeMessageBegin("set_table_epochs", Thrift.MessageType.EXCEPTION, seqid);
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_table_epochs(args.session, args.db_id, args.table_epochs, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined')) {
          result_obj = new Heavy_set_table_epochs_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_table_epochs", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_table_epochs", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_session_info (seqid, input, output) {
    const args = new Heavy_get_session_info_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_session_info.length === 1) {
      Promise.resolve(this._handler.get_session_info.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_session_info_result({success: result});
        output.writeMessageBegin("get_session_info", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_session_info_result(err);
          output.writeMessageBegin("get_session_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_session_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_session_info(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_session_info_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_session_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_session_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_queries_info (seqid, input, output) {
    const args = new Heavy_get_queries_info_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_queries_info.length === 1) {
      Promise.resolve(this._handler.get_queries_info.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_queries_info_result({success: result});
        output.writeMessageBegin("get_queries_info", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_queries_info_result(err);
          output.writeMessageBegin("get_queries_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_queries_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_queries_info(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_queries_info_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_queries_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_queries_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_leaf_info (seqid, input, output) {
    const args = new Heavy_set_leaf_info_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_leaf_info.length === 2) {
      Promise.resolve(this._handler.set_leaf_info.bind(this._handler)(
        args.session,
        args.leaf_info
      )).then(result => {
        const result_obj = new Heavy_set_leaf_info_result({success: result});
        output.writeMessageBegin("set_leaf_info", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_leaf_info_result(err);
          output.writeMessageBegin("set_leaf_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_leaf_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_leaf_info(args.session, args.leaf_info, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_leaf_info_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_leaf_info", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_leaf_info", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sql_execute (seqid, input, output) {
    const args = new Heavy_sql_execute_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sql_execute.length === 6) {
      Promise.resolve(this._handler.sql_execute.bind(this._handler)(
        args.session,
        args.query,
        args.column_format,
        args.nonce,
        args.first_n,
        args.at_most_n
      )).then(result => {
        const result_obj = new Heavy_sql_execute_result({success: result});
        output.writeMessageBegin("sql_execute", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_sql_execute_result(err);
          output.writeMessageBegin("sql_execute", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sql_execute(args.session, args.query, args.column_format, args.nonce, args.first_n, args.at_most_n, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_sql_execute_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sql_execute", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sql_execute_df (seqid, input, output) {
    const args = new Heavy_sql_execute_df_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sql_execute_df.length === 6) {
      Promise.resolve(this._handler.sql_execute_df.bind(this._handler)(
        args.session,
        args.query,
        args.device_type,
        args.device_id,
        args.first_n,
        args.transport_method
      )).then(result => {
        const result_obj = new Heavy_sql_execute_df_result({success: result});
        output.writeMessageBegin("sql_execute_df", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_sql_execute_df_result(err);
          output.writeMessageBegin("sql_execute_df", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute_df", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sql_execute_df(args.session, args.query, args.device_type, args.device_id, args.first_n, args.transport_method, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_sql_execute_df_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sql_execute_df", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute_df", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sql_execute_gdf (seqid, input, output) {
    const args = new Heavy_sql_execute_gdf_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sql_execute_gdf.length === 4) {
      Promise.resolve(this._handler.sql_execute_gdf.bind(this._handler)(
        args.session,
        args.query,
        args.device_id,
        args.first_n
      )).then(result => {
        const result_obj = new Heavy_sql_execute_gdf_result({success: result});
        output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_sql_execute_gdf_result(err);
          output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sql_execute_gdf(args.session, args.query, args.device_id, args.first_n, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_sql_execute_gdf_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_execute_gdf", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_deallocate_df (seqid, input, output) {
    const args = new Heavy_deallocate_df_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.deallocate_df.length === 4) {
      Promise.resolve(this._handler.deallocate_df.bind(this._handler)(
        args.session,
        args.df,
        args.device_type,
        args.device_id
      )).then(result => {
        const result_obj = new Heavy_deallocate_df_result({success: result});
        output.writeMessageBegin("deallocate_df", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_deallocate_df_result(err);
          output.writeMessageBegin("deallocate_df", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("deallocate_df", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.deallocate_df(args.session, args.df, args.device_type, args.device_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_deallocate_df_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("deallocate_df", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("deallocate_df", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_interrupt (seqid, input, output) {
    const args = new Heavy_interrupt_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.interrupt.length === 2) {
      Promise.resolve(this._handler.interrupt.bind(this._handler)(
        args.query_session,
        args.interrupt_session
      )).then(result => {
        const result_obj = new Heavy_interrupt_result({success: result});
        output.writeMessageBegin("interrupt", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_interrupt_result(err);
          output.writeMessageBegin("interrupt", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("interrupt", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.interrupt(args.query_session, args.interrupt_session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_interrupt_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("interrupt", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("interrupt", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_sql_validate (seqid, input, output) {
    const args = new Heavy_sql_validate_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.sql_validate.length === 2) {
      Promise.resolve(this._handler.sql_validate.bind(this._handler)(
        args.session,
        args.query
      )).then(result => {
        const result_obj = new Heavy_sql_validate_result({success: result});
        output.writeMessageBegin("sql_validate", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_sql_validate_result(err);
          output.writeMessageBegin("sql_validate", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_validate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.sql_validate(args.session, args.query, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_sql_validate_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("sql_validate", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("sql_validate", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_completion_hints (seqid, input, output) {
    const args = new Heavy_get_completion_hints_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_completion_hints.length === 3) {
      Promise.resolve(this._handler.get_completion_hints.bind(this._handler)(
        args.session,
        args.sql,
        args.cursor
      )).then(result => {
        const result_obj = new Heavy_get_completion_hints_result({success: result});
        output.writeMessageBegin("get_completion_hints", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_completion_hints_result(err);
          output.writeMessageBegin("get_completion_hints", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_completion_hints", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_completion_hints(args.session, args.sql, args.cursor, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_completion_hints_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_completion_hints", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_completion_hints", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_execution_mode (seqid, input, output) {
    const args = new Heavy_set_execution_mode_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_execution_mode.length === 2) {
      Promise.resolve(this._handler.set_execution_mode.bind(this._handler)(
        args.session,
        args.mode
      )).then(result => {
        const result_obj = new Heavy_set_execution_mode_result({success: result});
        output.writeMessageBegin("set_execution_mode", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_execution_mode_result(err);
          output.writeMessageBegin("set_execution_mode", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_execution_mode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_execution_mode(args.session, args.mode, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_execution_mode_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_execution_mode", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_execution_mode", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_render_vega (seqid, input, output) {
    const args = new Heavy_render_vega_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.render_vega.length === 5) {
      Promise.resolve(this._handler.render_vega.bind(this._handler)(
        args.session,
        args.widget_id,
        args.vega_json,
        args.compression_level,
        args.nonce
      )).then(result => {
        const result_obj = new Heavy_render_vega_result({success: result});
        output.writeMessageBegin("render_vega", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_render_vega_result(err);
          output.writeMessageBegin("render_vega", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("render_vega", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.render_vega(args.session, args.widget_id, args.vega_json, args.compression_level, args.nonce, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_render_vega_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("render_vega", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("render_vega", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_result_row_for_pixel (seqid, input, output) {
    const args = new Heavy_get_result_row_for_pixel_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_result_row_for_pixel.length === 7) {
      Promise.resolve(this._handler.get_result_row_for_pixel.bind(this._handler)(
        args.session,
        args.widget_id,
        args.pixel,
        args.table_col_names,
        args.column_format,
        args.pixelRadius,
        args.nonce
      )).then(result => {
        const result_obj = new Heavy_get_result_row_for_pixel_result({success: result});
        output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_result_row_for_pixel_result(err);
          output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_result_row_for_pixel(args.session, args.widget_id, args.pixel, args.table_col_names, args.column_format, args.pixelRadius, args.nonce, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_result_row_for_pixel_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_result_row_for_pixel", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_create_custom_expression (seqid, input, output) {
    const args = new Heavy_create_custom_expression_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.create_custom_expression.length === 2) {
      Promise.resolve(this._handler.create_custom_expression.bind(this._handler)(
        args.session,
        args.custom_expression
      )).then(result => {
        const result_obj = new Heavy_create_custom_expression_result({success: result});
        output.writeMessageBegin("create_custom_expression", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_create_custom_expression_result(err);
          output.writeMessageBegin("create_custom_expression", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_custom_expression", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.create_custom_expression(args.session, args.custom_expression, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_create_custom_expression_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("create_custom_expression", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_custom_expression", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_custom_expressions (seqid, input, output) {
    const args = new Heavy_get_custom_expressions_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_custom_expressions.length === 1) {
      Promise.resolve(this._handler.get_custom_expressions.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_custom_expressions_result({success: result});
        output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_custom_expressions_result(err);
          output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_custom_expressions(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_custom_expressions_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_custom_expressions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_update_custom_expression (seqid, input, output) {
    const args = new Heavy_update_custom_expression_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.update_custom_expression.length === 3) {
      Promise.resolve(this._handler.update_custom_expression.bind(this._handler)(
        args.session,
        args.id,
        args.expression_json
      )).then(result => {
        const result_obj = new Heavy_update_custom_expression_result({success: result});
        output.writeMessageBegin("update_custom_expression", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_update_custom_expression_result(err);
          output.writeMessageBegin("update_custom_expression", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("update_custom_expression", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.update_custom_expression(args.session, args.id, args.expression_json, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_update_custom_expression_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("update_custom_expression", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("update_custom_expression", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_delete_custom_expressions (seqid, input, output) {
    const args = new Heavy_delete_custom_expressions_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.delete_custom_expressions.length === 3) {
      Promise.resolve(this._handler.delete_custom_expressions.bind(this._handler)(
        args.session,
        args.custom_expression_ids,
        args.do_soft_delete
      )).then(result => {
        const result_obj = new Heavy_delete_custom_expressions_result({success: result});
        output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_delete_custom_expressions_result(err);
          output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.delete_custom_expressions(args.session, args.custom_expression_ids, args.do_soft_delete, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_delete_custom_expressions_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_custom_expressions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_dashboard (seqid, input, output) {
    const args = new Heavy_get_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_dashboard.length === 2) {
      Promise.resolve(this._handler.get_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id
      )).then(result => {
        const result_obj = new Heavy_get_dashboard_result({success: result});
        output.writeMessageBegin("get_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_dashboard_result(err);
          output.writeMessageBegin("get_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_dashboard(args.session, args.dashboard_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_dashboards (seqid, input, output) {
    const args = new Heavy_get_dashboards_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_dashboards.length === 1) {
      Promise.resolve(this._handler.get_dashboards.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_dashboards_result({success: result});
        output.writeMessageBegin("get_dashboards", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_dashboards_result(err);
          output.writeMessageBegin("get_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_dashboards(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_dashboards_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_create_dashboard (seqid, input, output) {
    const args = new Heavy_create_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.create_dashboard.length === 5) {
      Promise.resolve(this._handler.create_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_name,
        args.dashboard_state,
        args.image_hash,
        args.dashboard_metadata
      )).then(result => {
        const result_obj = new Heavy_create_dashboard_result({success: result});
        output.writeMessageBegin("create_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_create_dashboard_result(err);
          output.writeMessageBegin("create_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.create_dashboard(args.session, args.dashboard_name, args.dashboard_state, args.image_hash, args.dashboard_metadata, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_create_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("create_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_replace_dashboard (seqid, input, output) {
    const args = new Heavy_replace_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.replace_dashboard.length === 7) {
      Promise.resolve(this._handler.replace_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id,
        args.dashboard_name,
        args.dashboard_owner,
        args.dashboard_state,
        args.image_hash,
        args.dashboard_metadata
      )).then(result => {
        const result_obj = new Heavy_replace_dashboard_result({success: result});
        output.writeMessageBegin("replace_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_replace_dashboard_result(err);
          output.writeMessageBegin("replace_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("replace_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.replace_dashboard(args.session, args.dashboard_id, args.dashboard_name, args.dashboard_owner, args.dashboard_state, args.image_hash, args.dashboard_metadata, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_replace_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("replace_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("replace_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_delete_dashboard (seqid, input, output) {
    const args = new Heavy_delete_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.delete_dashboard.length === 2) {
      Promise.resolve(this._handler.delete_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id
      )).then(result => {
        const result_obj = new Heavy_delete_dashboard_result({success: result});
        output.writeMessageBegin("delete_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_delete_dashboard_result(err);
          output.writeMessageBegin("delete_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.delete_dashboard(args.session, args.dashboard_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_delete_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("delete_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_share_dashboards (seqid, input, output) {
    const args = new Heavy_share_dashboards_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.share_dashboards.length === 4) {
      Promise.resolve(this._handler.share_dashboards.bind(this._handler)(
        args.session,
        args.dashboard_ids,
        args.groups,
        args.permissions
      )).then(result => {
        const result_obj = new Heavy_share_dashboards_result({success: result});
        output.writeMessageBegin("share_dashboards", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_share_dashboards_result(err);
          output.writeMessageBegin("share_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("share_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.share_dashboards(args.session, args.dashboard_ids, args.groups, args.permissions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_share_dashboards_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("share_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("share_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_delete_dashboards (seqid, input, output) {
    const args = new Heavy_delete_dashboards_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.delete_dashboards.length === 2) {
      Promise.resolve(this._handler.delete_dashboards.bind(this._handler)(
        args.session,
        args.dashboard_ids
      )).then(result => {
        const result_obj = new Heavy_delete_dashboards_result({success: result});
        output.writeMessageBegin("delete_dashboards", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_delete_dashboards_result(err);
          output.writeMessageBegin("delete_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.delete_dashboards(args.session, args.dashboard_ids, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_delete_dashboards_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("delete_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("delete_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_share_dashboard (seqid, input, output) {
    const args = new Heavy_share_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.share_dashboard.length === 6) {
      Promise.resolve(this._handler.share_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id,
        args.groups,
        args.objects,
        args.permissions,
        args.grant_role
      )).then(result => {
        const result_obj = new Heavy_share_dashboard_result({success: result});
        output.writeMessageBegin("share_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_share_dashboard_result(err);
          output.writeMessageBegin("share_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("share_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.share_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions, args.grant_role, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_share_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("share_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("share_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_unshare_dashboard (seqid, input, output) {
    const args = new Heavy_unshare_dashboard_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.unshare_dashboard.length === 5) {
      Promise.resolve(this._handler.unshare_dashboard.bind(this._handler)(
        args.session,
        args.dashboard_id,
        args.groups,
        args.objects,
        args.permissions
      )).then(result => {
        const result_obj = new Heavy_unshare_dashboard_result({success: result});
        output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_unshare_dashboard_result(err);
          output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.unshare_dashboard(args.session, args.dashboard_id, args.groups, args.objects, args.permissions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_unshare_dashboard_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unshare_dashboard", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_unshare_dashboards (seqid, input, output) {
    const args = new Heavy_unshare_dashboards_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.unshare_dashboards.length === 4) {
      Promise.resolve(this._handler.unshare_dashboards.bind(this._handler)(
        args.session,
        args.dashboard_ids,
        args.groups,
        args.permissions
      )).then(result => {
        const result_obj = new Heavy_unshare_dashboards_result({success: result});
        output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_unshare_dashboards_result(err);
          output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.unshare_dashboards(args.session, args.dashboard_ids, args.groups, args.permissions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_unshare_dashboards_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("unshare_dashboards", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_dashboard_grantees (seqid, input, output) {
    const args = new Heavy_get_dashboard_grantees_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_dashboard_grantees.length === 2) {
      Promise.resolve(this._handler.get_dashboard_grantees.bind(this._handler)(
        args.session,
        args.dashboard_id
      )).then(result => {
        const result_obj = new Heavy_get_dashboard_grantees_result({success: result});
        output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_dashboard_grantees_result(err);
          output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_dashboard_grantees(args.session, args.dashboard_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_dashboard_grantees_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_dashboard_grantees", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_link_view (seqid, input, output) {
    const args = new Heavy_get_link_view_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_link_view.length === 2) {
      Promise.resolve(this._handler.get_link_view.bind(this._handler)(
        args.session,
        args.link
      )).then(result => {
        const result_obj = new Heavy_get_link_view_result({success: result});
        output.writeMessageBegin("get_link_view", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_link_view_result(err);
          output.writeMessageBegin("get_link_view", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_link_view", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_link_view(args.session, args.link, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_link_view_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_link_view", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_link_view", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_create_link (seqid, input, output) {
    const args = new Heavy_create_link_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.create_link.length === 3) {
      Promise.resolve(this._handler.create_link.bind(this._handler)(
        args.session,
        args.view_state,
        args.view_metadata
      )).then(result => {
        const result_obj = new Heavy_create_link_result({success: result});
        output.writeMessageBegin("create_link", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_create_link_result(err);
          output.writeMessageBegin("create_link", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_link", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.create_link(args.session, args.view_state, args.view_metadata, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_create_link_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("create_link", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_link", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table_binary (seqid, input, output) {
    const args = new Heavy_load_table_binary_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table_binary.length === 4) {
      Promise.resolve(this._handler.load_table_binary.bind(this._handler)(
        args.session,
        args.table_name,
        args.rows,
        args.column_names
      )).then(result => {
        const result_obj = new Heavy_load_table_binary_result({success: result});
        output.writeMessageBegin("load_table_binary", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_binary_result(err);
          output.writeMessageBegin("load_table_binary", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table_binary(args.session, args.table_name, args.rows, args.column_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_binary_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table_binary", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table_binary_columnar (seqid, input, output) {
    const args = new Heavy_load_table_binary_columnar_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table_binary_columnar.length === 4) {
      Promise.resolve(this._handler.load_table_binary_columnar.bind(this._handler)(
        args.session,
        args.table_name,
        args.cols,
        args.column_names
      )).then(result => {
        const result_obj = new Heavy_load_table_binary_columnar_result({success: result});
        output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_binary_columnar_result(err);
          output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table_binary_columnar(args.session, args.table_name, args.cols, args.column_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_binary_columnar_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_columnar", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table_binary_arrow (seqid, input, output) {
    const args = new Heavy_load_table_binary_arrow_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table_binary_arrow.length === 4) {
      Promise.resolve(this._handler.load_table_binary_arrow.bind(this._handler)(
        args.session,
        args.table_name,
        args.arrow_stream,
        args.use_column_names
      )).then(result => {
        const result_obj = new Heavy_load_table_binary_arrow_result({success: result});
        output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_binary_arrow_result(err);
          output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table_binary_arrow(args.session, args.table_name, args.arrow_stream, args.use_column_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_binary_arrow_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table_binary_arrow", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_load_table (seqid, input, output) {
    const args = new Heavy_load_table_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.load_table.length === 4) {
      Promise.resolve(this._handler.load_table.bind(this._handler)(
        args.session,
        args.table_name,
        args.rows,
        args.column_names
      )).then(result => {
        const result_obj = new Heavy_load_table_result({success: result});
        output.writeMessageBegin("load_table", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_load_table_result(err);
          output.writeMessageBegin("load_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.load_table(args.session, args.table_name, args.rows, args.column_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_load_table_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("load_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("load_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_detect_column_types (seqid, input, output) {
    const args = new Heavy_detect_column_types_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.detect_column_types.length === 3) {
      Promise.resolve(this._handler.detect_column_types.bind(this._handler)(
        args.session,
        args.file_name,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_detect_column_types_result({success: result});
        output.writeMessageBegin("detect_column_types", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_detect_column_types_result(err);
          output.writeMessageBegin("detect_column_types", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("detect_column_types", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.detect_column_types(args.session, args.file_name, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_detect_column_types_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("detect_column_types", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("detect_column_types", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_create_table (seqid, input, output) {
    const args = new Heavy_create_table_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.create_table.length === 4) {
      Promise.resolve(this._handler.create_table.bind(this._handler)(
        args.session,
        args.table_name,
        args.row_desc,
        args.create_params
      )).then(result => {
        const result_obj = new Heavy_create_table_result({success: result});
        output.writeMessageBegin("create_table", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_create_table_result(err);
          output.writeMessageBegin("create_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.create_table(args.session, args.table_name, args.row_desc, args.create_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_create_table_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("create_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("create_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_import_table (seqid, input, output) {
    const args = new Heavy_import_table_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.import_table.length === 4) {
      Promise.resolve(this._handler.import_table.bind(this._handler)(
        args.session,
        args.table_name,
        args.file_name,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_import_table_result({success: result});
        output.writeMessageBegin("import_table", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_import_table_result(err);
          output.writeMessageBegin("import_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.import_table(args.session, args.table_name, args.file_name, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_import_table_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("import_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_import_geo_table (seqid, input, output) {
    const args = new Heavy_import_geo_table_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.import_geo_table.length === 6) {
      Promise.resolve(this._handler.import_geo_table.bind(this._handler)(
        args.session,
        args.table_name,
        args.file_name,
        args.copy_params,
        args.row_desc,
        args.create_params
      )).then(result => {
        const result_obj = new Heavy_import_geo_table_result({success: result});
        output.writeMessageBegin("import_geo_table", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_import_geo_table_result(err);
          output.writeMessageBegin("import_geo_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_geo_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.import_geo_table(args.session, args.table_name, args.file_name, args.copy_params, args.row_desc, args.create_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_import_geo_table_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("import_geo_table", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_geo_table", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_import_table_status (seqid, input, output) {
    const args = new Heavy_import_table_status_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.import_table_status.length === 2) {
      Promise.resolve(this._handler.import_table_status.bind(this._handler)(
        args.session,
        args.import_id
      )).then(result => {
        const result_obj = new Heavy_import_table_status_result({success: result});
        output.writeMessageBegin("import_table_status", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_import_table_status_result(err);
          output.writeMessageBegin("import_table_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_table_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.import_table_status(args.session, args.import_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_import_table_status_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("import_table_status", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("import_table_status", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_first_geo_file_in_archive (seqid, input, output) {
    const args = new Heavy_get_first_geo_file_in_archive_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_first_geo_file_in_archive.length === 3) {
      Promise.resolve(this._handler.get_first_geo_file_in_archive.bind(this._handler)(
        args.session,
        args.archive_path,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_get_first_geo_file_in_archive_result({success: result});
        output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_first_geo_file_in_archive_result(err);
          output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_first_geo_file_in_archive(args.session, args.archive_path, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_first_geo_file_in_archive_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_first_geo_file_in_archive", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_all_files_in_archive (seqid, input, output) {
    const args = new Heavy_get_all_files_in_archive_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_all_files_in_archive.length === 3) {
      Promise.resolve(this._handler.get_all_files_in_archive.bind(this._handler)(
        args.session,
        args.archive_path,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_get_all_files_in_archive_result({success: result});
        output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_all_files_in_archive_result(err);
          output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_all_files_in_archive(args.session, args.archive_path, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_all_files_in_archive_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_files_in_archive", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_layers_in_geo_file (seqid, input, output) {
    const args = new Heavy_get_layers_in_geo_file_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_layers_in_geo_file.length === 3) {
      Promise.resolve(this._handler.get_layers_in_geo_file.bind(this._handler)(
        args.session,
        args.file_name,
        args.copy_params
      )).then(result => {
        const result_obj = new Heavy_get_layers_in_geo_file_result({success: result});
        output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_layers_in_geo_file_result(err);
          output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_layers_in_geo_file(args.session, args.file_name, args.copy_params, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_layers_in_geo_file_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_layers_in_geo_file", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_query_get_outer_fragment_count (seqid, input, output) {
    const args = new Heavy_query_get_outer_fragment_count_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.query_get_outer_fragment_count.length === 2) {
      Promise.resolve(this._handler.query_get_outer_fragment_count.bind(this._handler)(
        args.session,
        args.query
      )).then(result => {
        const result_obj = new Heavy_query_get_outer_fragment_count_result({success: result});
        output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_query_get_outer_fragment_count_result(err);
          output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.query_get_outer_fragment_count(args.session, args.query, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_query_get_outer_fragment_count_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("query_get_outer_fragment_count", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_check_table_consistency (seqid, input, output) {
    const args = new Heavy_check_table_consistency_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.check_table_consistency.length === 2) {
      Promise.resolve(this._handler.check_table_consistency.bind(this._handler)(
        args.session,
        args.table_id
      )).then(result => {
        const result_obj = new Heavy_check_table_consistency_result({success: result});
        output.writeMessageBegin("check_table_consistency", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_check_table_consistency_result(err);
          output.writeMessageBegin("check_table_consistency", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("check_table_consistency", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.check_table_consistency(args.session, args.table_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_check_table_consistency_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("check_table_consistency", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("check_table_consistency", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_start_query (seqid, input, output) {
    const args = new Heavy_start_query_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.start_query.length === 6) {
      Promise.resolve(this._handler.start_query.bind(this._handler)(
        args.leaf_session,
        args.parent_session,
        args.query_ra,
        args.start_time_str,
        args.just_explain,
        args.outer_fragment_indices
      )).then(result => {
        const result_obj = new Heavy_start_query_result({success: result});
        output.writeMessageBegin("start_query", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_start_query_result(err);
          output.writeMessageBegin("start_query", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_query", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.start_query(args.leaf_session, args.parent_session, args.query_ra, args.start_time_str, args.just_explain, args.outer_fragment_indices, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_start_query_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("start_query", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_query", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_execute_query_step (seqid, input, output) {
    const args = new Heavy_execute_query_step_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.execute_query_step.length === 3) {
      Promise.resolve(this._handler.execute_query_step.bind(this._handler)(
        args.pending_query,
        args.subquery_id,
        args.start_time_str
      )).then(result => {
        const result_obj = new Heavy_execute_query_step_result({success: result});
        output.writeMessageBegin("execute_query_step", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_execute_query_step_result(err);
          output.writeMessageBegin("execute_query_step", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("execute_query_step", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.execute_query_step(args.pending_query, args.subquery_id, args.start_time_str, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_execute_query_step_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("execute_query_step", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("execute_query_step", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_broadcast_serialized_rows (seqid, input, output) {
    const args = new Heavy_broadcast_serialized_rows_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.broadcast_serialized_rows.length === 5) {
      Promise.resolve(this._handler.broadcast_serialized_rows.bind(this._handler)(
        args.serialized_rows,
        args.row_desc,
        args.query_id,
        args.subquery_id,
        args.is_final_subquery_result
      )).then(result => {
        const result_obj = new Heavy_broadcast_serialized_rows_result({success: result});
        output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_broadcast_serialized_rows_result(err);
          output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.broadcast_serialized_rows(args.serialized_rows, args.row_desc, args.query_id, args.subquery_id, args.is_final_subquery_result, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_broadcast_serialized_rows_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("broadcast_serialized_rows", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_start_render_query (seqid, input, output) {
    const args = new Heavy_start_render_query_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.start_render_query.length === 4) {
      Promise.resolve(this._handler.start_render_query.bind(this._handler)(
        args.session,
        args.widget_id,
        args.node_idx,
        args.vega_json
      )).then(result => {
        const result_obj = new Heavy_start_render_query_result({success: result});
        output.writeMessageBegin("start_render_query", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_start_render_query_result(err);
          output.writeMessageBegin("start_render_query", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_render_query", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.start_render_query(args.session, args.widget_id, args.node_idx, args.vega_json, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_start_render_query_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("start_render_query", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("start_render_query", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_execute_next_render_step (seqid, input, output) {
    const args = new Heavy_execute_next_render_step_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.execute_next_render_step.length === 2) {
      Promise.resolve(this._handler.execute_next_render_step.bind(this._handler)(
        args.pending_render,
        args.merged_data
      )).then(result => {
        const result_obj = new Heavy_execute_next_render_step_result({success: result});
        output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_execute_next_render_step_result(err);
          output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.execute_next_render_step(args.pending_render, args.merged_data, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_execute_next_render_step_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("execute_next_render_step", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_insert_data (seqid, input, output) {
    const args = new Heavy_insert_data_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.insert_data.length === 2) {
      Promise.resolve(this._handler.insert_data.bind(this._handler)(
        args.session,
        args.insert_data
      )).then(result => {
        const result_obj = new Heavy_insert_data_result({success: result});
        output.writeMessageBegin("insert_data", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_insert_data_result(err);
          output.writeMessageBegin("insert_data", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("insert_data", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.insert_data(args.session, args.insert_data, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_insert_data_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("insert_data", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("insert_data", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_insert_chunks (seqid, input, output) {
    const args = new Heavy_insert_chunks_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.insert_chunks.length === 2) {
      Promise.resolve(this._handler.insert_chunks.bind(this._handler)(
        args.session,
        args.insert_chunks
      )).then(result => {
        const result_obj = new Heavy_insert_chunks_result({success: result});
        output.writeMessageBegin("insert_chunks", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_insert_chunks_result(err);
          output.writeMessageBegin("insert_chunks", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("insert_chunks", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.insert_chunks(args.session, args.insert_chunks, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_insert_chunks_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("insert_chunks", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("insert_chunks", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_checkpoint (seqid, input, output) {
    const args = new Heavy_checkpoint_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.checkpoint.length === 2) {
      Promise.resolve(this._handler.checkpoint.bind(this._handler)(
        args.session,
        args.table_id
      )).then(result => {
        const result_obj = new Heavy_checkpoint_result({success: result});
        output.writeMessageBegin("checkpoint", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_checkpoint_result(err);
          output.writeMessageBegin("checkpoint", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("checkpoint", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.checkpoint(args.session, args.table_id, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_checkpoint_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("checkpoint", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("checkpoint", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_roles (seqid, input, output) {
    const args = new Heavy_get_roles_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_roles.length === 1) {
      Promise.resolve(this._handler.get_roles.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_roles_result({success: result});
        output.writeMessageBegin("get_roles", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_roles_result(err);
          output.writeMessageBegin("get_roles", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_roles", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_roles(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_roles_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_roles", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_roles", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_db_objects_for_grantee (seqid, input, output) {
    const args = new Heavy_get_db_objects_for_grantee_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_db_objects_for_grantee.length === 2) {
      Promise.resolve(this._handler.get_db_objects_for_grantee.bind(this._handler)(
        args.session,
        args.roleName
      )).then(result => {
        const result_obj = new Heavy_get_db_objects_for_grantee_result({success: result});
        output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_db_objects_for_grantee_result(err);
          output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_db_objects_for_grantee(args.session, args.roleName, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_db_objects_for_grantee_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_db_objects_for_grantee", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_db_object_privs (seqid, input, output) {
    const args = new Heavy_get_db_object_privs_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_db_object_privs.length === 3) {
      Promise.resolve(this._handler.get_db_object_privs.bind(this._handler)(
        args.session,
        args.objectName,
        args.type
      )).then(result => {
        const result_obj = new Heavy_get_db_object_privs_result({success: result});
        output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_db_object_privs_result(err);
          output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_db_object_privs(args.session, args.objectName, args.type, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_db_object_privs_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_db_object_privs", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_all_roles_for_user (seqid, input, output) {
    const args = new Heavy_get_all_roles_for_user_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_all_roles_for_user.length === 2) {
      Promise.resolve(this._handler.get_all_roles_for_user.bind(this._handler)(
        args.session,
        args.userName
      )).then(result => {
        const result_obj = new Heavy_get_all_roles_for_user_result({success: result});
        output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_all_roles_for_user_result(err);
          output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_all_roles_for_user(args.session, args.userName, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_all_roles_for_user_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_roles_for_user", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_all_effective_roles_for_user (seqid, input, output) {
    const args = new Heavy_get_all_effective_roles_for_user_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_all_effective_roles_for_user.length === 2) {
      Promise.resolve(this._handler.get_all_effective_roles_for_user.bind(this._handler)(
        args.session,
        args.userName
      )).then(result => {
        const result_obj = new Heavy_get_all_effective_roles_for_user_result({success: result});
        output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_all_effective_roles_for_user_result(err);
          output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_all_effective_roles_for_user(args.session, args.userName, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_all_effective_roles_for_user_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_all_effective_roles_for_user", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_has_role (seqid, input, output) {
    const args = new Heavy_has_role_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.has_role.length === 3) {
      Promise.resolve(this._handler.has_role.bind(this._handler)(
        args.session,
        args.granteeName,
        args.roleName
      )).then(result => {
        const result_obj = new Heavy_has_role_result({success: result});
        output.writeMessageBegin("has_role", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_has_role_result(err);
          output.writeMessageBegin("has_role", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("has_role", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.has_role(args.session, args.granteeName, args.roleName, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_has_role_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("has_role", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("has_role", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_has_object_privilege (seqid, input, output) {
    const args = new Heavy_has_object_privilege_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.has_object_privilege.length === 5) {
      Promise.resolve(this._handler.has_object_privilege.bind(this._handler)(
        args.session,
        args.granteeName,
        args.ObjectName,
        args.objectType,
        args.permissions
      )).then(result => {
        const result_obj = new Heavy_has_object_privilege_result({success: result});
        output.writeMessageBegin("has_object_privilege", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_has_object_privilege_result(err);
          output.writeMessageBegin("has_object_privilege", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("has_object_privilege", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.has_object_privilege(args.session, args.granteeName, args.ObjectName, args.objectType, args.permissions, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_has_object_privilege_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("has_object_privilege", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("has_object_privilege", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_set_license_key (seqid, input, output) {
    const args = new Heavy_set_license_key_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.set_license_key.length === 3) {
      Promise.resolve(this._handler.set_license_key.bind(this._handler)(
        args.session,
        args.key,
        args.nonce
      )).then(result => {
        const result_obj = new Heavy_set_license_key_result({success: result});
        output.writeMessageBegin("set_license_key", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_set_license_key_result(err);
          output.writeMessageBegin("set_license_key", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_license_key", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.set_license_key(args.session, args.key, args.nonce, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_set_license_key_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("set_license_key", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("set_license_key", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_license_claims (seqid, input, output) {
    const args = new Heavy_get_license_claims_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_license_claims.length === 2) {
      Promise.resolve(this._handler.get_license_claims.bind(this._handler)(
        args.session,
        args.nonce
      )).then(result => {
        const result_obj = new Heavy_get_license_claims_result({success: result});
        output.writeMessageBegin("get_license_claims", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_license_claims_result(err);
          output.writeMessageBegin("get_license_claims", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_license_claims", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_license_claims(args.session, args.nonce, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_license_claims_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_license_claims", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_license_claims", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_device_parameters (seqid, input, output) {
    const args = new Heavy_get_device_parameters_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_device_parameters.length === 1) {
      Promise.resolve(this._handler.get_device_parameters.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_device_parameters_result({success: result});
        output.writeMessageBegin("get_device_parameters", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_device_parameters_result(err);
          output.writeMessageBegin("get_device_parameters", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_device_parameters", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_device_parameters(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_device_parameters_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_device_parameters", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_device_parameters", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_register_runtime_extension_functions (seqid, input, output) {
    const args = new Heavy_register_runtime_extension_functions_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.register_runtime_extension_functions.length === 4) {
      Promise.resolve(this._handler.register_runtime_extension_functions.bind(this._handler)(
        args.session,
        args.udfs,
        args.udtfs,
        args.device_ir_map
      )).then(result => {
        const result_obj = new Heavy_register_runtime_extension_functions_result({success: result});
        output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_register_runtime_extension_functions_result(err);
          output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.register_runtime_extension_functions(args.session, args.udfs, args.udtfs, args.device_ir_map, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_register_runtime_extension_functions_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("register_runtime_extension_functions", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_function_names (seqid, input, output) {
    const args = new Heavy_get_table_function_names_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_function_names.length === 1) {
      Promise.resolve(this._handler.get_table_function_names.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_table_function_names_result({success: result});
        output.writeMessageBegin("get_table_function_names", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_table_function_names_result(err);
          output.writeMessageBegin("get_table_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_function_names(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_table_function_names_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_runtime_table_function_names (seqid, input, output) {
    const args = new Heavy_get_runtime_table_function_names_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_runtime_table_function_names.length === 1) {
      Promise.resolve(this._handler.get_runtime_table_function_names.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_runtime_table_function_names_result({success: result});
        output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_runtime_table_function_names_result(err);
          output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_runtime_table_function_names(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_runtime_table_function_names_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_runtime_table_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_table_function_details (seqid, input, output) {
    const args = new Heavy_get_table_function_details_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_table_function_details.length === 2) {
      Promise.resolve(this._handler.get_table_function_details.bind(this._handler)(
        args.session,
        args.udtf_names
      )).then(result => {
        const result_obj = new Heavy_get_table_function_details_result({success: result});
        output.writeMessageBegin("get_table_function_details", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_table_function_details_result(err);
          output.writeMessageBegin("get_table_function_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_function_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_table_function_details(args.session, args.udtf_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_table_function_details_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_table_function_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_table_function_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_function_names (seqid, input, output) {
    const args = new Heavy_get_function_names_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_function_names.length === 1) {
      Promise.resolve(this._handler.get_function_names.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_function_names_result({success: result});
        output.writeMessageBegin("get_function_names", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_function_names_result(err);
          output.writeMessageBegin("get_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_function_names(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_function_names_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_runtime_function_names (seqid, input, output) {
    const args = new Heavy_get_runtime_function_names_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_runtime_function_names.length === 1) {
      Promise.resolve(this._handler.get_runtime_function_names.bind(this._handler)(
        args.session
      )).then(result => {
        const result_obj = new Heavy_get_runtime_function_names_result({success: result});
        output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_runtime_function_names_result(err);
          output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_runtime_function_names(args.session, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_runtime_function_names_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_runtime_function_names", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
  process_get_function_details (seqid, input, output) {
    const args = new Heavy_get_function_details_args();
    args.read(input);
    input.readMessageEnd();
    if (this._handler.get_function_details.length === 2) {
      Promise.resolve(this._handler.get_function_details.bind(this._handler)(
        args.session,
        args.udf_names
      )).then(result => {
        const result_obj = new Heavy_get_function_details_result({success: result});
        output.writeMessageBegin("get_function_details", Thrift.MessageType.REPLY, seqid);
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      }).catch(err => {
        let result;
        if (err instanceof ttypes.TDBException) {
          result = new Heavy_get_function_details_result(err);
          output.writeMessageBegin("get_function_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_function_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    } else {
      this._handler.get_function_details(args.session, args.udf_names, (err, result) => {
        let result_obj;
        if ((err === null || typeof err === 'undefined') || err instanceof ttypes.TDBException) {
          result_obj = new Heavy_get_function_details_result((err !== null || typeof err === 'undefined') ? err : {success: result});
          output.writeMessageBegin("get_function_details", Thrift.MessageType.REPLY, seqid);
        } else {
          result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("get_function_details", Thrift.MessageType.EXCEPTION, seqid);
        }
        result_obj.write(output);
        output.writeMessageEnd();
        output.flush();
      });
    }
  }
};


/***/ }),

/***/ 2818:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(7392);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);


const ttypes = module.exports = {};
ttypes.TDeviceType = {
  'CPU' : 0,
  'GPU' : 1
};
ttypes.TDatumType = {
  'SMALLINT' : 0,
  'INT' : 1,
  'BIGINT' : 2,
  'FLOAT' : 3,
  'DECIMAL' : 4,
  'DOUBLE' : 5,
  'STR' : 6,
  'TIME' : 7,
  'TIMESTAMP' : 8,
  'DATE' : 9,
  'BOOL' : 10,
  'INTERVAL_DAY_TIME' : 11,
  'INTERVAL_YEAR_MONTH' : 12,
  'POINT' : 13,
  'LINESTRING' : 14,
  'POLYGON' : 15,
  'MULTIPOLYGON' : 16,
  'TINYINT' : 17,
  'GEOMETRY' : 18,
  'GEOGRAPHY' : 19,
  'MULTILINESTRING' : 20,
  'MULTIPOINT' : 21
};
ttypes.TEncodingType = {
  'NONE' : 0,
  'FIXED' : 1,
  'RL' : 2,
  'DIFF' : 3,
  'DICT' : 4,
  'SPARSE' : 5,
  'GEOINT' : 6,
  'DATE_IN_DAYS' : 7,
  'ARRAY' : 8,
  'ARRAY_DICT' : 9
};
const TStringDictKey = module.exports.TStringDictKey = class {
  constructor(args) {
    this.db_id = null;
    this.dict_id = null;
    if (args) {
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.dict_id !== undefined && args.dict_id !== null) {
        this.dict_id = args.dict_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dict_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TStringDictKey');
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 1);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.dict_id !== null && this.dict_id !== undefined) {
      output.writeFieldBegin('dict_id', Thrift.Type.I32, 2);
      output.writeI32(this.dict_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTypeInfo = module.exports.TTypeInfo = class {
  constructor(args) {
    this.type = null;
    this.encoding = null;
    this.nullable = null;
    this.is_array = null;
    this.precision = null;
    this.scale = null;
    this.comp_param = null;
    this.size = -1;
    this.dict_key = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.encoding !== undefined && args.encoding !== null) {
        this.encoding = args.encoding;
      }
      if (args.nullable !== undefined && args.nullable !== null) {
        this.nullable = args.nullable;
      }
      if (args.is_array !== undefined && args.is_array !== null) {
        this.is_array = args.is_array;
      }
      if (args.precision !== undefined && args.precision !== null) {
        this.precision = args.precision;
      }
      if (args.scale !== undefined && args.scale !== null) {
        this.scale = args.scale;
      }
      if (args.comp_param !== undefined && args.comp_param !== null) {
        this.comp_param = args.comp_param;
      }
      if (args.size !== undefined && args.size !== null) {
        this.size = args.size;
      }
      if (args.dict_key !== undefined && args.dict_key !== null) {
        this.dict_key = new ttypes.TStringDictKey(args.dict_key);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.encoding = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.nullable = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.is_array = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.precision = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.scale = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.comp_param = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.size = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.dict_key = new ttypes.TStringDictKey();
          this.dict_key.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTypeInfo');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
      output.writeFieldBegin('encoding', Thrift.Type.I32, 4);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.nullable !== null && this.nullable !== undefined) {
      output.writeFieldBegin('nullable', Thrift.Type.BOOL, 2);
      output.writeBool(this.nullable);
      output.writeFieldEnd();
    }
    if (this.is_array !== null && this.is_array !== undefined) {
      output.writeFieldBegin('is_array', Thrift.Type.BOOL, 3);
      output.writeBool(this.is_array);
      output.writeFieldEnd();
    }
    if (this.precision !== null && this.precision !== undefined) {
      output.writeFieldBegin('precision', Thrift.Type.I32, 5);
      output.writeI32(this.precision);
      output.writeFieldEnd();
    }
    if (this.scale !== null && this.scale !== undefined) {
      output.writeFieldBegin('scale', Thrift.Type.I32, 6);
      output.writeI32(this.scale);
      output.writeFieldEnd();
    }
    if (this.comp_param !== null && this.comp_param !== undefined) {
      output.writeFieldBegin('comp_param', Thrift.Type.I32, 7);
      output.writeI32(this.comp_param);
      output.writeFieldEnd();
    }
    if (this.size !== null && this.size !== undefined) {
      output.writeFieldBegin('size', Thrift.Type.I32, 8);
      output.writeI32(this.size);
      output.writeFieldEnd();
    }
    if (this.dict_key !== null && this.dict_key !== undefined) {
      output.writeFieldBegin('dict_key', Thrift.Type.STRUCT, 9);
      this.dict_key.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 4494:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(7392);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);


const ttypes = module.exports = {};
ttypes.TCompletionHintType = {
  'COLUMN' : 0,
  'TABLE' : 1,
  'VIEW' : 2,
  'SCHEMA' : 3,
  'CATALOG' : 4,
  'REPOSITORY' : 5,
  'FUNCTION' : 6,
  'KEYWORD' : 7
};
const TCompletionHint = module.exports.TCompletionHint = class {
  constructor(args) {
    this.type = null;
    this.hints = null;
    this.replaced = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.hints !== undefined && args.hints !== null) {
        this.hints = Thrift.copyList(args.hints, [null]);
      }
      if (args.replaced !== undefined && args.replaced !== null) {
        this.replaced = args.replaced;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.hints = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readString();
            this.hints.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.replaced = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCompletionHint');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.hints !== null && this.hints !== undefined) {
      output.writeFieldBegin('hints', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.hints.length);
      for (let iter4 in this.hints) {
        if (this.hints.hasOwnProperty(iter4)) {
          iter4 = this.hints[iter4];
          output.writeString(iter4);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.replaced !== null && this.replaced !== undefined) {
      output.writeFieldBegin('replaced', Thrift.Type.STRING, 3);
      output.writeString(this.replaced);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 1396:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(7392);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);


const ttypes = module.exports = {};
ttypes.TExtArgumentType = {
  'Int8' : 0,
  'Int16' : 1,
  'Int32' : 2,
  'Int64' : 3,
  'Float' : 4,
  'Double' : 5,
  'Void' : 6,
  'PInt8' : 7,
  'PInt16' : 8,
  'PInt32' : 9,
  'PInt64' : 10,
  'PFloat' : 11,
  'PDouble' : 12,
  'PBool' : 13,
  'Bool' : 14,
  'ArrayInt8' : 15,
  'ArrayInt16' : 16,
  'ArrayInt32' : 17,
  'ArrayInt64' : 18,
  'ArrayFloat' : 19,
  'ArrayDouble' : 20,
  'ArrayBool' : 21,
  'GeoPoint' : 22,
  'GeoLineString' : 23,
  'Cursor' : 24,
  'GeoPolygon' : 25,
  'GeoMultiPolygon' : 26,
  'ColumnInt8' : 27,
  'ColumnInt16' : 28,
  'ColumnInt32' : 29,
  'ColumnInt64' : 30,
  'ColumnFloat' : 31,
  'ColumnDouble' : 32,
  'ColumnBool' : 33,
  'TextEncodingNone' : 34,
  'TextEncodingDict' : 35,
  'ColumnListInt8' : 36,
  'ColumnListInt16' : 37,
  'ColumnListInt32' : 38,
  'ColumnListInt64' : 39,
  'ColumnListFloat' : 40,
  'ColumnListDouble' : 41,
  'ColumnListBool' : 42,
  'ColumnTextEncodingDict' : 43,
  'ColumnListTextEncodingDict' : 44,
  'ColumnTimestamp' : 45,
  'Timestamp' : 46,
  'ColumnArrayInt8' : 47,
  'ColumnArrayInt16' : 48,
  'ColumnArrayInt32' : 49,
  'ColumnArrayInt64' : 50,
  'ColumnArrayFloat' : 51,
  'ColumnArrayDouble' : 52,
  'ColumnArrayBool' : 53,
  'ColumnListArrayInt8' : 54,
  'ColumnListArrayInt16' : 55,
  'ColumnListArrayInt32' : 56,
  'ColumnListArrayInt64' : 57,
  'ColumnListArrayFloat' : 58,
  'ColumnListArrayDouble' : 59,
  'ColumnListArrayBool' : 60,
  'GeoMultiLineString' : 61,
  'ArrayTextEncodingNone' : 62,
  'ColumnTextEncodingNone' : 63,
  'ColumnListTextEncodingNone' : 64,
  'ColumnArrayTextEncodingNone' : 65,
  'ColumnListArrayTextEncodingNone' : 66,
  'ArrayTextEncodingDict' : 67,
  'ColumnArrayTextEncodingDict' : 68,
  'ColumnListArrayTextEncodingDict' : 69,
  'GeoMultiPoint' : 70,
  'DayTimeInterval' : 71,
  'YearMonthTimeInterval' : 72,
  'ColumnGeoPoint' : 73,
  'ColumnGeoLineString' : 74,
  'ColumnGeoPolygon' : 75,
  'ColumnGeoMultiPoint' : 76,
  'ColumnGeoMultiLineString' : 77,
  'ColumnGeoMultiPolygon' : 78,
  'ColumnListGeoPoint' : 79,
  'ColumnListGeoLineString' : 80,
  'ColumnListGeoPolygon' : 81,
  'ColumnListGeoMultiPoint' : 82,
  'ColumnListGeoMultiLineString' : 83,
  'ColumnListGeoMultiPolygon' : 84
};
ttypes.TOutputBufferSizeType = {
  'kConstant' : 0,
  'kUserSpecifiedConstantParameter' : 1,
  'kUserSpecifiedRowMultiplier' : 2,
  'kTableFunctionSpecifiedParameter' : 3,
  'kPreFlightParameter' : 4
};
const TUserDefinedFunction = module.exports.TUserDefinedFunction = class {
  constructor(args) {
    this.name = null;
    this.argTypes = null;
    this.retType = null;
    this.annotations = null;
    if (args) {
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.argTypes !== undefined && args.argTypes !== null) {
        this.argTypes = Thrift.copyList(args.argTypes, [null]);
      }
      if (args.retType !== undefined && args.retType !== null) {
        this.retType = args.retType;
      }
      if (args.annotations !== undefined && args.annotations !== null) {
        this.annotations = Thrift.copyList(args.annotations, [Thrift.copyMap, null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.argTypes = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readI32();
            this.argTypes.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.retType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.annotations = [];
          const _rtmp35 = input.readListBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = {};
            const _rtmp39 = input.readMapBegin();
            const _size8 = _rtmp39.size || 0;
            for (let _i10 = 0; _i10 < _size8; ++_i10) {
              let key11 = null;
              let val12 = null;
              key11 = input.readString();
              val12 = input.readString();
              elem7[key11] = val12;
            }
            input.readMapEnd();
            this.annotations.push(elem7);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TUserDefinedFunction');
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 1);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.argTypes !== null && this.argTypes !== undefined) {
      output.writeFieldBegin('argTypes', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.argTypes.length);
      for (let iter13 in this.argTypes) {
        if (this.argTypes.hasOwnProperty(iter13)) {
          iter13 = this.argTypes[iter13];
          output.writeI32(iter13);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.retType !== null && this.retType !== undefined) {
      output.writeFieldBegin('retType', Thrift.Type.I32, 3);
      output.writeI32(this.retType);
      output.writeFieldEnd();
    }
    if (this.annotations !== null && this.annotations !== undefined) {
      output.writeFieldBegin('annotations', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.MAP, this.annotations.length);
      for (let iter14 in this.annotations) {
        if (this.annotations.hasOwnProperty(iter14)) {
          iter14 = this.annotations[iter14];
          output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(iter14));
          for (let kiter15 in iter14) {
            if (iter14.hasOwnProperty(kiter15)) {
              let viter16 = iter14[kiter15];
              output.writeString(kiter15);
              output.writeString(viter16);
            }
          }
          output.writeMapEnd();
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TUserDefinedTableFunction = module.exports.TUserDefinedTableFunction = class {
  constructor(args) {
    this.name = null;
    this.sizerType = null;
    this.sizerArgPos = null;
    this.inputArgTypes = null;
    this.outputArgTypes = null;
    this.sqlArgTypes = null;
    this.annotations = null;
    if (args) {
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.sizerType !== undefined && args.sizerType !== null) {
        this.sizerType = args.sizerType;
      }
      if (args.sizerArgPos !== undefined && args.sizerArgPos !== null) {
        this.sizerArgPos = args.sizerArgPos;
      }
      if (args.inputArgTypes !== undefined && args.inputArgTypes !== null) {
        this.inputArgTypes = Thrift.copyList(args.inputArgTypes, [null]);
      }
      if (args.outputArgTypes !== undefined && args.outputArgTypes !== null) {
        this.outputArgTypes = Thrift.copyList(args.outputArgTypes, [null]);
      }
      if (args.sqlArgTypes !== undefined && args.sqlArgTypes !== null) {
        this.sqlArgTypes = Thrift.copyList(args.sqlArgTypes, [null]);
      }
      if (args.annotations !== undefined && args.annotations !== null) {
        this.annotations = Thrift.copyList(args.annotations, [Thrift.copyMap, null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.sizerType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.sizerArgPos = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.inputArgTypes = [];
          const _rtmp318 = input.readListBegin();
          const _size17 = _rtmp318.size || 0;
          for (let _i19 = 0; _i19 < _size17; ++_i19) {
            let elem20 = null;
            elem20 = input.readI32();
            this.inputArgTypes.push(elem20);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.outputArgTypes = [];
          const _rtmp322 = input.readListBegin();
          const _size21 = _rtmp322.size || 0;
          for (let _i23 = 0; _i23 < _size21; ++_i23) {
            let elem24 = null;
            elem24 = input.readI32();
            this.outputArgTypes.push(elem24);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.sqlArgTypes = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = input.readI32();
            this.sqlArgTypes.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.annotations = [];
          const _rtmp330 = input.readListBegin();
          const _size29 = _rtmp330.size || 0;
          for (let _i31 = 0; _i31 < _size29; ++_i31) {
            let elem32 = null;
            elem32 = {};
            const _rtmp334 = input.readMapBegin();
            const _size33 = _rtmp334.size || 0;
            for (let _i35 = 0; _i35 < _size33; ++_i35) {
              let key36 = null;
              let val37 = null;
              key36 = input.readString();
              val37 = input.readString();
              elem32[key36] = val37;
            }
            input.readMapEnd();
            this.annotations.push(elem32);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TUserDefinedTableFunction');
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 1);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.sizerType !== null && this.sizerType !== undefined) {
      output.writeFieldBegin('sizerType', Thrift.Type.I32, 2);
      output.writeI32(this.sizerType);
      output.writeFieldEnd();
    }
    if (this.sizerArgPos !== null && this.sizerArgPos !== undefined) {
      output.writeFieldBegin('sizerArgPos', Thrift.Type.I32, 3);
      output.writeI32(this.sizerArgPos);
      output.writeFieldEnd();
    }
    if (this.inputArgTypes !== null && this.inputArgTypes !== undefined) {
      output.writeFieldBegin('inputArgTypes', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.I32, this.inputArgTypes.length);
      for (let iter38 in this.inputArgTypes) {
        if (this.inputArgTypes.hasOwnProperty(iter38)) {
          iter38 = this.inputArgTypes[iter38];
          output.writeI32(iter38);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.outputArgTypes !== null && this.outputArgTypes !== undefined) {
      output.writeFieldBegin('outputArgTypes', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.I32, this.outputArgTypes.length);
      for (let iter39 in this.outputArgTypes) {
        if (this.outputArgTypes.hasOwnProperty(iter39)) {
          iter39 = this.outputArgTypes[iter39];
          output.writeI32(iter39);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.sqlArgTypes !== null && this.sqlArgTypes !== undefined) {
      output.writeFieldBegin('sqlArgTypes', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.I32, this.sqlArgTypes.length);
      for (let iter40 in this.sqlArgTypes) {
        if (this.sqlArgTypes.hasOwnProperty(iter40)) {
          iter40 = this.sqlArgTypes[iter40];
          output.writeI32(iter40);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.annotations !== null && this.annotations !== undefined) {
      output.writeFieldBegin('annotations', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.MAP, this.annotations.length);
      for (let iter41 in this.annotations) {
        if (this.annotations.hasOwnProperty(iter41)) {
          iter41 = this.annotations[iter41];
          output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(iter41));
          for (let kiter42 in iter41) {
            if (iter41.hasOwnProperty(kiter42)) {
              let viter43 = iter41[kiter42];
              output.writeString(kiter42);
              output.writeString(viter43);
            }
          }
          output.writeMapEnd();
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 2607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(7392);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);

const common_ttypes = __webpack_require__(2818);
const completion_hints_ttypes = __webpack_require__(4494);
const serialized_result_set_ttypes = __webpack_require__(3962);
const extension_functions_ttypes = __webpack_require__(1396);


const ttypes = module.exports = {};
ttypes.TExecuteMode = {
  'GPU' : 1,
  'CPU' : 2
};
ttypes.TSourceType = {
  'DELIMITED_FILE' : 0,
  'GEO_FILE' : 1,
  'PARQUET_FILE' : 2,
  'RASTER_FILE' : 3,
  'ODBC' : 4
};
ttypes.TPartitionDetail = {
  'DEFAULT' : 0,
  'REPLICATED' : 1,
  'SHARDED' : 2,
  'OTHER' : 3
};
ttypes.TGeoFileLayerContents = {
  'EMPTY' : 0,
  'GEO' : 1,
  'NON_GEO' : 2,
  'UNSUPPORTED_GEO' : 3
};
ttypes.TImportHeaderRow = {
  'AUTODETECT' : 0,
  'NO_HEADER' : 1,
  'HAS_HEADER' : 2
};
ttypes.TRole = {
  'SERVER' : 0,
  'AGGREGATOR' : 1,
  'LEAF' : 2,
  'STRING_DICTIONARY' : 3
};
ttypes.TTableType = {
  'DEFAULT' : 0,
  'TEMPORARY' : 1,
  'FOREIGN' : 2,
  'VIEW' : 3
};
ttypes.TTableRefreshUpdateType = {
  'ALL' : 0,
  'APPEND' : 1
};
ttypes.TTableRefreshTimingType = {
  'MANUAL' : 0,
  'SCHEDULED' : 1
};
ttypes.TTableRefreshIntervalType = {
  'NONE' : 0,
  'HOUR' : 1,
  'DAY' : 2
};
ttypes.TMergeType = {
  'UNION' : 0,
  'REDUCE' : 1
};
ttypes.TRasterPointType = {
  'NONE' : 0,
  'AUTO' : 1,
  'SMALLINT' : 2,
  'INT' : 3,
  'FLOAT' : 4,
  'DOUBLE' : 5,
  'POINT' : 6
};
ttypes.TRasterPointTransform = {
  'NONE' : 0,
  'AUTO' : 1,
  'FILE' : 2,
  'WORLD' : 3
};
ttypes.TQueryType = {
  'UNKNOWN' : 0,
  'READ' : 1,
  'WRITE' : 2,
  'SCHEMA_READ' : 3,
  'SCHEMA_WRITE' : 4
};
ttypes.TArrowTransport = {
  'SHARED_MEMORY' : 0,
  'WIRE' : 1
};
ttypes.TExpressionRangeType = {
  'INVALID' : 0,
  'INTEGER' : 1,
  'FLOAT' : 2,
  'DOUBLE' : 3
};
ttypes.TDBObjectType = {
  'AbstractDBObjectType' : 0,
  'DatabaseDBObjectType' : 1,
  'TableDBObjectType' : 2,
  'DashboardDBObjectType' : 3,
  'ViewDBObjectType' : 4,
  'ServerDBObjectType' : 5
};
ttypes.TDataSourceType = {
  'TABLE' : 0
};
const TDatumVal = module.exports.TDatumVal = class {
  constructor(args) {
    this.int_val = null;
    this.real_val = null;
    this.str_val = null;
    this.arr_val = null;
    if (args) {
      if (args.int_val !== undefined && args.int_val !== null) {
        this.int_val = args.int_val;
      }
      if (args.real_val !== undefined && args.real_val !== null) {
        this.real_val = args.real_val;
      }
      if (args.str_val !== undefined && args.str_val !== null) {
        this.str_val = args.str_val;
      }
      if (args.arr_val !== undefined && args.arr_val !== null) {
        this.arr_val = Thrift.copyList(args.arr_val, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.int_val = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.DOUBLE) {
          this.real_val = input.readDouble();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.str_val = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.arr_val = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new ttypes.TDatum();
            elem3.read(input);
            this.arr_val.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDatumVal');
    if (this.int_val !== null && this.int_val !== undefined) {
      output.writeFieldBegin('int_val', Thrift.Type.I64, 1);
      output.writeI64(this.int_val);
      output.writeFieldEnd();
    }
    if (this.real_val !== null && this.real_val !== undefined) {
      output.writeFieldBegin('real_val', Thrift.Type.DOUBLE, 2);
      output.writeDouble(this.real_val);
      output.writeFieldEnd();
    }
    if (this.str_val !== null && this.str_val !== undefined) {
      output.writeFieldBegin('str_val', Thrift.Type.STRING, 3);
      output.writeString(this.str_val);
      output.writeFieldEnd();
    }
    if (this.arr_val !== null && this.arr_val !== undefined) {
      output.writeFieldBegin('arr_val', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.arr_val.length);
      for (let iter4 in this.arr_val) {
        if (this.arr_val.hasOwnProperty(iter4)) {
          iter4 = this.arr_val[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDatum = module.exports.TDatum = class {
  constructor(args) {
    this.val = null;
    this.is_null = null;
    if (args) {
      if (args.val !== undefined && args.val !== null) {
        this.val = new ttypes.TDatumVal(args.val);
      }
      if (args.is_null !== undefined && args.is_null !== null) {
        this.is_null = args.is_null;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.val = new ttypes.TDatumVal();
          this.val.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.is_null = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDatum');
    if (this.val !== null && this.val !== undefined) {
      output.writeFieldBegin('val', Thrift.Type.STRUCT, 1);
      this.val.write(output);
      output.writeFieldEnd();
    }
    if (this.is_null !== null && this.is_null !== undefined) {
      output.writeFieldBegin('is_null', Thrift.Type.BOOL, 2);
      output.writeBool(this.is_null);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TStringValue = module.exports.TStringValue = class {
  constructor(args) {
    this.str_val = null;
    this.is_null = null;
    if (args) {
      if (args.str_val !== undefined && args.str_val !== null) {
        this.str_val = args.str_val;
      }
      if (args.is_null !== undefined && args.is_null !== null) {
        this.is_null = args.is_null;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.str_val = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.is_null = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TStringValue');
    if (this.str_val !== null && this.str_val !== undefined) {
      output.writeFieldBegin('str_val', Thrift.Type.STRING, 1);
      output.writeString(this.str_val);
      output.writeFieldEnd();
    }
    if (this.is_null !== null && this.is_null !== undefined) {
      output.writeFieldBegin('is_null', Thrift.Type.BOOL, 2);
      output.writeBool(this.is_null);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColumnType = module.exports.TColumnType = class {
  constructor(args) {
    this.col_name = null;
    this.col_type = null;
    this.is_reserved_keyword = null;
    this.src_name = null;
    this.is_system = null;
    this.is_physical = null;
    this.col_id = null;
    this.default_value = null;
    if (args) {
      if (args.col_name !== undefined && args.col_name !== null) {
        this.col_name = args.col_name;
      }
      if (args.col_type !== undefined && args.col_type !== null) {
        this.col_type = new common_ttypes.TTypeInfo(args.col_type);
      }
      if (args.is_reserved_keyword !== undefined && args.is_reserved_keyword !== null) {
        this.is_reserved_keyword = args.is_reserved_keyword;
      }
      if (args.src_name !== undefined && args.src_name !== null) {
        this.src_name = args.src_name;
      }
      if (args.is_system !== undefined && args.is_system !== null) {
        this.is_system = args.is_system;
      }
      if (args.is_physical !== undefined && args.is_physical !== null) {
        this.is_physical = args.is_physical;
      }
      if (args.col_id !== undefined && args.col_id !== null) {
        this.col_id = args.col_id;
      }
      if (args.default_value !== undefined && args.default_value !== null) {
        this.default_value = args.default_value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.col_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.col_type = new common_ttypes.TTypeInfo();
          this.col_type.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.is_reserved_keyword = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.src_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.is_system = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.is_physical = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.col_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.default_value = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColumnType');
    if (this.col_name !== null && this.col_name !== undefined) {
      output.writeFieldBegin('col_name', Thrift.Type.STRING, 1);
      output.writeString(this.col_name);
      output.writeFieldEnd();
    }
    if (this.col_type !== null && this.col_type !== undefined) {
      output.writeFieldBegin('col_type', Thrift.Type.STRUCT, 2);
      this.col_type.write(output);
      output.writeFieldEnd();
    }
    if (this.is_reserved_keyword !== null && this.is_reserved_keyword !== undefined) {
      output.writeFieldBegin('is_reserved_keyword', Thrift.Type.BOOL, 3);
      output.writeBool(this.is_reserved_keyword);
      output.writeFieldEnd();
    }
    if (this.src_name !== null && this.src_name !== undefined) {
      output.writeFieldBegin('src_name', Thrift.Type.STRING, 4);
      output.writeString(this.src_name);
      output.writeFieldEnd();
    }
    if (this.is_system !== null && this.is_system !== undefined) {
      output.writeFieldBegin('is_system', Thrift.Type.BOOL, 5);
      output.writeBool(this.is_system);
      output.writeFieldEnd();
    }
    if (this.is_physical !== null && this.is_physical !== undefined) {
      output.writeFieldBegin('is_physical', Thrift.Type.BOOL, 6);
      output.writeBool(this.is_physical);
      output.writeFieldEnd();
    }
    if (this.col_id !== null && this.col_id !== undefined) {
      output.writeFieldBegin('col_id', Thrift.Type.I64, 7);
      output.writeI64(this.col_id);
      output.writeFieldEnd();
    }
    if (this.default_value !== null && this.default_value !== undefined) {
      output.writeFieldBegin('default_value', Thrift.Type.STRING, 8);
      output.writeString(this.default_value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRow = module.exports.TRow = class {
  constructor(args) {
    this.cols = null;
    if (args) {
      if (args.cols !== undefined && args.cols !== null) {
        this.cols = Thrift.copyList(args.cols, [ttypes.TDatum]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.cols = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new ttypes.TDatum();
            elem8.read(input);
            this.cols.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRow');
    if (this.cols !== null && this.cols !== undefined) {
      output.writeFieldBegin('cols', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.cols.length);
      for (let iter9 in this.cols) {
        if (this.cols.hasOwnProperty(iter9)) {
          iter9 = this.cols[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColumnData = module.exports.TColumnData = class {
  constructor(args) {
    this.int_col = null;
    this.real_col = null;
    this.str_col = null;
    this.arr_col = null;
    if (args) {
      if (args.int_col !== undefined && args.int_col !== null) {
        this.int_col = Thrift.copyList(args.int_col, [null]);
      }
      if (args.real_col !== undefined && args.real_col !== null) {
        this.real_col = Thrift.copyList(args.real_col, [null]);
      }
      if (args.str_col !== undefined && args.str_col !== null) {
        this.str_col = Thrift.copyList(args.str_col, [null]);
      }
      if (args.arr_col !== undefined && args.arr_col !== null) {
        this.arr_col = Thrift.copyList(args.arr_col, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.int_col = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = input.readI64();
            this.int_col.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.real_col = [];
          const _rtmp315 = input.readListBegin();
          const _size14 = _rtmp315.size || 0;
          for (let _i16 = 0; _i16 < _size14; ++_i16) {
            let elem17 = null;
            elem17 = input.readDouble();
            this.real_col.push(elem17);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.str_col = [];
          const _rtmp319 = input.readListBegin();
          const _size18 = _rtmp319.size || 0;
          for (let _i20 = 0; _i20 < _size18; ++_i20) {
            let elem21 = null;
            elem21 = input.readString();
            this.str_col.push(elem21);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.arr_col = [];
          const _rtmp323 = input.readListBegin();
          const _size22 = _rtmp323.size || 0;
          for (let _i24 = 0; _i24 < _size22; ++_i24) {
            let elem25 = null;
            elem25 = new ttypes.TColumn();
            elem25.read(input);
            this.arr_col.push(elem25);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColumnData');
    if (this.int_col !== null && this.int_col !== undefined) {
      output.writeFieldBegin('int_col', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.I64, this.int_col.length);
      for (let iter26 in this.int_col) {
        if (this.int_col.hasOwnProperty(iter26)) {
          iter26 = this.int_col[iter26];
          output.writeI64(iter26);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.real_col !== null && this.real_col !== undefined) {
      output.writeFieldBegin('real_col', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.DOUBLE, this.real_col.length);
      for (let iter27 in this.real_col) {
        if (this.real_col.hasOwnProperty(iter27)) {
          iter27 = this.real_col[iter27];
          output.writeDouble(iter27);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.str_col !== null && this.str_col !== undefined) {
      output.writeFieldBegin('str_col', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.str_col.length);
      for (let iter28 in this.str_col) {
        if (this.str_col.hasOwnProperty(iter28)) {
          iter28 = this.str_col[iter28];
          output.writeString(iter28);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.arr_col !== null && this.arr_col !== undefined) {
      output.writeFieldBegin('arr_col', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.arr_col.length);
      for (let iter29 in this.arr_col) {
        if (this.arr_col.hasOwnProperty(iter29)) {
          iter29 = this.arr_col[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColumn = module.exports.TColumn = class {
  constructor(args) {
    this.data = null;
    this.nulls = null;
    if (args) {
      if (args.data !== undefined && args.data !== null) {
        this.data = new ttypes.TColumnData(args.data);
      }
      if (args.nulls !== undefined && args.nulls !== null) {
        this.nulls = Thrift.copyList(args.nulls, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.data = new ttypes.TColumnData();
          this.data.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.nulls = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = input.readBool();
            this.nulls.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColumn');
    if (this.data !== null && this.data !== undefined) {
      output.writeFieldBegin('data', Thrift.Type.STRUCT, 1);
      this.data.write(output);
      output.writeFieldEnd();
    }
    if (this.nulls !== null && this.nulls !== undefined) {
      output.writeFieldBegin('nulls', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.BOOL, this.nulls.length);
      for (let iter34 in this.nulls) {
        if (this.nulls.hasOwnProperty(iter34)) {
          iter34 = this.nulls[iter34];
          output.writeBool(iter34);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TStringRow = module.exports.TStringRow = class {
  constructor(args) {
    this.cols = null;
    if (args) {
      if (args.cols !== undefined && args.cols !== null) {
        this.cols = Thrift.copyList(args.cols, [ttypes.TStringValue]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.cols = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new ttypes.TStringValue();
            elem38.read(input);
            this.cols.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TStringRow');
    if (this.cols !== null && this.cols !== undefined) {
      output.writeFieldBegin('cols', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.cols.length);
      for (let iter39 in this.cols) {
        if (this.cols.hasOwnProperty(iter39)) {
          iter39 = this.cols[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TKrb5Session = module.exports.TKrb5Session = class {
  constructor(args) {
    this.sessionId = null;
    this.krbToken = null;
    if (args) {
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
      if (args.krbToken !== undefined && args.krbToken !== null) {
        this.krbToken = args.krbToken;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.krbToken = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TKrb5Session');
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 1);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    if (this.krbToken !== null && this.krbToken !== undefined) {
      output.writeFieldBegin('krbToken', Thrift.Type.STRING, 2);
      output.writeString(this.krbToken);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TStepResult = module.exports.TStepResult = class {
  constructor(args) {
    this.serialized_rows = null;
    this.execution_finished = null;
    this.merge_type = null;
    this.sharded = null;
    this.row_desc = null;
    this.node_id = null;
    if (args) {
      if (args.serialized_rows !== undefined && args.serialized_rows !== null) {
        this.serialized_rows = new serialized_result_set_ttypes.TSerializedRows(args.serialized_rows);
      }
      if (args.execution_finished !== undefined && args.execution_finished !== null) {
        this.execution_finished = args.execution_finished;
      }
      if (args.merge_type !== undefined && args.merge_type !== null) {
        this.merge_type = args.merge_type;
      }
      if (args.sharded !== undefined && args.sharded !== null) {
        this.sharded = args.sharded;
      }
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.node_id !== undefined && args.node_id !== null) {
        this.node_id = args.node_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.serialized_rows = new serialized_result_set_ttypes.TSerializedRows();
          this.serialized_rows.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.execution_finished = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.merge_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.sharded = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp341 = input.readListBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            let elem43 = null;
            elem43 = new ttypes.TColumnType();
            elem43.read(input);
            this.row_desc.push(elem43);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.node_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TStepResult');
    if (this.serialized_rows !== null && this.serialized_rows !== undefined) {
      output.writeFieldBegin('serialized_rows', Thrift.Type.STRUCT, 1);
      this.serialized_rows.write(output);
      output.writeFieldEnd();
    }
    if (this.execution_finished !== null && this.execution_finished !== undefined) {
      output.writeFieldBegin('execution_finished', Thrift.Type.BOOL, 2);
      output.writeBool(this.execution_finished);
      output.writeFieldEnd();
    }
    if (this.merge_type !== null && this.merge_type !== undefined) {
      output.writeFieldBegin('merge_type', Thrift.Type.I32, 3);
      output.writeI32(this.merge_type);
      output.writeFieldEnd();
    }
    if (this.sharded !== null && this.sharded !== undefined) {
      output.writeFieldBegin('sharded', Thrift.Type.BOOL, 4);
      output.writeBool(this.sharded);
      output.writeFieldEnd();
    }
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter44 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter44)) {
          iter44 = this.row_desc[iter44];
          iter44.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.node_id !== null && this.node_id !== undefined) {
      output.writeFieldBegin('node_id', Thrift.Type.I32, 6);
      output.writeI32(this.node_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRowSet = module.exports.TRowSet = class {
  constructor(args) {
    this.row_desc = null;
    this.rows = null;
    this.columns = null;
    this.is_columnar = null;
    if (args) {
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.rows !== undefined && args.rows !== null) {
        this.rows = Thrift.copyList(args.rows, [ttypes.TRow]);
      }
      if (args.columns !== undefined && args.columns !== null) {
        this.columns = Thrift.copyList(args.columns, [ttypes.TColumn]);
      }
      if (args.is_columnar !== undefined && args.is_columnar !== null) {
        this.is_columnar = args.is_columnar;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp346 = input.readListBegin();
          const _size45 = _rtmp346.size || 0;
          for (let _i47 = 0; _i47 < _size45; ++_i47) {
            let elem48 = null;
            elem48 = new ttypes.TColumnType();
            elem48.read(input);
            this.row_desc.push(elem48);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.rows = [];
          const _rtmp350 = input.readListBegin();
          const _size49 = _rtmp350.size || 0;
          for (let _i51 = 0; _i51 < _size49; ++_i51) {
            let elem52 = null;
            elem52 = new ttypes.TRow();
            elem52.read(input);
            this.rows.push(elem52);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.columns = [];
          const _rtmp354 = input.readListBegin();
          const _size53 = _rtmp354.size || 0;
          for (let _i55 = 0; _i55 < _size53; ++_i55) {
            let elem56 = null;
            elem56 = new ttypes.TColumn();
            elem56.read(input);
            this.columns.push(elem56);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.is_columnar = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRowSet');
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter57 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter57)) {
          iter57 = this.row_desc[iter57];
          iter57.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.rows !== null && this.rows !== undefined) {
      output.writeFieldBegin('rows', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.rows.length);
      for (let iter58 in this.rows) {
        if (this.rows.hasOwnProperty(iter58)) {
          iter58 = this.rows[iter58];
          iter58.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.columns !== null && this.columns !== undefined) {
      output.writeFieldBegin('columns', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
      for (let iter59 in this.columns) {
        if (this.columns.hasOwnProperty(iter59)) {
          iter59 = this.columns[iter59];
          iter59.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.is_columnar !== null && this.is_columnar !== undefined) {
      output.writeFieldBegin('is_columnar', Thrift.Type.BOOL, 4);
      output.writeBool(this.is_columnar);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TQueryResult = module.exports.TQueryResult = class {
  constructor(args) {
    this.row_set = null;
    this.execution_time_ms = null;
    this.total_time_ms = null;
    this.nonce = null;
    this.debug = null;
    this.success = true;
    this.query_type = 0;
    if (args) {
      if (args.row_set !== undefined && args.row_set !== null) {
        this.row_set = new ttypes.TRowSet(args.row_set);
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.total_time_ms !== undefined && args.total_time_ms !== null) {
        this.total_time_ms = args.total_time_ms;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
      if (args.debug !== undefined && args.debug !== null) {
        this.debug = args.debug;
      }
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.query_type !== undefined && args.query_type !== null) {
        this.query_type = args.query_type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.row_set = new ttypes.TRowSet();
          this.row_set.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.total_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.debug = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.query_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TQueryResult');
    if (this.row_set !== null && this.row_set !== undefined) {
      output.writeFieldBegin('row_set', Thrift.Type.STRUCT, 1);
      this.row_set.write(output);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 2);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.total_time_ms !== null && this.total_time_ms !== undefined) {
      output.writeFieldBegin('total_time_ms', Thrift.Type.I64, 3);
      output.writeI64(this.total_time_ms);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 4);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    if (this.debug !== null && this.debug !== undefined) {
      output.writeFieldBegin('debug', Thrift.Type.STRING, 5);
      output.writeString(this.debug);
      output.writeFieldEnd();
    }
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 6);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.query_type !== null && this.query_type !== undefined) {
      output.writeFieldBegin('query_type', Thrift.Type.I32, 7);
      output.writeI32(this.query_type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDataFrame = module.exports.TDataFrame = class {
  constructor(args) {
    this.sm_handle = null;
    this.sm_size = null;
    this.df_handle = null;
    this.df_size = null;
    this.execution_time_ms = null;
    this.arrow_conversion_time_ms = null;
    this.df_buffer = null;
    if (args) {
      if (args.sm_handle !== undefined && args.sm_handle !== null) {
        this.sm_handle = args.sm_handle;
      }
      if (args.sm_size !== undefined && args.sm_size !== null) {
        this.sm_size = args.sm_size;
      }
      if (args.df_handle !== undefined && args.df_handle !== null) {
        this.df_handle = args.df_handle;
      }
      if (args.df_size !== undefined && args.df_size !== null) {
        this.df_size = args.df_size;
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.arrow_conversion_time_ms !== undefined && args.arrow_conversion_time_ms !== null) {
        this.arrow_conversion_time_ms = args.arrow_conversion_time_ms;
      }
      if (args.df_buffer !== undefined && args.df_buffer !== null) {
        this.df_buffer = args.df_buffer;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.sm_handle = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.sm_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.df_handle = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.df_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.arrow_conversion_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.df_buffer = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDataFrame');
    if (this.sm_handle !== null && this.sm_handle !== undefined) {
      output.writeFieldBegin('sm_handle', Thrift.Type.STRING, 1);
      output.writeBinary(this.sm_handle);
      output.writeFieldEnd();
    }
    if (this.sm_size !== null && this.sm_size !== undefined) {
      output.writeFieldBegin('sm_size', Thrift.Type.I64, 2);
      output.writeI64(this.sm_size);
      output.writeFieldEnd();
    }
    if (this.df_handle !== null && this.df_handle !== undefined) {
      output.writeFieldBegin('df_handle', Thrift.Type.STRING, 3);
      output.writeBinary(this.df_handle);
      output.writeFieldEnd();
    }
    if (this.df_size !== null && this.df_size !== undefined) {
      output.writeFieldBegin('df_size', Thrift.Type.I64, 4);
      output.writeI64(this.df_size);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 5);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.arrow_conversion_time_ms !== null && this.arrow_conversion_time_ms !== undefined) {
      output.writeFieldBegin('arrow_conversion_time_ms', Thrift.Type.I64, 6);
      output.writeI64(this.arrow_conversion_time_ms);
      output.writeFieldEnd();
    }
    if (this.df_buffer !== null && this.df_buffer !== undefined) {
      output.writeFieldBegin('df_buffer', Thrift.Type.STRING, 7);
      output.writeBinary(this.df_buffer);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDBInfo = module.exports.TDBInfo = class {
  constructor(args) {
    this.db_name = null;
    this.db_owner = null;
    if (args) {
      if (args.db_name !== undefined && args.db_name !== null) {
        this.db_name = args.db_name;
      }
      if (args.db_owner !== undefined && args.db_owner !== null) {
        this.db_owner = args.db_owner;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.db_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.db_owner = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDBInfo');
    if (this.db_name !== null && this.db_name !== undefined) {
      output.writeFieldBegin('db_name', Thrift.Type.STRING, 1);
      output.writeString(this.db_name);
      output.writeFieldEnd();
    }
    if (this.db_owner !== null && this.db_owner !== undefined) {
      output.writeFieldBegin('db_owner', Thrift.Type.STRING, 2);
      output.writeString(this.db_owner);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDBException = module.exports.TDBException = class extends Thrift.TException {
  constructor(args) {
    super(args);
    this.name = "TDBException";
    this.error_msg = null;
    if (args) {
      if (args.error_msg !== undefined && args.error_msg !== null) {
        this.error_msg = args.error_msg;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.error_msg = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDBException');
    if (this.error_msg !== null && this.error_msg !== undefined) {
      output.writeFieldBegin('error_msg', Thrift.Type.STRING, 1);
      output.writeString(this.error_msg);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCopyParams = module.exports.TCopyParams = class {
  constructor(args) {
    this.delimiter = null;
    this.null_str = null;
    this.has_header = 0;
    this.quoted = null;
    this.quote = null;
    this.escape = null;
    this.line_delim = null;
    this.array_delim = null;
    this.array_begin = null;
    this.array_end = null;
    this.threads = null;
    this.source_type = 0;
    this.s3_access_key = null;
    this.s3_secret_key = null;
    this.s3_region = null;
    this.geo_coords_encoding = 6;
    this.geo_coords_comp_param = 32;
    this.geo_coords_type = 18;
    this.geo_coords_srid = 4326;
    this.sanitize_column_names = true;
    this.geo_layer_name = null;
    this.s3_endpoint = null;
    this.geo_assign_render_groups = false;
    this.geo_explode_collections = false;
    this.source_srid = 0;
    this.s3_session_token = null;
    this.raster_point_type = 1;
    this.raster_import_bands = null;
    this.raster_scanlines_per_thread = null;
    this.raster_point_transform = 1;
    this.raster_point_compute_angle = false;
    this.raster_import_dimensions = null;
    this.odbc_dsn = null;
    this.odbc_connection_string = null;
    this.odbc_sql_select = null;
    this.odbc_sql_order_by = null;
    this.odbc_username = null;
    this.odbc_password = null;
    this.odbc_credential_string = null;
    this.add_metadata_columns = null;
    this.trim_spaces = true;
    this.geo_validate_geometry = false;
    if (args) {
      if (args.delimiter !== undefined && args.delimiter !== null) {
        this.delimiter = args.delimiter;
      }
      if (args.null_str !== undefined && args.null_str !== null) {
        this.null_str = args.null_str;
      }
      if (args.has_header !== undefined && args.has_header !== null) {
        this.has_header = args.has_header;
      }
      if (args.quoted !== undefined && args.quoted !== null) {
        this.quoted = args.quoted;
      }
      if (args.quote !== undefined && args.quote !== null) {
        this.quote = args.quote;
      }
      if (args.escape !== undefined && args.escape !== null) {
        this.escape = args.escape;
      }
      if (args.line_delim !== undefined && args.line_delim !== null) {
        this.line_delim = args.line_delim;
      }
      if (args.array_delim !== undefined && args.array_delim !== null) {
        this.array_delim = args.array_delim;
      }
      if (args.array_begin !== undefined && args.array_begin !== null) {
        this.array_begin = args.array_begin;
      }
      if (args.array_end !== undefined && args.array_end !== null) {
        this.array_end = args.array_end;
      }
      if (args.threads !== undefined && args.threads !== null) {
        this.threads = args.threads;
      }
      if (args.source_type !== undefined && args.source_type !== null) {
        this.source_type = args.source_type;
      }
      if (args.s3_access_key !== undefined && args.s3_access_key !== null) {
        this.s3_access_key = args.s3_access_key;
      }
      if (args.s3_secret_key !== undefined && args.s3_secret_key !== null) {
        this.s3_secret_key = args.s3_secret_key;
      }
      if (args.s3_region !== undefined && args.s3_region !== null) {
        this.s3_region = args.s3_region;
      }
      if (args.geo_coords_encoding !== undefined && args.geo_coords_encoding !== null) {
        this.geo_coords_encoding = args.geo_coords_encoding;
      }
      if (args.geo_coords_comp_param !== undefined && args.geo_coords_comp_param !== null) {
        this.geo_coords_comp_param = args.geo_coords_comp_param;
      }
      if (args.geo_coords_type !== undefined && args.geo_coords_type !== null) {
        this.geo_coords_type = args.geo_coords_type;
      }
      if (args.geo_coords_srid !== undefined && args.geo_coords_srid !== null) {
        this.geo_coords_srid = args.geo_coords_srid;
      }
      if (args.sanitize_column_names !== undefined && args.sanitize_column_names !== null) {
        this.sanitize_column_names = args.sanitize_column_names;
      }
      if (args.geo_layer_name !== undefined && args.geo_layer_name !== null) {
        this.geo_layer_name = args.geo_layer_name;
      }
      if (args.s3_endpoint !== undefined && args.s3_endpoint !== null) {
        this.s3_endpoint = args.s3_endpoint;
      }
      if (args.geo_assign_render_groups !== undefined && args.geo_assign_render_groups !== null) {
        this.geo_assign_render_groups = args.geo_assign_render_groups;
      }
      if (args.geo_explode_collections !== undefined && args.geo_explode_collections !== null) {
        this.geo_explode_collections = args.geo_explode_collections;
      }
      if (args.source_srid !== undefined && args.source_srid !== null) {
        this.source_srid = args.source_srid;
      }
      if (args.s3_session_token !== undefined && args.s3_session_token !== null) {
        this.s3_session_token = args.s3_session_token;
      }
      if (args.raster_point_type !== undefined && args.raster_point_type !== null) {
        this.raster_point_type = args.raster_point_type;
      }
      if (args.raster_import_bands !== undefined && args.raster_import_bands !== null) {
        this.raster_import_bands = args.raster_import_bands;
      }
      if (args.raster_scanlines_per_thread !== undefined && args.raster_scanlines_per_thread !== null) {
        this.raster_scanlines_per_thread = args.raster_scanlines_per_thread;
      }
      if (args.raster_point_transform !== undefined && args.raster_point_transform !== null) {
        this.raster_point_transform = args.raster_point_transform;
      }
      if (args.raster_point_compute_angle !== undefined && args.raster_point_compute_angle !== null) {
        this.raster_point_compute_angle = args.raster_point_compute_angle;
      }
      if (args.raster_import_dimensions !== undefined && args.raster_import_dimensions !== null) {
        this.raster_import_dimensions = args.raster_import_dimensions;
      }
      if (args.odbc_dsn !== undefined && args.odbc_dsn !== null) {
        this.odbc_dsn = args.odbc_dsn;
      }
      if (args.odbc_connection_string !== undefined && args.odbc_connection_string !== null) {
        this.odbc_connection_string = args.odbc_connection_string;
      }
      if (args.odbc_sql_select !== undefined && args.odbc_sql_select !== null) {
        this.odbc_sql_select = args.odbc_sql_select;
      }
      if (args.odbc_sql_order_by !== undefined && args.odbc_sql_order_by !== null) {
        this.odbc_sql_order_by = args.odbc_sql_order_by;
      }
      if (args.odbc_username !== undefined && args.odbc_username !== null) {
        this.odbc_username = args.odbc_username;
      }
      if (args.odbc_password !== undefined && args.odbc_password !== null) {
        this.odbc_password = args.odbc_password;
      }
      if (args.odbc_credential_string !== undefined && args.odbc_credential_string !== null) {
        this.odbc_credential_string = args.odbc_credential_string;
      }
      if (args.add_metadata_columns !== undefined && args.add_metadata_columns !== null) {
        this.add_metadata_columns = args.add_metadata_columns;
      }
      if (args.trim_spaces !== undefined && args.trim_spaces !== null) {
        this.trim_spaces = args.trim_spaces;
      }
      if (args.geo_validate_geometry !== undefined && args.geo_validate_geometry !== null) {
        this.geo_validate_geometry = args.geo_validate_geometry;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.delimiter = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.null_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.has_header = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.quoted = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.quote = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.escape = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.line_delim = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.array_delim = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.array_begin = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.array_end = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.threads = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.source_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.s3_access_key = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.s3_secret_key = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.s3_region = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.I32) {
          this.geo_coords_encoding = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.I32) {
          this.geo_coords_comp_param = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.geo_coords_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.I32) {
          this.geo_coords_srid = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.BOOL) {
          this.sanitize_column_names = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.geo_layer_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRING) {
          this.s3_endpoint = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.geo_assign_render_groups = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.BOOL) {
          this.geo_explode_collections = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I32) {
          this.source_srid = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRING) {
          this.s3_session_token = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.I32) {
          this.raster_point_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRING) {
          this.raster_import_bands = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.I32) {
          this.raster_scanlines_per_thread = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.I32) {
          this.raster_point_transform = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.BOOL) {
          this.raster_point_compute_angle = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.STRING) {
          this.raster_import_dimensions = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_dsn = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_connection_string = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_sql_select = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_sql_order_by = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 37:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_username = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 38:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_password = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 39:
        if (ftype == Thrift.Type.STRING) {
          this.odbc_credential_string = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 40:
        if (ftype == Thrift.Type.STRING) {
          this.add_metadata_columns = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 41:
        if (ftype == Thrift.Type.BOOL) {
          this.trim_spaces = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 42:
        if (ftype == Thrift.Type.BOOL) {
          this.geo_validate_geometry = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCopyParams');
    if (this.delimiter !== null && this.delimiter !== undefined) {
      output.writeFieldBegin('delimiter', Thrift.Type.STRING, 1);
      output.writeString(this.delimiter);
      output.writeFieldEnd();
    }
    if (this.null_str !== null && this.null_str !== undefined) {
      output.writeFieldBegin('null_str', Thrift.Type.STRING, 2);
      output.writeString(this.null_str);
      output.writeFieldEnd();
    }
    if (this.has_header !== null && this.has_header !== undefined) {
      output.writeFieldBegin('has_header', Thrift.Type.I32, 3);
      output.writeI32(this.has_header);
      output.writeFieldEnd();
    }
    if (this.quoted !== null && this.quoted !== undefined) {
      output.writeFieldBegin('quoted', Thrift.Type.BOOL, 4);
      output.writeBool(this.quoted);
      output.writeFieldEnd();
    }
    if (this.quote !== null && this.quote !== undefined) {
      output.writeFieldBegin('quote', Thrift.Type.STRING, 5);
      output.writeString(this.quote);
      output.writeFieldEnd();
    }
    if (this.escape !== null && this.escape !== undefined) {
      output.writeFieldBegin('escape', Thrift.Type.STRING, 6);
      output.writeString(this.escape);
      output.writeFieldEnd();
    }
    if (this.line_delim !== null && this.line_delim !== undefined) {
      output.writeFieldBegin('line_delim', Thrift.Type.STRING, 7);
      output.writeString(this.line_delim);
      output.writeFieldEnd();
    }
    if (this.array_delim !== null && this.array_delim !== undefined) {
      output.writeFieldBegin('array_delim', Thrift.Type.STRING, 8);
      output.writeString(this.array_delim);
      output.writeFieldEnd();
    }
    if (this.array_begin !== null && this.array_begin !== undefined) {
      output.writeFieldBegin('array_begin', Thrift.Type.STRING, 9);
      output.writeString(this.array_begin);
      output.writeFieldEnd();
    }
    if (this.array_end !== null && this.array_end !== undefined) {
      output.writeFieldBegin('array_end', Thrift.Type.STRING, 10);
      output.writeString(this.array_end);
      output.writeFieldEnd();
    }
    if (this.threads !== null && this.threads !== undefined) {
      output.writeFieldBegin('threads', Thrift.Type.I32, 11);
      output.writeI32(this.threads);
      output.writeFieldEnd();
    }
    if (this.source_type !== null && this.source_type !== undefined) {
      output.writeFieldBegin('source_type', Thrift.Type.I32, 12);
      output.writeI32(this.source_type);
      output.writeFieldEnd();
    }
    if (this.s3_access_key !== null && this.s3_access_key !== undefined) {
      output.writeFieldBegin('s3_access_key', Thrift.Type.STRING, 13);
      output.writeString(this.s3_access_key);
      output.writeFieldEnd();
    }
    if (this.s3_secret_key !== null && this.s3_secret_key !== undefined) {
      output.writeFieldBegin('s3_secret_key', Thrift.Type.STRING, 14);
      output.writeString(this.s3_secret_key);
      output.writeFieldEnd();
    }
    if (this.s3_region !== null && this.s3_region !== undefined) {
      output.writeFieldBegin('s3_region', Thrift.Type.STRING, 15);
      output.writeString(this.s3_region);
      output.writeFieldEnd();
    }
    if (this.geo_coords_encoding !== null && this.geo_coords_encoding !== undefined) {
      output.writeFieldBegin('geo_coords_encoding', Thrift.Type.I32, 16);
      output.writeI32(this.geo_coords_encoding);
      output.writeFieldEnd();
    }
    if (this.geo_coords_comp_param !== null && this.geo_coords_comp_param !== undefined) {
      output.writeFieldBegin('geo_coords_comp_param', Thrift.Type.I32, 17);
      output.writeI32(this.geo_coords_comp_param);
      output.writeFieldEnd();
    }
    if (this.geo_coords_type !== null && this.geo_coords_type !== undefined) {
      output.writeFieldBegin('geo_coords_type', Thrift.Type.I32, 18);
      output.writeI32(this.geo_coords_type);
      output.writeFieldEnd();
    }
    if (this.geo_coords_srid !== null && this.geo_coords_srid !== undefined) {
      output.writeFieldBegin('geo_coords_srid', Thrift.Type.I32, 19);
      output.writeI32(this.geo_coords_srid);
      output.writeFieldEnd();
    }
    if (this.sanitize_column_names !== null && this.sanitize_column_names !== undefined) {
      output.writeFieldBegin('sanitize_column_names', Thrift.Type.BOOL, 20);
      output.writeBool(this.sanitize_column_names);
      output.writeFieldEnd();
    }
    if (this.geo_layer_name !== null && this.geo_layer_name !== undefined) {
      output.writeFieldBegin('geo_layer_name', Thrift.Type.STRING, 21);
      output.writeString(this.geo_layer_name);
      output.writeFieldEnd();
    }
    if (this.s3_endpoint !== null && this.s3_endpoint !== undefined) {
      output.writeFieldBegin('s3_endpoint', Thrift.Type.STRING, 22);
      output.writeString(this.s3_endpoint);
      output.writeFieldEnd();
    }
    if (this.geo_assign_render_groups !== null && this.geo_assign_render_groups !== undefined) {
      output.writeFieldBegin('geo_assign_render_groups', Thrift.Type.BOOL, 23);
      output.writeBool(this.geo_assign_render_groups);
      output.writeFieldEnd();
    }
    if (this.geo_explode_collections !== null && this.geo_explode_collections !== undefined) {
      output.writeFieldBegin('geo_explode_collections', Thrift.Type.BOOL, 24);
      output.writeBool(this.geo_explode_collections);
      output.writeFieldEnd();
    }
    if (this.source_srid !== null && this.source_srid !== undefined) {
      output.writeFieldBegin('source_srid', Thrift.Type.I32, 25);
      output.writeI32(this.source_srid);
      output.writeFieldEnd();
    }
    if (this.s3_session_token !== null && this.s3_session_token !== undefined) {
      output.writeFieldBegin('s3_session_token', Thrift.Type.STRING, 26);
      output.writeString(this.s3_session_token);
      output.writeFieldEnd();
    }
    if (this.raster_point_type !== null && this.raster_point_type !== undefined) {
      output.writeFieldBegin('raster_point_type', Thrift.Type.I32, 27);
      output.writeI32(this.raster_point_type);
      output.writeFieldEnd();
    }
    if (this.raster_import_bands !== null && this.raster_import_bands !== undefined) {
      output.writeFieldBegin('raster_import_bands', Thrift.Type.STRING, 28);
      output.writeString(this.raster_import_bands);
      output.writeFieldEnd();
    }
    if (this.raster_scanlines_per_thread !== null && this.raster_scanlines_per_thread !== undefined) {
      output.writeFieldBegin('raster_scanlines_per_thread', Thrift.Type.I32, 29);
      output.writeI32(this.raster_scanlines_per_thread);
      output.writeFieldEnd();
    }
    if (this.raster_point_transform !== null && this.raster_point_transform !== undefined) {
      output.writeFieldBegin('raster_point_transform', Thrift.Type.I32, 30);
      output.writeI32(this.raster_point_transform);
      output.writeFieldEnd();
    }
    if (this.raster_point_compute_angle !== null && this.raster_point_compute_angle !== undefined) {
      output.writeFieldBegin('raster_point_compute_angle', Thrift.Type.BOOL, 31);
      output.writeBool(this.raster_point_compute_angle);
      output.writeFieldEnd();
    }
    if (this.raster_import_dimensions !== null && this.raster_import_dimensions !== undefined) {
      output.writeFieldBegin('raster_import_dimensions', Thrift.Type.STRING, 32);
      output.writeString(this.raster_import_dimensions);
      output.writeFieldEnd();
    }
    if (this.odbc_dsn !== null && this.odbc_dsn !== undefined) {
      output.writeFieldBegin('odbc_dsn', Thrift.Type.STRING, 33);
      output.writeString(this.odbc_dsn);
      output.writeFieldEnd();
    }
    if (this.odbc_connection_string !== null && this.odbc_connection_string !== undefined) {
      output.writeFieldBegin('odbc_connection_string', Thrift.Type.STRING, 34);
      output.writeString(this.odbc_connection_string);
      output.writeFieldEnd();
    }
    if (this.odbc_sql_select !== null && this.odbc_sql_select !== undefined) {
      output.writeFieldBegin('odbc_sql_select', Thrift.Type.STRING, 35);
      output.writeString(this.odbc_sql_select);
      output.writeFieldEnd();
    }
    if (this.odbc_sql_order_by !== null && this.odbc_sql_order_by !== undefined) {
      output.writeFieldBegin('odbc_sql_order_by', Thrift.Type.STRING, 36);
      output.writeString(this.odbc_sql_order_by);
      output.writeFieldEnd();
    }
    if (this.odbc_username !== null && this.odbc_username !== undefined) {
      output.writeFieldBegin('odbc_username', Thrift.Type.STRING, 37);
      output.writeString(this.odbc_username);
      output.writeFieldEnd();
    }
    if (this.odbc_password !== null && this.odbc_password !== undefined) {
      output.writeFieldBegin('odbc_password', Thrift.Type.STRING, 38);
      output.writeString(this.odbc_password);
      output.writeFieldEnd();
    }
    if (this.odbc_credential_string !== null && this.odbc_credential_string !== undefined) {
      output.writeFieldBegin('odbc_credential_string', Thrift.Type.STRING, 39);
      output.writeString(this.odbc_credential_string);
      output.writeFieldEnd();
    }
    if (this.add_metadata_columns !== null && this.add_metadata_columns !== undefined) {
      output.writeFieldBegin('add_metadata_columns', Thrift.Type.STRING, 40);
      output.writeString(this.add_metadata_columns);
      output.writeFieldEnd();
    }
    if (this.trim_spaces !== null && this.trim_spaces !== undefined) {
      output.writeFieldBegin('trim_spaces', Thrift.Type.BOOL, 41);
      output.writeBool(this.trim_spaces);
      output.writeFieldEnd();
    }
    if (this.geo_validate_geometry !== null && this.geo_validate_geometry !== undefined) {
      output.writeFieldBegin('geo_validate_geometry', Thrift.Type.BOOL, 42);
      output.writeBool(this.geo_validate_geometry);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCreateParams = module.exports.TCreateParams = class {
  constructor(args) {
    this.is_replicated = null;
    if (args) {
      if (args.is_replicated !== undefined && args.is_replicated !== null) {
        this.is_replicated = args.is_replicated;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.is_replicated = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCreateParams');
    if (this.is_replicated !== null && this.is_replicated !== undefined) {
      output.writeFieldBegin('is_replicated', Thrift.Type.BOOL, 1);
      output.writeBool(this.is_replicated);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDetectResult = module.exports.TDetectResult = class {
  constructor(args) {
    this.row_set = null;
    this.copy_params = null;
    if (args) {
      if (args.row_set !== undefined && args.row_set !== null) {
        this.row_set = new ttypes.TRowSet(args.row_set);
      }
      if (args.copy_params !== undefined && args.copy_params !== null) {
        this.copy_params = new ttypes.TCopyParams(args.copy_params);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.row_set = new ttypes.TRowSet();
          this.row_set.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.copy_params = new ttypes.TCopyParams();
          this.copy_params.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDetectResult');
    if (this.row_set !== null && this.row_set !== undefined) {
      output.writeFieldBegin('row_set', Thrift.Type.STRUCT, 1);
      this.row_set.write(output);
      output.writeFieldEnd();
    }
    if (this.copy_params !== null && this.copy_params !== undefined) {
      output.writeFieldBegin('copy_params', Thrift.Type.STRUCT, 2);
      this.copy_params.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TImportStatus = module.exports.TImportStatus = class {
  constructor(args) {
    this.elapsed = null;
    this.rows_completed = null;
    this.rows_estimated = null;
    this.rows_rejected = null;
    if (args) {
      if (args.elapsed !== undefined && args.elapsed !== null) {
        this.elapsed = args.elapsed;
      }
      if (args.rows_completed !== undefined && args.rows_completed !== null) {
        this.rows_completed = args.rows_completed;
      }
      if (args.rows_estimated !== undefined && args.rows_estimated !== null) {
        this.rows_estimated = args.rows_estimated;
      }
      if (args.rows_rejected !== undefined && args.rows_rejected !== null) {
        this.rows_rejected = args.rows_rejected;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.elapsed = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.rows_completed = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.rows_estimated = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.rows_rejected = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TImportStatus');
    if (this.elapsed !== null && this.elapsed !== undefined) {
      output.writeFieldBegin('elapsed', Thrift.Type.I64, 1);
      output.writeI64(this.elapsed);
      output.writeFieldEnd();
    }
    if (this.rows_completed !== null && this.rows_completed !== undefined) {
      output.writeFieldBegin('rows_completed', Thrift.Type.I64, 2);
      output.writeI64(this.rows_completed);
      output.writeFieldEnd();
    }
    if (this.rows_estimated !== null && this.rows_estimated !== undefined) {
      output.writeFieldBegin('rows_estimated', Thrift.Type.I64, 3);
      output.writeI64(this.rows_estimated);
      output.writeFieldEnd();
    }
    if (this.rows_rejected !== null && this.rows_rejected !== undefined) {
      output.writeFieldBegin('rows_rejected', Thrift.Type.I64, 4);
      output.writeI64(this.rows_rejected);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TFrontendView = module.exports.TFrontendView = class {
  constructor(args) {
    this.view_name = null;
    this.view_state = null;
    this.image_hash = null;
    this.update_time = null;
    this.view_metadata = null;
    if (args) {
      if (args.view_name !== undefined && args.view_name !== null) {
        this.view_name = args.view_name;
      }
      if (args.view_state !== undefined && args.view_state !== null) {
        this.view_state = args.view_state;
      }
      if (args.image_hash !== undefined && args.image_hash !== null) {
        this.image_hash = args.image_hash;
      }
      if (args.update_time !== undefined && args.update_time !== null) {
        this.update_time = args.update_time;
      }
      if (args.view_metadata !== undefined && args.view_metadata !== null) {
        this.view_metadata = args.view_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.view_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.view_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.image_hash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.update_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.view_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TFrontendView');
    if (this.view_name !== null && this.view_name !== undefined) {
      output.writeFieldBegin('view_name', Thrift.Type.STRING, 1);
      output.writeString(this.view_name);
      output.writeFieldEnd();
    }
    if (this.view_state !== null && this.view_state !== undefined) {
      output.writeFieldBegin('view_state', Thrift.Type.STRING, 2);
      output.writeString(this.view_state);
      output.writeFieldEnd();
    }
    if (this.image_hash !== null && this.image_hash !== undefined) {
      output.writeFieldBegin('image_hash', Thrift.Type.STRING, 3);
      output.writeString(this.image_hash);
      output.writeFieldEnd();
    }
    if (this.update_time !== null && this.update_time !== undefined) {
      output.writeFieldBegin('update_time', Thrift.Type.STRING, 4);
      output.writeString(this.update_time);
      output.writeFieldEnd();
    }
    if (this.view_metadata !== null && this.view_metadata !== undefined) {
      output.writeFieldBegin('view_metadata', Thrift.Type.STRING, 5);
      output.writeString(this.view_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TServerStatus = module.exports.TServerStatus = class {
  constructor(args) {
    this.read_only = null;
    this.version = null;
    this.rendering_enabled = null;
    this.start_time = null;
    this.edition = null;
    this.host_name = null;
    this.poly_rendering_enabled = null;
    this.role = null;
    this.renderer_status_json = null;
    this.host_id = null;
    if (args) {
      if (args.read_only !== undefined && args.read_only !== null) {
        this.read_only = args.read_only;
      }
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      }
      if (args.rendering_enabled !== undefined && args.rendering_enabled !== null) {
        this.rendering_enabled = args.rendering_enabled;
      }
      if (args.start_time !== undefined && args.start_time !== null) {
        this.start_time = args.start_time;
      }
      if (args.edition !== undefined && args.edition !== null) {
        this.edition = args.edition;
      }
      if (args.host_name !== undefined && args.host_name !== null) {
        this.host_name = args.host_name;
      }
      if (args.poly_rendering_enabled !== undefined && args.poly_rendering_enabled !== null) {
        this.poly_rendering_enabled = args.poly_rendering_enabled;
      }
      if (args.role !== undefined && args.role !== null) {
        this.role = args.role;
      }
      if (args.renderer_status_json !== undefined && args.renderer_status_json !== null) {
        this.renderer_status_json = args.renderer_status_json;
      }
      if (args.host_id !== undefined && args.host_id !== null) {
        this.host_id = args.host_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.read_only = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.version = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.rendering_enabled = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.start_time = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.edition = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.host_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.poly_rendering_enabled = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.role = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.renderer_status_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.host_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TServerStatus');
    if (this.read_only !== null && this.read_only !== undefined) {
      output.writeFieldBegin('read_only', Thrift.Type.BOOL, 1);
      output.writeBool(this.read_only);
      output.writeFieldEnd();
    }
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.STRING, 2);
      output.writeString(this.version);
      output.writeFieldEnd();
    }
    if (this.rendering_enabled !== null && this.rendering_enabled !== undefined) {
      output.writeFieldBegin('rendering_enabled', Thrift.Type.BOOL, 3);
      output.writeBool(this.rendering_enabled);
      output.writeFieldEnd();
    }
    if (this.start_time !== null && this.start_time !== undefined) {
      output.writeFieldBegin('start_time', Thrift.Type.I64, 4);
      output.writeI64(this.start_time);
      output.writeFieldEnd();
    }
    if (this.edition !== null && this.edition !== undefined) {
      output.writeFieldBegin('edition', Thrift.Type.STRING, 5);
      output.writeString(this.edition);
      output.writeFieldEnd();
    }
    if (this.host_name !== null && this.host_name !== undefined) {
      output.writeFieldBegin('host_name', Thrift.Type.STRING, 6);
      output.writeString(this.host_name);
      output.writeFieldEnd();
    }
    if (this.poly_rendering_enabled !== null && this.poly_rendering_enabled !== undefined) {
      output.writeFieldBegin('poly_rendering_enabled', Thrift.Type.BOOL, 7);
      output.writeBool(this.poly_rendering_enabled);
      output.writeFieldEnd();
    }
    if (this.role !== null && this.role !== undefined) {
      output.writeFieldBegin('role', Thrift.Type.I32, 8);
      output.writeI32(this.role);
      output.writeFieldEnd();
    }
    if (this.renderer_status_json !== null && this.renderer_status_json !== undefined) {
      output.writeFieldBegin('renderer_status_json', Thrift.Type.STRING, 9);
      output.writeString(this.renderer_status_json);
      output.writeFieldEnd();
    }
    if (this.host_id !== null && this.host_id !== undefined) {
      output.writeFieldBegin('host_id', Thrift.Type.STRING, 10);
      output.writeString(this.host_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TPixel = module.exports.TPixel = class {
  constructor(args) {
    this.x = null;
    this.y = null;
    if (args) {
      if (args.x !== undefined && args.x !== null) {
        this.x = args.x;
      }
      if (args.y !== undefined && args.y !== null) {
        this.y = args.y;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.x = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.y = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TPixel');
    if (this.x !== null && this.x !== undefined) {
      output.writeFieldBegin('x', Thrift.Type.I64, 1);
      output.writeI64(this.x);
      output.writeFieldEnd();
    }
    if (this.y !== null && this.y !== undefined) {
      output.writeFieldBegin('y', Thrift.Type.I64, 2);
      output.writeI64(this.y);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TPixelTableRowResult = module.exports.TPixelTableRowResult = class {
  constructor(args) {
    this.pixel = null;
    this.vega_table_name = null;
    this.table_id = null;
    this.row_id = null;
    this.row_set = null;
    this.nonce = null;
    if (args) {
      if (args.pixel !== undefined && args.pixel !== null) {
        this.pixel = new ttypes.TPixel(args.pixel);
      }
      if (args.vega_table_name !== undefined && args.vega_table_name !== null) {
        this.vega_table_name = args.vega_table_name;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = Thrift.copyList(args.table_id, [null]);
      }
      if (args.row_id !== undefined && args.row_id !== null) {
        this.row_id = Thrift.copyList(args.row_id, [null]);
      }
      if (args.row_set !== undefined && args.row_set !== null) {
        this.row_set = new ttypes.TRowSet(args.row_set);
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.pixel = new ttypes.TPixel();
          this.pixel.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.vega_table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.table_id = [];
          const _rtmp361 = input.readListBegin();
          const _size60 = _rtmp361.size || 0;
          for (let _i62 = 0; _i62 < _size60; ++_i62) {
            let elem63 = null;
            elem63 = input.readI64();
            this.table_id.push(elem63);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.row_id = [];
          const _rtmp365 = input.readListBegin();
          const _size64 = _rtmp365.size || 0;
          for (let _i66 = 0; _i66 < _size64; ++_i66) {
            let elem67 = null;
            elem67 = input.readI64();
            this.row_id.push(elem67);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.row_set = new ttypes.TRowSet();
          this.row_set.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TPixelTableRowResult');
    if (this.pixel !== null && this.pixel !== undefined) {
      output.writeFieldBegin('pixel', Thrift.Type.STRUCT, 1);
      this.pixel.write(output);
      output.writeFieldEnd();
    }
    if (this.vega_table_name !== null && this.vega_table_name !== undefined) {
      output.writeFieldBegin('vega_table_name', Thrift.Type.STRING, 2);
      output.writeString(this.vega_table_name);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.I64, this.table_id.length);
      for (let iter68 in this.table_id) {
        if (this.table_id.hasOwnProperty(iter68)) {
          iter68 = this.table_id[iter68];
          output.writeI64(iter68);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.row_id !== null && this.row_id !== undefined) {
      output.writeFieldBegin('row_id', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.I64, this.row_id.length);
      for (let iter69 in this.row_id) {
        if (this.row_id.hasOwnProperty(iter69)) {
          iter69 = this.row_id[iter69];
          output.writeI64(iter69);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.row_set !== null && this.row_set !== undefined) {
      output.writeFieldBegin('row_set', Thrift.Type.STRUCT, 5);
      this.row_set.write(output);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 6);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRenderResult = module.exports.TRenderResult = class {
  constructor(args) {
    this.image = null;
    this.nonce = null;
    this.execution_time_ms = null;
    this.render_time_ms = null;
    this.total_time_ms = null;
    this.vega_metadata = null;
    if (args) {
      if (args.image !== undefined && args.image !== null) {
        this.image = args.image;
      }
      if (args.nonce !== undefined && args.nonce !== null) {
        this.nonce = args.nonce;
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.render_time_ms !== undefined && args.render_time_ms !== null) {
        this.render_time_ms = args.render_time_ms;
      }
      if (args.total_time_ms !== undefined && args.total_time_ms !== null) {
        this.total_time_ms = args.total_time_ms;
      }
      if (args.vega_metadata !== undefined && args.vega_metadata !== null) {
        this.vega_metadata = args.vega_metadata;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.image = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nonce = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.render_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.total_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.vega_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRenderResult');
    if (this.image !== null && this.image !== undefined) {
      output.writeFieldBegin('image', Thrift.Type.STRING, 1);
      output.writeBinary(this.image);
      output.writeFieldEnd();
    }
    if (this.nonce !== null && this.nonce !== undefined) {
      output.writeFieldBegin('nonce', Thrift.Type.STRING, 2);
      output.writeString(this.nonce);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 3);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.render_time_ms !== null && this.render_time_ms !== undefined) {
      output.writeFieldBegin('render_time_ms', Thrift.Type.I64, 4);
      output.writeI64(this.render_time_ms);
      output.writeFieldEnd();
    }
    if (this.total_time_ms !== null && this.total_time_ms !== undefined) {
      output.writeFieldBegin('total_time_ms', Thrift.Type.I64, 5);
      output.writeI64(this.total_time_ms);
      output.writeFieldEnd();
    }
    if (this.vega_metadata !== null && this.vega_metadata !== undefined) {
      output.writeFieldBegin('vega_metadata', Thrift.Type.STRING, 6);
      output.writeString(this.vega_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TGpuSpecification = module.exports.TGpuSpecification = class {
  constructor(args) {
    this.num_sm = null;
    this.clock_frequency_kHz = null;
    this.memory = null;
    this.compute_capability_major = null;
    this.compute_capability_minor = null;
    if (args) {
      if (args.num_sm !== undefined && args.num_sm !== null) {
        this.num_sm = args.num_sm;
      }
      if (args.clock_frequency_kHz !== undefined && args.clock_frequency_kHz !== null) {
        this.clock_frequency_kHz = args.clock_frequency_kHz;
      }
      if (args.memory !== undefined && args.memory !== null) {
        this.memory = args.memory;
      }
      if (args.compute_capability_major !== undefined && args.compute_capability_major !== null) {
        this.compute_capability_major = args.compute_capability_major;
      }
      if (args.compute_capability_minor !== undefined && args.compute_capability_minor !== null) {
        this.compute_capability_minor = args.compute_capability_minor;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.num_sm = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.clock_frequency_kHz = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.memory = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I16) {
          this.compute_capability_major = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I16) {
          this.compute_capability_minor = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TGpuSpecification');
    if (this.num_sm !== null && this.num_sm !== undefined) {
      output.writeFieldBegin('num_sm', Thrift.Type.I32, 1);
      output.writeI32(this.num_sm);
      output.writeFieldEnd();
    }
    if (this.clock_frequency_kHz !== null && this.clock_frequency_kHz !== undefined) {
      output.writeFieldBegin('clock_frequency_kHz', Thrift.Type.I64, 2);
      output.writeI64(this.clock_frequency_kHz);
      output.writeFieldEnd();
    }
    if (this.memory !== null && this.memory !== undefined) {
      output.writeFieldBegin('memory', Thrift.Type.I64, 3);
      output.writeI64(this.memory);
      output.writeFieldEnd();
    }
    if (this.compute_capability_major !== null && this.compute_capability_major !== undefined) {
      output.writeFieldBegin('compute_capability_major', Thrift.Type.I16, 4);
      output.writeI16(this.compute_capability_major);
      output.writeFieldEnd();
    }
    if (this.compute_capability_minor !== null && this.compute_capability_minor !== undefined) {
      output.writeFieldBegin('compute_capability_minor', Thrift.Type.I16, 5);
      output.writeI16(this.compute_capability_minor);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const THardwareInfo = module.exports.THardwareInfo = class {
  constructor(args) {
    this.num_gpu_hw = null;
    this.num_cpu_hw = null;
    this.num_gpu_allocated = null;
    this.start_gpu = null;
    this.host_name = null;
    this.gpu_info = null;
    if (args) {
      if (args.num_gpu_hw !== undefined && args.num_gpu_hw !== null) {
        this.num_gpu_hw = args.num_gpu_hw;
      }
      if (args.num_cpu_hw !== undefined && args.num_cpu_hw !== null) {
        this.num_cpu_hw = args.num_cpu_hw;
      }
      if (args.num_gpu_allocated !== undefined && args.num_gpu_allocated !== null) {
        this.num_gpu_allocated = args.num_gpu_allocated;
      }
      if (args.start_gpu !== undefined && args.start_gpu !== null) {
        this.start_gpu = args.start_gpu;
      }
      if (args.host_name !== undefined && args.host_name !== null) {
        this.host_name = args.host_name;
      }
      if (args.gpu_info !== undefined && args.gpu_info !== null) {
        this.gpu_info = Thrift.copyList(args.gpu_info, [ttypes.TGpuSpecification]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I16) {
          this.num_gpu_hw = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I16) {
          this.num_cpu_hw = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I16) {
          this.num_gpu_allocated = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I16) {
          this.start_gpu = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.host_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.gpu_info = [];
          const _rtmp371 = input.readListBegin();
          const _size70 = _rtmp371.size || 0;
          for (let _i72 = 0; _i72 < _size70; ++_i72) {
            let elem73 = null;
            elem73 = new ttypes.TGpuSpecification();
            elem73.read(input);
            this.gpu_info.push(elem73);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('THardwareInfo');
    if (this.num_gpu_hw !== null && this.num_gpu_hw !== undefined) {
      output.writeFieldBegin('num_gpu_hw', Thrift.Type.I16, 1);
      output.writeI16(this.num_gpu_hw);
      output.writeFieldEnd();
    }
    if (this.num_cpu_hw !== null && this.num_cpu_hw !== undefined) {
      output.writeFieldBegin('num_cpu_hw', Thrift.Type.I16, 2);
      output.writeI16(this.num_cpu_hw);
      output.writeFieldEnd();
    }
    if (this.num_gpu_allocated !== null && this.num_gpu_allocated !== undefined) {
      output.writeFieldBegin('num_gpu_allocated', Thrift.Type.I16, 3);
      output.writeI16(this.num_gpu_allocated);
      output.writeFieldEnd();
    }
    if (this.start_gpu !== null && this.start_gpu !== undefined) {
      output.writeFieldBegin('start_gpu', Thrift.Type.I16, 4);
      output.writeI16(this.start_gpu);
      output.writeFieldEnd();
    }
    if (this.host_name !== null && this.host_name !== undefined) {
      output.writeFieldBegin('host_name', Thrift.Type.STRING, 5);
      output.writeString(this.host_name);
      output.writeFieldEnd();
    }
    if (this.gpu_info !== null && this.gpu_info !== undefined) {
      output.writeFieldBegin('gpu_info', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.gpu_info.length);
      for (let iter74 in this.gpu_info) {
        if (this.gpu_info.hasOwnProperty(iter74)) {
          iter74 = this.gpu_info[iter74];
          iter74.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TClusterHardwareInfo = module.exports.TClusterHardwareInfo = class {
  constructor(args) {
    this.hardware_info = null;
    if (args) {
      if (args.hardware_info !== undefined && args.hardware_info !== null) {
        this.hardware_info = Thrift.copyList(args.hardware_info, [ttypes.THardwareInfo]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.hardware_info = [];
          const _rtmp376 = input.readListBegin();
          const _size75 = _rtmp376.size || 0;
          for (let _i77 = 0; _i77 < _size75; ++_i77) {
            let elem78 = null;
            elem78 = new ttypes.THardwareInfo();
            elem78.read(input);
            this.hardware_info.push(elem78);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TClusterHardwareInfo');
    if (this.hardware_info !== null && this.hardware_info !== undefined) {
      output.writeFieldBegin('hardware_info', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.hardware_info.length);
      for (let iter79 in this.hardware_info) {
        if (this.hardware_info.hasOwnProperty(iter79)) {
          iter79 = this.hardware_info[iter79];
          iter79.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TMemoryData = module.exports.TMemoryData = class {
  constructor(args) {
    this.slab = null;
    this.start_page = null;
    this.num_pages = null;
    this.touch = null;
    this.chunk_key = null;
    this.buffer_epoch = null;
    this.is_free = null;
    if (args) {
      if (args.slab !== undefined && args.slab !== null) {
        this.slab = args.slab;
      }
      if (args.start_page !== undefined && args.start_page !== null) {
        this.start_page = args.start_page;
      }
      if (args.num_pages !== undefined && args.num_pages !== null) {
        this.num_pages = args.num_pages;
      }
      if (args.touch !== undefined && args.touch !== null) {
        this.touch = args.touch;
      }
      if (args.chunk_key !== undefined && args.chunk_key !== null) {
        this.chunk_key = Thrift.copyList(args.chunk_key, [null]);
      }
      if (args.buffer_epoch !== undefined && args.buffer_epoch !== null) {
        this.buffer_epoch = args.buffer_epoch;
      }
      if (args.is_free !== undefined && args.is_free !== null) {
        this.is_free = args.is_free;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.slab = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.start_page = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.num_pages = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.touch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.chunk_key = [];
          const _rtmp381 = input.readListBegin();
          const _size80 = _rtmp381.size || 0;
          for (let _i82 = 0; _i82 < _size80; ++_i82) {
            let elem83 = null;
            elem83 = input.readI64();
            this.chunk_key.push(elem83);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.buffer_epoch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.is_free = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TMemoryData');
    if (this.slab !== null && this.slab !== undefined) {
      output.writeFieldBegin('slab', Thrift.Type.I64, 1);
      output.writeI64(this.slab);
      output.writeFieldEnd();
    }
    if (this.start_page !== null && this.start_page !== undefined) {
      output.writeFieldBegin('start_page', Thrift.Type.I32, 2);
      output.writeI32(this.start_page);
      output.writeFieldEnd();
    }
    if (this.num_pages !== null && this.num_pages !== undefined) {
      output.writeFieldBegin('num_pages', Thrift.Type.I64, 3);
      output.writeI64(this.num_pages);
      output.writeFieldEnd();
    }
    if (this.touch !== null && this.touch !== undefined) {
      output.writeFieldBegin('touch', Thrift.Type.I32, 4);
      output.writeI32(this.touch);
      output.writeFieldEnd();
    }
    if (this.chunk_key !== null && this.chunk_key !== undefined) {
      output.writeFieldBegin('chunk_key', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.I64, this.chunk_key.length);
      for (let iter84 in this.chunk_key) {
        if (this.chunk_key.hasOwnProperty(iter84)) {
          iter84 = this.chunk_key[iter84];
          output.writeI64(iter84);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.buffer_epoch !== null && this.buffer_epoch !== undefined) {
      output.writeFieldBegin('buffer_epoch', Thrift.Type.I32, 6);
      output.writeI32(this.buffer_epoch);
      output.writeFieldEnd();
    }
    if (this.is_free !== null && this.is_free !== undefined) {
      output.writeFieldBegin('is_free', Thrift.Type.BOOL, 7);
      output.writeBool(this.is_free);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TNodeMemoryInfo = module.exports.TNodeMemoryInfo = class {
  constructor(args) {
    this.host_name = null;
    this.page_size = null;
    this.max_num_pages = null;
    this.num_pages_allocated = null;
    this.is_allocation_capped = null;
    this.node_memory_data = null;
    if (args) {
      if (args.host_name !== undefined && args.host_name !== null) {
        this.host_name = args.host_name;
      }
      if (args.page_size !== undefined && args.page_size !== null) {
        this.page_size = args.page_size;
      }
      if (args.max_num_pages !== undefined && args.max_num_pages !== null) {
        this.max_num_pages = args.max_num_pages;
      }
      if (args.num_pages_allocated !== undefined && args.num_pages_allocated !== null) {
        this.num_pages_allocated = args.num_pages_allocated;
      }
      if (args.is_allocation_capped !== undefined && args.is_allocation_capped !== null) {
        this.is_allocation_capped = args.is_allocation_capped;
      }
      if (args.node_memory_data !== undefined && args.node_memory_data !== null) {
        this.node_memory_data = Thrift.copyList(args.node_memory_data, [ttypes.TMemoryData]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.host_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.page_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.max_num_pages = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.num_pages_allocated = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.is_allocation_capped = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.node_memory_data = [];
          const _rtmp386 = input.readListBegin();
          const _size85 = _rtmp386.size || 0;
          for (let _i87 = 0; _i87 < _size85; ++_i87) {
            let elem88 = null;
            elem88 = new ttypes.TMemoryData();
            elem88.read(input);
            this.node_memory_data.push(elem88);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TNodeMemoryInfo');
    if (this.host_name !== null && this.host_name !== undefined) {
      output.writeFieldBegin('host_name', Thrift.Type.STRING, 1);
      output.writeString(this.host_name);
      output.writeFieldEnd();
    }
    if (this.page_size !== null && this.page_size !== undefined) {
      output.writeFieldBegin('page_size', Thrift.Type.I64, 2);
      output.writeI64(this.page_size);
      output.writeFieldEnd();
    }
    if (this.max_num_pages !== null && this.max_num_pages !== undefined) {
      output.writeFieldBegin('max_num_pages', Thrift.Type.I64, 3);
      output.writeI64(this.max_num_pages);
      output.writeFieldEnd();
    }
    if (this.num_pages_allocated !== null && this.num_pages_allocated !== undefined) {
      output.writeFieldBegin('num_pages_allocated', Thrift.Type.I64, 4);
      output.writeI64(this.num_pages_allocated);
      output.writeFieldEnd();
    }
    if (this.is_allocation_capped !== null && this.is_allocation_capped !== undefined) {
      output.writeFieldBegin('is_allocation_capped', Thrift.Type.BOOL, 5);
      output.writeBool(this.is_allocation_capped);
      output.writeFieldEnd();
    }
    if (this.node_memory_data !== null && this.node_memory_data !== undefined) {
      output.writeFieldBegin('node_memory_data', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.node_memory_data.length);
      for (let iter89 in this.node_memory_data) {
        if (this.node_memory_data.hasOwnProperty(iter89)) {
          iter89 = this.node_memory_data[iter89];
          iter89.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableMeta = module.exports.TTableMeta = class {
  constructor(args) {
    this.table_name = null;
    this.num_cols = null;
    this.is_view = null;
    this.is_replicated = null;
    this.shard_count = null;
    this.max_rows = null;
    this.table_id = null;
    this.max_table_id = null;
    this.col_types = null;
    this.col_names = null;
    if (args) {
      if (args.table_name !== undefined && args.table_name !== null) {
        this.table_name = args.table_name;
      }
      if (args.num_cols !== undefined && args.num_cols !== null) {
        this.num_cols = args.num_cols;
      }
      if (args.is_view !== undefined && args.is_view !== null) {
        this.is_view = args.is_view;
      }
      if (args.is_replicated !== undefined && args.is_replicated !== null) {
        this.is_replicated = args.is_replicated;
      }
      if (args.shard_count !== undefined && args.shard_count !== null) {
        this.shard_count = args.shard_count;
      }
      if (args.max_rows !== undefined && args.max_rows !== null) {
        this.max_rows = args.max_rows;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.max_table_id !== undefined && args.max_table_id !== null) {
        this.max_table_id = args.max_table_id;
      }
      if (args.col_types !== undefined && args.col_types !== null) {
        this.col_types = Thrift.copyList(args.col_types, [common_ttypes.TTypeInfo]);
      }
      if (args.col_names !== undefined && args.col_names !== null) {
        this.col_names = Thrift.copyList(args.col_names, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.table_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.num_cols = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.is_view = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.is_replicated = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.shard_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.max_rows = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.table_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.max_table_id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.col_types = [];
          const _rtmp391 = input.readListBegin();
          const _size90 = _rtmp391.size || 0;
          for (let _i92 = 0; _i92 < _size90; ++_i92) {
            let elem93 = null;
            elem93 = new common_ttypes.TTypeInfo();
            elem93.read(input);
            this.col_types.push(elem93);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.LIST) {
          this.col_names = [];
          const _rtmp395 = input.readListBegin();
          const _size94 = _rtmp395.size || 0;
          for (let _i96 = 0; _i96 < _size94; ++_i96) {
            let elem97 = null;
            elem97 = input.readString();
            this.col_names.push(elem97);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableMeta');
    if (this.table_name !== null && this.table_name !== undefined) {
      output.writeFieldBegin('table_name', Thrift.Type.STRING, 1);
      output.writeString(this.table_name);
      output.writeFieldEnd();
    }
    if (this.num_cols !== null && this.num_cols !== undefined) {
      output.writeFieldBegin('num_cols', Thrift.Type.I64, 2);
      output.writeI64(this.num_cols);
      output.writeFieldEnd();
    }
    if (this.is_view !== null && this.is_view !== undefined) {
      output.writeFieldBegin('is_view', Thrift.Type.BOOL, 4);
      output.writeBool(this.is_view);
      output.writeFieldEnd();
    }
    if (this.is_replicated !== null && this.is_replicated !== undefined) {
      output.writeFieldBegin('is_replicated', Thrift.Type.BOOL, 5);
      output.writeBool(this.is_replicated);
      output.writeFieldEnd();
    }
    if (this.shard_count !== null && this.shard_count !== undefined) {
      output.writeFieldBegin('shard_count', Thrift.Type.I64, 6);
      output.writeI64(this.shard_count);
      output.writeFieldEnd();
    }
    if (this.max_rows !== null && this.max_rows !== undefined) {
      output.writeFieldBegin('max_rows', Thrift.Type.I64, 7);
      output.writeI64(this.max_rows);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I64, 8);
      output.writeI64(this.table_id);
      output.writeFieldEnd();
    }
    if (this.max_table_id !== null && this.max_table_id !== undefined) {
      output.writeFieldBegin('max_table_id', Thrift.Type.I64, 9);
      output.writeI64(this.max_table_id);
      output.writeFieldEnd();
    }
    if (this.col_types !== null && this.col_types !== undefined) {
      output.writeFieldBegin('col_types', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.col_types.length);
      for (let iter98 in this.col_types) {
        if (this.col_types.hasOwnProperty(iter98)) {
          iter98 = this.col_types[iter98];
          iter98.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.col_names !== null && this.col_names !== undefined) {
      output.writeFieldBegin('col_names', Thrift.Type.LIST, 11);
      output.writeListBegin(Thrift.Type.STRING, this.col_names.length);
      for (let iter99 in this.col_names) {
        if (this.col_names.hasOwnProperty(iter99)) {
          iter99 = this.col_names[iter99];
          output.writeString(iter99);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableRefreshInfo = module.exports.TTableRefreshInfo = class {
  constructor(args) {
    this.update_type = null;
    this.timing_type = null;
    this.start_date_time = null;
    this.interval_type = null;
    this.interval_count = null;
    this.last_refresh_time = null;
    this.next_refresh_time = null;
    if (args) {
      if (args.update_type !== undefined && args.update_type !== null) {
        this.update_type = args.update_type;
      }
      if (args.timing_type !== undefined && args.timing_type !== null) {
        this.timing_type = args.timing_type;
      }
      if (args.start_date_time !== undefined && args.start_date_time !== null) {
        this.start_date_time = args.start_date_time;
      }
      if (args.interval_type !== undefined && args.interval_type !== null) {
        this.interval_type = args.interval_type;
      }
      if (args.interval_count !== undefined && args.interval_count !== null) {
        this.interval_count = args.interval_count;
      }
      if (args.last_refresh_time !== undefined && args.last_refresh_time !== null) {
        this.last_refresh_time = args.last_refresh_time;
      }
      if (args.next_refresh_time !== undefined && args.next_refresh_time !== null) {
        this.next_refresh_time = args.next_refresh_time;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.update_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.timing_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.start_date_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.interval_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.interval_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.last_refresh_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.next_refresh_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableRefreshInfo');
    if (this.update_type !== null && this.update_type !== undefined) {
      output.writeFieldBegin('update_type', Thrift.Type.I32, 1);
      output.writeI32(this.update_type);
      output.writeFieldEnd();
    }
    if (this.timing_type !== null && this.timing_type !== undefined) {
      output.writeFieldBegin('timing_type', Thrift.Type.I32, 2);
      output.writeI32(this.timing_type);
      output.writeFieldEnd();
    }
    if (this.start_date_time !== null && this.start_date_time !== undefined) {
      output.writeFieldBegin('start_date_time', Thrift.Type.STRING, 3);
      output.writeString(this.start_date_time);
      output.writeFieldEnd();
    }
    if (this.interval_type !== null && this.interval_type !== undefined) {
      output.writeFieldBegin('interval_type', Thrift.Type.I32, 4);
      output.writeI32(this.interval_type);
      output.writeFieldEnd();
    }
    if (this.interval_count !== null && this.interval_count !== undefined) {
      output.writeFieldBegin('interval_count', Thrift.Type.I64, 5);
      output.writeI64(this.interval_count);
      output.writeFieldEnd();
    }
    if (this.last_refresh_time !== null && this.last_refresh_time !== undefined) {
      output.writeFieldBegin('last_refresh_time', Thrift.Type.STRING, 6);
      output.writeString(this.last_refresh_time);
      output.writeFieldEnd();
    }
    if (this.next_refresh_time !== null && this.next_refresh_time !== undefined) {
      output.writeFieldBegin('next_refresh_time', Thrift.Type.STRING, 7);
      output.writeString(this.next_refresh_time);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableDetails = module.exports.TTableDetails = class {
  constructor(args) {
    this.row_desc = null;
    this.fragment_size = null;
    this.page_size = null;
    this.max_rows = null;
    this.view_sql = null;
    this.shard_count = null;
    this.key_metainfo = null;
    this.is_temporary = null;
    this.partition_detail = null;
    this.table_type = null;
    this.refresh_info = null;
    this.sharded_column_name = null;
    if (args) {
      if (args.row_desc !== undefined && args.row_desc !== null) {
        this.row_desc = Thrift.copyList(args.row_desc, [ttypes.TColumnType]);
      }
      if (args.fragment_size !== undefined && args.fragment_size !== null) {
        this.fragment_size = args.fragment_size;
      }
      if (args.page_size !== undefined && args.page_size !== null) {
        this.page_size = args.page_size;
      }
      if (args.max_rows !== undefined && args.max_rows !== null) {
        this.max_rows = args.max_rows;
      }
      if (args.view_sql !== undefined && args.view_sql !== null) {
        this.view_sql = args.view_sql;
      }
      if (args.shard_count !== undefined && args.shard_count !== null) {
        this.shard_count = args.shard_count;
      }
      if (args.key_metainfo !== undefined && args.key_metainfo !== null) {
        this.key_metainfo = args.key_metainfo;
      }
      if (args.is_temporary !== undefined && args.is_temporary !== null) {
        this.is_temporary = args.is_temporary;
      }
      if (args.partition_detail !== undefined && args.partition_detail !== null) {
        this.partition_detail = args.partition_detail;
      }
      if (args.table_type !== undefined && args.table_type !== null) {
        this.table_type = args.table_type;
      }
      if (args.refresh_info !== undefined && args.refresh_info !== null) {
        this.refresh_info = new ttypes.TTableRefreshInfo(args.refresh_info);
      }
      if (args.sharded_column_name !== undefined && args.sharded_column_name !== null) {
        this.sharded_column_name = args.sharded_column_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.row_desc = [];
          const _rtmp3101 = input.readListBegin();
          const _size100 = _rtmp3101.size || 0;
          for (let _i102 = 0; _i102 < _size100; ++_i102) {
            let elem103 = null;
            elem103 = new ttypes.TColumnType();
            elem103.read(input);
            this.row_desc.push(elem103);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.fragment_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.page_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.max_rows = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.view_sql = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.shard_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.key_metainfo = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.is_temporary = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.partition_detail = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.table_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.refresh_info = new ttypes.TTableRefreshInfo();
          this.refresh_info.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.sharded_column_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableDetails');
    if (this.row_desc !== null && this.row_desc !== undefined) {
      output.writeFieldBegin('row_desc', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_desc.length);
      for (let iter104 in this.row_desc) {
        if (this.row_desc.hasOwnProperty(iter104)) {
          iter104 = this.row_desc[iter104];
          iter104.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.fragment_size !== null && this.fragment_size !== undefined) {
      output.writeFieldBegin('fragment_size', Thrift.Type.I64, 2);
      output.writeI64(this.fragment_size);
      output.writeFieldEnd();
    }
    if (this.page_size !== null && this.page_size !== undefined) {
      output.writeFieldBegin('page_size', Thrift.Type.I64, 3);
      output.writeI64(this.page_size);
      output.writeFieldEnd();
    }
    if (this.max_rows !== null && this.max_rows !== undefined) {
      output.writeFieldBegin('max_rows', Thrift.Type.I64, 4);
      output.writeI64(this.max_rows);
      output.writeFieldEnd();
    }
    if (this.view_sql !== null && this.view_sql !== undefined) {
      output.writeFieldBegin('view_sql', Thrift.Type.STRING, 5);
      output.writeString(this.view_sql);
      output.writeFieldEnd();
    }
    if (this.shard_count !== null && this.shard_count !== undefined) {
      output.writeFieldBegin('shard_count', Thrift.Type.I64, 6);
      output.writeI64(this.shard_count);
      output.writeFieldEnd();
    }
    if (this.key_metainfo !== null && this.key_metainfo !== undefined) {
      output.writeFieldBegin('key_metainfo', Thrift.Type.STRING, 7);
      output.writeString(this.key_metainfo);
      output.writeFieldEnd();
    }
    if (this.is_temporary !== null && this.is_temporary !== undefined) {
      output.writeFieldBegin('is_temporary', Thrift.Type.BOOL, 8);
      output.writeBool(this.is_temporary);
      output.writeFieldEnd();
    }
    if (this.partition_detail !== null && this.partition_detail !== undefined) {
      output.writeFieldBegin('partition_detail', Thrift.Type.I32, 9);
      output.writeI32(this.partition_detail);
      output.writeFieldEnd();
    }
    if (this.table_type !== null && this.table_type !== undefined) {
      output.writeFieldBegin('table_type', Thrift.Type.I32, 10);
      output.writeI32(this.table_type);
      output.writeFieldEnd();
    }
    if (this.refresh_info !== null && this.refresh_info !== undefined) {
      output.writeFieldBegin('refresh_info', Thrift.Type.STRUCT, 11);
      this.refresh_info.write(output);
      output.writeFieldEnd();
    }
    if (this.sharded_column_name !== null && this.sharded_column_name !== undefined) {
      output.writeFieldBegin('sharded_column_name', Thrift.Type.STRING, 12);
      output.writeString(this.sharded_column_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColumnRange = module.exports.TColumnRange = class {
  constructor(args) {
    this.type = null;
    this.col_id = null;
    this.table_id = null;
    this.has_nulls = null;
    this.int_min = null;
    this.int_max = null;
    this.bucket = null;
    this.fp_min = null;
    this.fp_max = null;
    this.db_id = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.col_id !== undefined && args.col_id !== null) {
        this.col_id = args.col_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.has_nulls !== undefined && args.has_nulls !== null) {
        this.has_nulls = args.has_nulls;
      }
      if (args.int_min !== undefined && args.int_min !== null) {
        this.int_min = args.int_min;
      }
      if (args.int_max !== undefined && args.int_max !== null) {
        this.int_max = args.int_max;
      }
      if (args.bucket !== undefined && args.bucket !== null) {
        this.bucket = args.bucket;
      }
      if (args.fp_min !== undefined && args.fp_min !== null) {
        this.fp_min = args.fp_min;
      }
      if (args.fp_max !== undefined && args.fp_max !== null) {
        this.fp_max = args.fp_max;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.col_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.has_nulls = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.int_min = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.int_max = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.bucket = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.DOUBLE) {
          this.fp_min = input.readDouble();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.DOUBLE) {
          this.fp_max = input.readDouble();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColumnRange');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.col_id !== null && this.col_id !== undefined) {
      output.writeFieldBegin('col_id', Thrift.Type.I32, 2);
      output.writeI32(this.col_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 3);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.has_nulls !== null && this.has_nulls !== undefined) {
      output.writeFieldBegin('has_nulls', Thrift.Type.BOOL, 4);
      output.writeBool(this.has_nulls);
      output.writeFieldEnd();
    }
    if (this.int_min !== null && this.int_min !== undefined) {
      output.writeFieldBegin('int_min', Thrift.Type.I64, 5);
      output.writeI64(this.int_min);
      output.writeFieldEnd();
    }
    if (this.int_max !== null && this.int_max !== undefined) {
      output.writeFieldBegin('int_max', Thrift.Type.I64, 6);
      output.writeI64(this.int_max);
      output.writeFieldEnd();
    }
    if (this.bucket !== null && this.bucket !== undefined) {
      output.writeFieldBegin('bucket', Thrift.Type.I64, 7);
      output.writeI64(this.bucket);
      output.writeFieldEnd();
    }
    if (this.fp_min !== null && this.fp_min !== undefined) {
      output.writeFieldBegin('fp_min', Thrift.Type.DOUBLE, 8);
      output.writeDouble(this.fp_min);
      output.writeFieldEnd();
    }
    if (this.fp_max !== null && this.fp_max !== undefined) {
      output.writeFieldBegin('fp_max', Thrift.Type.DOUBLE, 9);
      output.writeDouble(this.fp_max);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 10);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDictionaryGeneration = module.exports.TDictionaryGeneration = class {
  constructor(args) {
    this.dict_id = null;
    this.entry_count = null;
    this.db_id = null;
    if (args) {
      if (args.dict_id !== undefined && args.dict_id !== null) {
        this.dict_id = args.dict_id;
      }
      if (args.entry_count !== undefined && args.entry_count !== null) {
        this.entry_count = args.entry_count;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.dict_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.entry_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDictionaryGeneration');
    if (this.dict_id !== null && this.dict_id !== undefined) {
      output.writeFieldBegin('dict_id', Thrift.Type.I32, 1);
      output.writeI32(this.dict_id);
      output.writeFieldEnd();
    }
    if (this.entry_count !== null && this.entry_count !== undefined) {
      output.writeFieldBegin('entry_count', Thrift.Type.I64, 2);
      output.writeI64(this.entry_count);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 3);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableGeneration = module.exports.TTableGeneration = class {
  constructor(args) {
    this.table_id = null;
    this.tuple_count = null;
    this.start_rowid = null;
    this.db_id = null;
    if (args) {
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.tuple_count !== undefined && args.tuple_count !== null) {
        this.tuple_count = args.tuple_count;
      }
      if (args.start_rowid !== undefined && args.start_rowid !== null) {
        this.start_rowid = args.start_rowid;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.tuple_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.start_rowid = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableGeneration');
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 1);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.tuple_count !== null && this.tuple_count !== undefined) {
      output.writeFieldBegin('tuple_count', Thrift.Type.I64, 2);
      output.writeI64(this.tuple_count);
      output.writeFieldEnd();
    }
    if (this.start_rowid !== null && this.start_rowid !== undefined) {
      output.writeFieldBegin('start_rowid', Thrift.Type.I64, 3);
      output.writeI64(this.start_rowid);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 4);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableCacheStatus = module.exports.TTableCacheStatus = class {
  constructor(args) {
    this.table_id = null;
    this.db_id = null;
    this.is_cached_on_disk = null;
    if (args) {
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.is_cached_on_disk !== undefined && args.is_cached_on_disk !== null) {
        this.is_cached_on_disk = args.is_cached_on_disk;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.is_cached_on_disk = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableCacheStatus');
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 1);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 2);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.is_cached_on_disk !== null && this.is_cached_on_disk !== undefined) {
      output.writeFieldBegin('is_cached_on_disk', Thrift.Type.BOOL, 3);
      output.writeBool(this.is_cached_on_disk);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TPendingQuery = module.exports.TPendingQuery = class {
  constructor(args) {
    this.id = null;
    this.column_ranges = null;
    this.dictionary_generations = null;
    this.table_generations = null;
    this.parent_session_id = null;
    this.table_cache_status = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.column_ranges !== undefined && args.column_ranges !== null) {
        this.column_ranges = Thrift.copyList(args.column_ranges, [ttypes.TColumnRange]);
      }
      if (args.dictionary_generations !== undefined && args.dictionary_generations !== null) {
        this.dictionary_generations = Thrift.copyList(args.dictionary_generations, [ttypes.TDictionaryGeneration]);
      }
      if (args.table_generations !== undefined && args.table_generations !== null) {
        this.table_generations = Thrift.copyList(args.table_generations, [ttypes.TTableGeneration]);
      }
      if (args.parent_session_id !== undefined && args.parent_session_id !== null) {
        this.parent_session_id = args.parent_session_id;
      }
      if (args.table_cache_status !== undefined && args.table_cache_status !== null) {
        this.table_cache_status = Thrift.copyList(args.table_cache_status, [ttypes.TTableCacheStatus]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.column_ranges = [];
          const _rtmp3106 = input.readListBegin();
          const _size105 = _rtmp3106.size || 0;
          for (let _i107 = 0; _i107 < _size105; ++_i107) {
            let elem108 = null;
            elem108 = new ttypes.TColumnRange();
            elem108.read(input);
            this.column_ranges.push(elem108);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.dictionary_generations = [];
          const _rtmp3110 = input.readListBegin();
          const _size109 = _rtmp3110.size || 0;
          for (let _i111 = 0; _i111 < _size109; ++_i111) {
            let elem112 = null;
            elem112 = new ttypes.TDictionaryGeneration();
            elem112.read(input);
            this.dictionary_generations.push(elem112);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.table_generations = [];
          const _rtmp3114 = input.readListBegin();
          const _size113 = _rtmp3114.size || 0;
          for (let _i115 = 0; _i115 < _size113; ++_i115) {
            let elem116 = null;
            elem116 = new ttypes.TTableGeneration();
            elem116.read(input);
            this.table_generations.push(elem116);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.parent_session_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.table_cache_status = [];
          const _rtmp3118 = input.readListBegin();
          const _size117 = _rtmp3118.size || 0;
          for (let _i119 = 0; _i119 < _size117; ++_i119) {
            let elem120 = null;
            elem120 = new ttypes.TTableCacheStatus();
            elem120.read(input);
            this.table_cache_status.push(elem120);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TPendingQuery');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.I64, 1);
      output.writeI64(this.id);
      output.writeFieldEnd();
    }
    if (this.column_ranges !== null && this.column_ranges !== undefined) {
      output.writeFieldBegin('column_ranges', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.column_ranges.length);
      for (let iter121 in this.column_ranges) {
        if (this.column_ranges.hasOwnProperty(iter121)) {
          iter121 = this.column_ranges[iter121];
          iter121.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.dictionary_generations !== null && this.dictionary_generations !== undefined) {
      output.writeFieldBegin('dictionary_generations', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.dictionary_generations.length);
      for (let iter122 in this.dictionary_generations) {
        if (this.dictionary_generations.hasOwnProperty(iter122)) {
          iter122 = this.dictionary_generations[iter122];
          iter122.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.table_generations !== null && this.table_generations !== undefined) {
      output.writeFieldBegin('table_generations', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.table_generations.length);
      for (let iter123 in this.table_generations) {
        if (this.table_generations.hasOwnProperty(iter123)) {
          iter123 = this.table_generations[iter123];
          iter123.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.parent_session_id !== null && this.parent_session_id !== undefined) {
      output.writeFieldBegin('parent_session_id', Thrift.Type.STRING, 5);
      output.writeString(this.parent_session_id);
      output.writeFieldEnd();
    }
    if (this.table_cache_status !== null && this.table_cache_status !== undefined) {
      output.writeFieldBegin('table_cache_status', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.table_cache_status.length);
      for (let iter124 in this.table_cache_status) {
        if (this.table_cache_status.hasOwnProperty(iter124)) {
          iter124 = this.table_cache_status[iter124];
          iter124.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TVarLen = module.exports.TVarLen = class {
  constructor(args) {
    this.payload = null;
    this.is_null = null;
    if (args) {
      if (args.payload !== undefined && args.payload !== null) {
        this.payload = args.payload;
      }
      if (args.is_null !== undefined && args.is_null !== null) {
        this.is_null = args.is_null;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.payload = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.is_null = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TVarLen');
    if (this.payload !== null && this.payload !== undefined) {
      output.writeFieldBegin('payload', Thrift.Type.STRING, 1);
      output.writeBinary(this.payload);
      output.writeFieldEnd();
    }
    if (this.is_null !== null && this.is_null !== undefined) {
      output.writeFieldBegin('is_null', Thrift.Type.BOOL, 2);
      output.writeBool(this.is_null);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDataBlockPtr = module.exports.TDataBlockPtr = class {
  constructor(args) {
    this.fixed_len_data = null;
    this.var_len_data = null;
    if (args) {
      if (args.fixed_len_data !== undefined && args.fixed_len_data !== null) {
        this.fixed_len_data = args.fixed_len_data;
      }
      if (args.var_len_data !== undefined && args.var_len_data !== null) {
        this.var_len_data = Thrift.copyList(args.var_len_data, [ttypes.TVarLen]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.fixed_len_data = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.var_len_data = [];
          const _rtmp3126 = input.readListBegin();
          const _size125 = _rtmp3126.size || 0;
          for (let _i127 = 0; _i127 < _size125; ++_i127) {
            let elem128 = null;
            elem128 = new ttypes.TVarLen();
            elem128.read(input);
            this.var_len_data.push(elem128);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDataBlockPtr');
    if (this.fixed_len_data !== null && this.fixed_len_data !== undefined) {
      output.writeFieldBegin('fixed_len_data', Thrift.Type.STRING, 1);
      output.writeBinary(this.fixed_len_data);
      output.writeFieldEnd();
    }
    if (this.var_len_data !== null && this.var_len_data !== undefined) {
      output.writeFieldBegin('var_len_data', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.var_len_data.length);
      for (let iter129 in this.var_len_data) {
        if (this.var_len_data.hasOwnProperty(iter129)) {
          iter129 = this.var_len_data[iter129];
          iter129.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TInsertData = module.exports.TInsertData = class {
  constructor(args) {
    this.db_id = null;
    this.table_id = null;
    this.column_ids = null;
    this.data = null;
    this.num_rows = null;
    this.is_default = null;
    if (args) {
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.column_ids !== undefined && args.column_ids !== null) {
        this.column_ids = Thrift.copyList(args.column_ids, [null]);
      }
      if (args.data !== undefined && args.data !== null) {
        this.data = Thrift.copyList(args.data, [ttypes.TDataBlockPtr]);
      }
      if (args.num_rows !== undefined && args.num_rows !== null) {
        this.num_rows = args.num_rows;
      }
      if (args.is_default !== undefined && args.is_default !== null) {
        this.is_default = Thrift.copyList(args.is_default, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.column_ids = [];
          const _rtmp3131 = input.readListBegin();
          const _size130 = _rtmp3131.size || 0;
          for (let _i132 = 0; _i132 < _size130; ++_i132) {
            let elem133 = null;
            elem133 = input.readI32();
            this.column_ids.push(elem133);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.data = [];
          const _rtmp3135 = input.readListBegin();
          const _size134 = _rtmp3135.size || 0;
          for (let _i136 = 0; _i136 < _size134; ++_i136) {
            let elem137 = null;
            elem137 = new ttypes.TDataBlockPtr();
            elem137.read(input);
            this.data.push(elem137);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.num_rows = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.is_default = [];
          const _rtmp3139 = input.readListBegin();
          const _size138 = _rtmp3139.size || 0;
          for (let _i140 = 0; _i140 < _size138; ++_i140) {
            let elem141 = null;
            elem141 = input.readBool();
            this.is_default.push(elem141);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TInsertData');
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 1);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 2);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.column_ids !== null && this.column_ids !== undefined) {
      output.writeFieldBegin('column_ids', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.I32, this.column_ids.length);
      for (let iter142 in this.column_ids) {
        if (this.column_ids.hasOwnProperty(iter142)) {
          iter142 = this.column_ids[iter142];
          output.writeI32(iter142);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.data !== null && this.data !== undefined) {
      output.writeFieldBegin('data', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.data.length);
      for (let iter143 in this.data) {
        if (this.data.hasOwnProperty(iter143)) {
          iter143 = this.data[iter143];
          iter143.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
      output.writeFieldBegin('num_rows', Thrift.Type.I64, 5);
      output.writeI64(this.num_rows);
      output.writeFieldEnd();
    }
    if (this.is_default !== null && this.is_default !== undefined) {
      output.writeFieldBegin('is_default', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.BOOL, this.is_default.length);
      for (let iter144 in this.is_default) {
        if (this.is_default.hasOwnProperty(iter144)) {
          iter144 = this.is_default[iter144];
          output.writeBool(iter144);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TChunkData = module.exports.TChunkData = class {
  constructor(args) {
    this.data_buffer = null;
    this.index_buffer = null;
    if (args) {
      if (args.data_buffer !== undefined && args.data_buffer !== null) {
        this.data_buffer = args.data_buffer;
      }
      if (args.index_buffer !== undefined && args.index_buffer !== null) {
        this.index_buffer = args.index_buffer;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.data_buffer = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.index_buffer = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TChunkData');
    if (this.data_buffer !== null && this.data_buffer !== undefined) {
      output.writeFieldBegin('data_buffer', Thrift.Type.STRING, 1);
      output.writeBinary(this.data_buffer);
      output.writeFieldEnd();
    }
    if (this.index_buffer !== null && this.index_buffer !== undefined) {
      output.writeFieldBegin('index_buffer', Thrift.Type.STRING, 2);
      output.writeBinary(this.index_buffer);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TInsertChunks = module.exports.TInsertChunks = class {
  constructor(args) {
    this.db_id = null;
    this.table_id = null;
    this.data = null;
    this.valid_indices = null;
    this.num_rows = null;
    if (args) {
      if (args.db_id !== undefined && args.db_id !== null) {
        this.db_id = args.db_id;
      }
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.data !== undefined && args.data !== null) {
        this.data = Thrift.copyList(args.data, [ttypes.TChunkData]);
      }
      if (args.valid_indices !== undefined && args.valid_indices !== null) {
        this.valid_indices = Thrift.copyList(args.valid_indices, [null]);
      }
      if (args.num_rows !== undefined && args.num_rows !== null) {
        this.num_rows = args.num_rows;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.db_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.data = [];
          const _rtmp3146 = input.readListBegin();
          const _size145 = _rtmp3146.size || 0;
          for (let _i147 = 0; _i147 < _size145; ++_i147) {
            let elem148 = null;
            elem148 = new ttypes.TChunkData();
            elem148.read(input);
            this.data.push(elem148);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.valid_indices = [];
          const _rtmp3150 = input.readListBegin();
          const _size149 = _rtmp3150.size || 0;
          for (let _i151 = 0; _i151 < _size149; ++_i151) {
            let elem152 = null;
            elem152 = input.readI64();
            this.valid_indices.push(elem152);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.num_rows = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TInsertChunks');
    if (this.db_id !== null && this.db_id !== undefined) {
      output.writeFieldBegin('db_id', Thrift.Type.I32, 1);
      output.writeI32(this.db_id);
      output.writeFieldEnd();
    }
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 2);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.data !== null && this.data !== undefined) {
      output.writeFieldBegin('data', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.data.length);
      for (let iter153 in this.data) {
        if (this.data.hasOwnProperty(iter153)) {
          iter153 = this.data[iter153];
          iter153.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.valid_indices !== null && this.valid_indices !== undefined) {
      output.writeFieldBegin('valid_indices', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.I64, this.valid_indices.length);
      for (let iter154 in this.valid_indices) {
        if (this.valid_indices.hasOwnProperty(iter154)) {
          iter154 = this.valid_indices[iter154];
          output.writeI64(iter154);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
      output.writeFieldBegin('num_rows', Thrift.Type.I64, 5);
      output.writeI64(this.num_rows);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TPendingRenderQuery = module.exports.TPendingRenderQuery = class {
  constructor(args) {
    this.id = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.id = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TPendingRenderQuery');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.I64, 1);
      output.writeI64(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRenderParseResult = module.exports.TRenderParseResult = class {
  constructor(args) {
    this.merge_type = null;
    this.node_id = null;
    this.execution_time_ms = null;
    this.render_time_ms = null;
    this.total_time_ms = null;
    if (args) {
      if (args.merge_type !== undefined && args.merge_type !== null) {
        this.merge_type = args.merge_type;
      }
      if (args.node_id !== undefined && args.node_id !== null) {
        this.node_id = args.node_id;
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.render_time_ms !== undefined && args.render_time_ms !== null) {
        this.render_time_ms = args.render_time_ms;
      }
      if (args.total_time_ms !== undefined && args.total_time_ms !== null) {
        this.total_time_ms = args.total_time_ms;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.merge_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.node_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.render_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.total_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRenderParseResult');
    if (this.merge_type !== null && this.merge_type !== undefined) {
      output.writeFieldBegin('merge_type', Thrift.Type.I32, 1);
      output.writeI32(this.merge_type);
      output.writeFieldEnd();
    }
    if (this.node_id !== null && this.node_id !== undefined) {
      output.writeFieldBegin('node_id', Thrift.Type.I32, 2);
      output.writeI32(this.node_id);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 3);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.render_time_ms !== null && this.render_time_ms !== undefined) {
      output.writeFieldBegin('render_time_ms', Thrift.Type.I64, 4);
      output.writeI64(this.render_time_ms);
      output.writeFieldEnd();
    }
    if (this.total_time_ms !== null && this.total_time_ms !== undefined) {
      output.writeFieldBegin('total_time_ms', Thrift.Type.I64, 5);
      output.writeI64(this.total_time_ms);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRawRenderPassDataResult = module.exports.TRawRenderPassDataResult = class {
  constructor(args) {
    this.num_pixel_channels = null;
    this.num_pixel_samples = null;
    this.pixels = null;
    this.row_ids_A = null;
    this.row_ids_B = null;
    this.table_ids = null;
    this.accum_data = null;
    this.accum_depth = null;
    if (args) {
      if (args.num_pixel_channels !== undefined && args.num_pixel_channels !== null) {
        this.num_pixel_channels = args.num_pixel_channels;
      }
      if (args.num_pixel_samples !== undefined && args.num_pixel_samples !== null) {
        this.num_pixel_samples = args.num_pixel_samples;
      }
      if (args.pixels !== undefined && args.pixels !== null) {
        this.pixels = args.pixels;
      }
      if (args.row_ids_A !== undefined && args.row_ids_A !== null) {
        this.row_ids_A = args.row_ids_A;
      }
      if (args.row_ids_B !== undefined && args.row_ids_B !== null) {
        this.row_ids_B = args.row_ids_B;
      }
      if (args.table_ids !== undefined && args.table_ids !== null) {
        this.table_ids = args.table_ids;
      }
      if (args.accum_data !== undefined && args.accum_data !== null) {
        this.accum_data = args.accum_data;
      }
      if (args.accum_depth !== undefined && args.accum_depth !== null) {
        this.accum_depth = args.accum_depth;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.num_pixel_channels = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.num_pixel_samples = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pixels = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.row_ids_A = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.row_ids_B = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.table_ids = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.accum_data = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.accum_depth = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRawRenderPassDataResult');
    if (this.num_pixel_channels !== null && this.num_pixel_channels !== undefined) {
      output.writeFieldBegin('num_pixel_channels', Thrift.Type.I32, 1);
      output.writeI32(this.num_pixel_channels);
      output.writeFieldEnd();
    }
    if (this.num_pixel_samples !== null && this.num_pixel_samples !== undefined) {
      output.writeFieldBegin('num_pixel_samples', Thrift.Type.I32, 2);
      output.writeI32(this.num_pixel_samples);
      output.writeFieldEnd();
    }
    if (this.pixels !== null && this.pixels !== undefined) {
      output.writeFieldBegin('pixels', Thrift.Type.STRING, 3);
      output.writeBinary(this.pixels);
      output.writeFieldEnd();
    }
    if (this.row_ids_A !== null && this.row_ids_A !== undefined) {
      output.writeFieldBegin('row_ids_A', Thrift.Type.STRING, 4);
      output.writeBinary(this.row_ids_A);
      output.writeFieldEnd();
    }
    if (this.row_ids_B !== null && this.row_ids_B !== undefined) {
      output.writeFieldBegin('row_ids_B', Thrift.Type.STRING, 5);
      output.writeBinary(this.row_ids_B);
      output.writeFieldEnd();
    }
    if (this.table_ids !== null && this.table_ids !== undefined) {
      output.writeFieldBegin('table_ids', Thrift.Type.STRING, 6);
      output.writeBinary(this.table_ids);
      output.writeFieldEnd();
    }
    if (this.accum_data !== null && this.accum_data !== undefined) {
      output.writeFieldBegin('accum_data', Thrift.Type.STRING, 7);
      output.writeBinary(this.accum_data);
      output.writeFieldEnd();
    }
    if (this.accum_depth !== null && this.accum_depth !== undefined) {
      output.writeFieldBegin('accum_depth', Thrift.Type.I32, 8);
      output.writeI32(this.accum_depth);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRawPixelData = module.exports.TRawPixelData = class {
  constructor(args) {
    this.width = null;
    this.height = null;
    this.render_pass_map = null;
    if (args) {
      if (args.width !== undefined && args.width !== null) {
        this.width = args.width;
      }
      if (args.height !== undefined && args.height !== null) {
        this.height = args.height;
      }
      if (args.render_pass_map !== undefined && args.render_pass_map !== null) {
        this.render_pass_map = Thrift.copyMap(args.render_pass_map, [ttypes.TRawRenderPassDataResult]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.width = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.height = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.render_pass_map = {};
          const _rtmp3156 = input.readMapBegin();
          const _size155 = _rtmp3156.size || 0;
          for (let _i157 = 0; _i157 < _size155; ++_i157) {
            let key158 = null;
            let val159 = null;
            key158 = input.readI32();
            val159 = new ttypes.TRawRenderPassDataResult();
            val159.read(input);
            this.render_pass_map[key158] = val159;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRawPixelData');
    if (this.width !== null && this.width !== undefined) {
      output.writeFieldBegin('width', Thrift.Type.I32, 1);
      output.writeI32(this.width);
      output.writeFieldEnd();
    }
    if (this.height !== null && this.height !== undefined) {
      output.writeFieldBegin('height', Thrift.Type.I32, 2);
      output.writeI32(this.height);
      output.writeFieldEnd();
    }
    if (this.render_pass_map !== null && this.render_pass_map !== undefined) {
      output.writeFieldBegin('render_pass_map', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRUCT, Thrift.objectLength(this.render_pass_map));
      for (let kiter160 in this.render_pass_map) {
        if (this.render_pass_map.hasOwnProperty(kiter160)) {
          let viter161 = this.render_pass_map[kiter160];
          output.writeI32(kiter160);
          viter161.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRenderDatum = module.exports.TRenderDatum = class {
  constructor(args) {
    this.type = null;
    this.cnt = null;
    this.value = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.cnt !== undefined && args.cnt !== null) {
        this.cnt = args.cnt;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.cnt = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRenderDatum');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.cnt !== null && this.cnt !== undefined) {
      output.writeFieldBegin('cnt', Thrift.Type.I32, 2);
      output.writeI32(this.cnt);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeBinary(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TRenderStepResult = module.exports.TRenderStepResult = class {
  constructor(args) {
    this.merge_data = null;
    this.raw_pixel_data = null;
    this.execution_time_ms = null;
    this.render_time_ms = null;
    this.total_time_ms = null;
    if (args) {
      if (args.merge_data !== undefined && args.merge_data !== null) {
        this.merge_data = Thrift.copyMap(args.merge_data, [Thrift.copyMap, Thrift.copyMap, Thrift.copyMap, Thrift.copyList, ttypes.TRenderDatum]);
      }
      if (args.raw_pixel_data !== undefined && args.raw_pixel_data !== null) {
        this.raw_pixel_data = new ttypes.TRawPixelData(args.raw_pixel_data);
      }
      if (args.execution_time_ms !== undefined && args.execution_time_ms !== null) {
        this.execution_time_ms = args.execution_time_ms;
      }
      if (args.render_time_ms !== undefined && args.render_time_ms !== null) {
        this.render_time_ms = args.render_time_ms;
      }
      if (args.total_time_ms !== undefined && args.total_time_ms !== null) {
        this.total_time_ms = args.total_time_ms;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.MAP) {
          this.merge_data = {};
          const _rtmp3163 = input.readMapBegin();
          const _size162 = _rtmp3163.size || 0;
          for (let _i164 = 0; _i164 < _size162; ++_i164) {
            let key165 = null;
            let val166 = null;
            key165 = input.readString();
            val166 = {};
            const _rtmp3168 = input.readMapBegin();
            const _size167 = _rtmp3168.size || 0;
            for (let _i169 = 0; _i169 < _size167; ++_i169) {
              let key170 = null;
              let val171 = null;
              key170 = input.readString();
              val171 = {};
              const _rtmp3173 = input.readMapBegin();
              const _size172 = _rtmp3173.size || 0;
              for (let _i174 = 0; _i174 < _size172; ++_i174) {
                let key175 = null;
                let val176 = null;
                key175 = input.readString();
                val176 = {};
                const _rtmp3178 = input.readMapBegin();
                const _size177 = _rtmp3178.size || 0;
                for (let _i179 = 0; _i179 < _size177; ++_i179) {
                  let key180 = null;
                  let val181 = null;
                  key180 = input.readString();
                  val181 = [];
                  const _rtmp3183 = input.readListBegin();
                  const _size182 = _rtmp3183.size || 0;
                  for (let _i184 = 0; _i184 < _size182; ++_i184) {
                    let elem185 = null;
                    elem185 = new ttypes.TRenderDatum();
                    elem185.read(input);
                    val181.push(elem185);
                  }
                  input.readListEnd();
                  val176[key180] = val181;
                }
                input.readMapEnd();
                val171[key175] = val176;
              }
              input.readMapEnd();
              val166[key170] = val171;
            }
            input.readMapEnd();
            this.merge_data[key165] = val166;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.raw_pixel_data = new ttypes.TRawPixelData();
          this.raw_pixel_data.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.execution_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.render_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.total_time_ms = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TRenderStepResult');
    if (this.merge_data !== null && this.merge_data !== undefined) {
      output.writeFieldBegin('merge_data', Thrift.Type.MAP, 1);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.merge_data));
      for (let kiter186 in this.merge_data) {
        if (this.merge_data.hasOwnProperty(kiter186)) {
          let viter187 = this.merge_data[kiter186];
          output.writeString(kiter186);
          output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(viter187));
          for (let kiter188 in viter187) {
            if (viter187.hasOwnProperty(kiter188)) {
              let viter189 = viter187[kiter188];
              output.writeString(kiter188);
              output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(viter189));
              for (let kiter190 in viter189) {
                if (viter189.hasOwnProperty(kiter190)) {
                  let viter191 = viter189[kiter190];
                  output.writeString(kiter190);
                  output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter191));
                  for (let kiter192 in viter191) {
                    if (viter191.hasOwnProperty(kiter192)) {
                      let viter193 = viter191[kiter192];
                      output.writeString(kiter192);
                      output.writeListBegin(Thrift.Type.STRUCT, viter193.length);
                      for (let iter194 in viter193) {
                        if (viter193.hasOwnProperty(iter194)) {
                          iter194 = viter193[iter194];
                          iter194.write(output);
                        }
                      }
                      output.writeListEnd();
                    }
                  }
                  output.writeMapEnd();
                }
              }
              output.writeMapEnd();
            }
          }
          output.writeMapEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.raw_pixel_data !== null && this.raw_pixel_data !== undefined) {
      output.writeFieldBegin('raw_pixel_data', Thrift.Type.STRUCT, 2);
      this.raw_pixel_data.write(output);
      output.writeFieldEnd();
    }
    if (this.execution_time_ms !== null && this.execution_time_ms !== undefined) {
      output.writeFieldBegin('execution_time_ms', Thrift.Type.I64, 3);
      output.writeI64(this.execution_time_ms);
      output.writeFieldEnd();
    }
    if (this.render_time_ms !== null && this.render_time_ms !== undefined) {
      output.writeFieldBegin('render_time_ms', Thrift.Type.I64, 4);
      output.writeI64(this.render_time_ms);
      output.writeFieldEnd();
    }
    if (this.total_time_ms !== null && this.total_time_ms !== undefined) {
      output.writeFieldBegin('total_time_ms', Thrift.Type.I64, 5);
      output.writeI64(this.total_time_ms);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDatabasePermissions = module.exports.TDatabasePermissions = class {
  constructor(args) {
    this.create_ = null;
    this.delete_ = null;
    this.view_sql_editor_ = null;
    this.access_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.delete_ !== undefined && args.delete_ !== null) {
        this.delete_ = args.delete_;
      }
      if (args.view_sql_editor_ !== undefined && args.view_sql_editor_ !== null) {
        this.view_sql_editor_ = args.view_sql_editor_;
      }
      if (args.access_ !== undefined && args.access_ !== null) {
        this.access_ = args.access_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.delete_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.view_sql_editor_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.access_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDatabasePermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.delete_ !== null && this.delete_ !== undefined) {
      output.writeFieldBegin('delete_', Thrift.Type.BOOL, 2);
      output.writeBool(this.delete_);
      output.writeFieldEnd();
    }
    if (this.view_sql_editor_ !== null && this.view_sql_editor_ !== undefined) {
      output.writeFieldBegin('view_sql_editor_', Thrift.Type.BOOL, 3);
      output.writeBool(this.view_sql_editor_);
      output.writeFieldEnd();
    }
    if (this.access_ !== null && this.access_ !== undefined) {
      output.writeFieldBegin('access_', Thrift.Type.BOOL, 4);
      output.writeBool(this.access_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTablePermissions = module.exports.TTablePermissions = class {
  constructor(args) {
    this.create_ = null;
    this.drop_ = null;
    this.select_ = null;
    this.insert_ = null;
    this.update_ = null;
    this.delete_ = null;
    this.truncate_ = null;
    this.alter_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.drop_ !== undefined && args.drop_ !== null) {
        this.drop_ = args.drop_;
      }
      if (args.select_ !== undefined && args.select_ !== null) {
        this.select_ = args.select_;
      }
      if (args.insert_ !== undefined && args.insert_ !== null) {
        this.insert_ = args.insert_;
      }
      if (args.update_ !== undefined && args.update_ !== null) {
        this.update_ = args.update_;
      }
      if (args.delete_ !== undefined && args.delete_ !== null) {
        this.delete_ = args.delete_;
      }
      if (args.truncate_ !== undefined && args.truncate_ !== null) {
        this.truncate_ = args.truncate_;
      }
      if (args.alter_ !== undefined && args.alter_ !== null) {
        this.alter_ = args.alter_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.drop_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.select_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.insert_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.update_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.delete_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.truncate_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.alter_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTablePermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.drop_ !== null && this.drop_ !== undefined) {
      output.writeFieldBegin('drop_', Thrift.Type.BOOL, 2);
      output.writeBool(this.drop_);
      output.writeFieldEnd();
    }
    if (this.select_ !== null && this.select_ !== undefined) {
      output.writeFieldBegin('select_', Thrift.Type.BOOL, 3);
      output.writeBool(this.select_);
      output.writeFieldEnd();
    }
    if (this.insert_ !== null && this.insert_ !== undefined) {
      output.writeFieldBegin('insert_', Thrift.Type.BOOL, 4);
      output.writeBool(this.insert_);
      output.writeFieldEnd();
    }
    if (this.update_ !== null && this.update_ !== undefined) {
      output.writeFieldBegin('update_', Thrift.Type.BOOL, 5);
      output.writeBool(this.update_);
      output.writeFieldEnd();
    }
    if (this.delete_ !== null && this.delete_ !== undefined) {
      output.writeFieldBegin('delete_', Thrift.Type.BOOL, 6);
      output.writeBool(this.delete_);
      output.writeFieldEnd();
    }
    if (this.truncate_ !== null && this.truncate_ !== undefined) {
      output.writeFieldBegin('truncate_', Thrift.Type.BOOL, 7);
      output.writeBool(this.truncate_);
      output.writeFieldEnd();
    }
    if (this.alter_ !== null && this.alter_ !== undefined) {
      output.writeFieldBegin('alter_', Thrift.Type.BOOL, 8);
      output.writeBool(this.alter_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDashboardPermissions = module.exports.TDashboardPermissions = class {
  constructor(args) {
    this.create_ = null;
    this.delete_ = null;
    this.view_ = null;
    this.edit_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.delete_ !== undefined && args.delete_ !== null) {
        this.delete_ = args.delete_;
      }
      if (args.view_ !== undefined && args.view_ !== null) {
        this.view_ = args.view_;
      }
      if (args.edit_ !== undefined && args.edit_ !== null) {
        this.edit_ = args.edit_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.delete_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.view_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.edit_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDashboardPermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.delete_ !== null && this.delete_ !== undefined) {
      output.writeFieldBegin('delete_', Thrift.Type.BOOL, 2);
      output.writeBool(this.delete_);
      output.writeFieldEnd();
    }
    if (this.view_ !== null && this.view_ !== undefined) {
      output.writeFieldBegin('view_', Thrift.Type.BOOL, 3);
      output.writeBool(this.view_);
      output.writeFieldEnd();
    }
    if (this.edit_ !== null && this.edit_ !== undefined) {
      output.writeFieldBegin('edit_', Thrift.Type.BOOL, 4);
      output.writeBool(this.edit_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TViewPermissions = module.exports.TViewPermissions = class {
  constructor(args) {
    this.create_ = null;
    this.drop_ = null;
    this.select_ = null;
    this.insert_ = null;
    this.update_ = null;
    this.delete_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.drop_ !== undefined && args.drop_ !== null) {
        this.drop_ = args.drop_;
      }
      if (args.select_ !== undefined && args.select_ !== null) {
        this.select_ = args.select_;
      }
      if (args.insert_ !== undefined && args.insert_ !== null) {
        this.insert_ = args.insert_;
      }
      if (args.update_ !== undefined && args.update_ !== null) {
        this.update_ = args.update_;
      }
      if (args.delete_ !== undefined && args.delete_ !== null) {
        this.delete_ = args.delete_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.drop_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.select_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.insert_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.update_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.delete_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TViewPermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.drop_ !== null && this.drop_ !== undefined) {
      output.writeFieldBegin('drop_', Thrift.Type.BOOL, 2);
      output.writeBool(this.drop_);
      output.writeFieldEnd();
    }
    if (this.select_ !== null && this.select_ !== undefined) {
      output.writeFieldBegin('select_', Thrift.Type.BOOL, 3);
      output.writeBool(this.select_);
      output.writeFieldEnd();
    }
    if (this.insert_ !== null && this.insert_ !== undefined) {
      output.writeFieldBegin('insert_', Thrift.Type.BOOL, 4);
      output.writeBool(this.insert_);
      output.writeFieldEnd();
    }
    if (this.update_ !== null && this.update_ !== undefined) {
      output.writeFieldBegin('update_', Thrift.Type.BOOL, 5);
      output.writeBool(this.update_);
      output.writeFieldEnd();
    }
    if (this.delete_ !== null && this.delete_ !== undefined) {
      output.writeFieldBegin('delete_', Thrift.Type.BOOL, 6);
      output.writeBool(this.delete_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TServerPermissions = module.exports.TServerPermissions = class {
  constructor(args) {
    this.create_ = null;
    this.drop_ = null;
    this.alter_ = null;
    this.usage_ = null;
    if (args) {
      if (args.create_ !== undefined && args.create_ !== null) {
        this.create_ = args.create_;
      }
      if (args.drop_ !== undefined && args.drop_ !== null) {
        this.drop_ = args.drop_;
      }
      if (args.alter_ !== undefined && args.alter_ !== null) {
        this.alter_ = args.alter_;
      }
      if (args.usage_ !== undefined && args.usage_ !== null) {
        this.usage_ = args.usage_;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.create_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.drop_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.alter_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.usage_ = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TServerPermissions');
    if (this.create_ !== null && this.create_ !== undefined) {
      output.writeFieldBegin('create_', Thrift.Type.BOOL, 1);
      output.writeBool(this.create_);
      output.writeFieldEnd();
    }
    if (this.drop_ !== null && this.drop_ !== undefined) {
      output.writeFieldBegin('drop_', Thrift.Type.BOOL, 2);
      output.writeBool(this.drop_);
      output.writeFieldEnd();
    }
    if (this.alter_ !== null && this.alter_ !== undefined) {
      output.writeFieldBegin('alter_', Thrift.Type.BOOL, 3);
      output.writeBool(this.alter_);
      output.writeFieldEnd();
    }
    if (this.usage_ !== null && this.usage_ !== undefined) {
      output.writeFieldBegin('usage_', Thrift.Type.BOOL, 4);
      output.writeBool(this.usage_);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDBObjectPermissions = module.exports.TDBObjectPermissions = class {
  constructor(args) {
    this.database_permissions_ = null;
    this.table_permissions_ = null;
    this.dashboard_permissions_ = null;
    this.view_permissions_ = null;
    this.server_permissions_ = null;
    if (args) {
      if (args.database_permissions_ !== undefined && args.database_permissions_ !== null) {
        this.database_permissions_ = new ttypes.TDatabasePermissions(args.database_permissions_);
      }
      if (args.table_permissions_ !== undefined && args.table_permissions_ !== null) {
        this.table_permissions_ = new ttypes.TTablePermissions(args.table_permissions_);
      }
      if (args.dashboard_permissions_ !== undefined && args.dashboard_permissions_ !== null) {
        this.dashboard_permissions_ = new ttypes.TDashboardPermissions(args.dashboard_permissions_);
      }
      if (args.view_permissions_ !== undefined && args.view_permissions_ !== null) {
        this.view_permissions_ = new ttypes.TViewPermissions(args.view_permissions_);
      }
      if (args.server_permissions_ !== undefined && args.server_permissions_ !== null) {
        this.server_permissions_ = new ttypes.TServerPermissions(args.server_permissions_);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.database_permissions_ = new ttypes.TDatabasePermissions();
          this.database_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.table_permissions_ = new ttypes.TTablePermissions();
          this.table_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.dashboard_permissions_ = new ttypes.TDashboardPermissions();
          this.dashboard_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.view_permissions_ = new ttypes.TViewPermissions();
          this.view_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.server_permissions_ = new ttypes.TServerPermissions();
          this.server_permissions_.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDBObjectPermissions');
    if (this.database_permissions_ !== null && this.database_permissions_ !== undefined) {
      output.writeFieldBegin('database_permissions_', Thrift.Type.STRUCT, 1);
      this.database_permissions_.write(output);
      output.writeFieldEnd();
    }
    if (this.table_permissions_ !== null && this.table_permissions_ !== undefined) {
      output.writeFieldBegin('table_permissions_', Thrift.Type.STRUCT, 2);
      this.table_permissions_.write(output);
      output.writeFieldEnd();
    }
    if (this.dashboard_permissions_ !== null && this.dashboard_permissions_ !== undefined) {
      output.writeFieldBegin('dashboard_permissions_', Thrift.Type.STRUCT, 3);
      this.dashboard_permissions_.write(output);
      output.writeFieldEnd();
    }
    if (this.view_permissions_ !== null && this.view_permissions_ !== undefined) {
      output.writeFieldBegin('view_permissions_', Thrift.Type.STRUCT, 4);
      this.view_permissions_.write(output);
      output.writeFieldEnd();
    }
    if (this.server_permissions_ !== null && this.server_permissions_ !== undefined) {
      output.writeFieldBegin('server_permissions_', Thrift.Type.STRUCT, 5);
      this.server_permissions_.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDBObject = module.exports.TDBObject = class {
  constructor(args) {
    this.objectName = null;
    this.objectType = null;
    this.privs = null;
    this.grantee = null;
    this.privilegeObjectType = null;
    this.objectId = null;
    if (args) {
      if (args.objectName !== undefined && args.objectName !== null) {
        this.objectName = args.objectName;
      }
      if (args.objectType !== undefined && args.objectType !== null) {
        this.objectType = args.objectType;
      }
      if (args.privs !== undefined && args.privs !== null) {
        this.privs = Thrift.copyList(args.privs, [null]);
      }
      if (args.grantee !== undefined && args.grantee !== null) {
        this.grantee = args.grantee;
      }
      if (args.privilegeObjectType !== undefined && args.privilegeObjectType !== null) {
        this.privilegeObjectType = args.privilegeObjectType;
      }
      if (args.objectId !== undefined && args.objectId !== null) {
        this.objectId = args.objectId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.objectName = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.objectType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.privs = [];
          const _rtmp3196 = input.readListBegin();
          const _size195 = _rtmp3196.size || 0;
          for (let _i197 = 0; _i197 < _size195; ++_i197) {
            let elem198 = null;
            elem198 = input.readBool();
            this.privs.push(elem198);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.grantee = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.privilegeObjectType = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.objectId = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDBObject');
    if (this.objectName !== null && this.objectName !== undefined) {
      output.writeFieldBegin('objectName', Thrift.Type.STRING, 1);
      output.writeString(this.objectName);
      output.writeFieldEnd();
    }
    if (this.objectType !== null && this.objectType !== undefined) {
      output.writeFieldBegin('objectType', Thrift.Type.I32, 2);
      output.writeI32(this.objectType);
      output.writeFieldEnd();
    }
    if (this.privs !== null && this.privs !== undefined) {
      output.writeFieldBegin('privs', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.BOOL, this.privs.length);
      for (let iter199 in this.privs) {
        if (this.privs.hasOwnProperty(iter199)) {
          iter199 = this.privs[iter199];
          output.writeBool(iter199);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.grantee !== null && this.grantee !== undefined) {
      output.writeFieldBegin('grantee', Thrift.Type.STRING, 4);
      output.writeString(this.grantee);
      output.writeFieldEnd();
    }
    if (this.privilegeObjectType !== null && this.privilegeObjectType !== undefined) {
      output.writeFieldBegin('privilegeObjectType', Thrift.Type.I32, 5);
      output.writeI32(this.privilegeObjectType);
      output.writeFieldEnd();
    }
    if (this.objectId !== null && this.objectId !== undefined) {
      output.writeFieldBegin('objectId', Thrift.Type.I32, 6);
      output.writeI32(this.objectId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDashboardGrantees = module.exports.TDashboardGrantees = class {
  constructor(args) {
    this.name = null;
    this.is_user = null;
    this.permissions = null;
    if (args) {
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.is_user !== undefined && args.is_user !== null) {
        this.is_user = args.is_user;
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new ttypes.TDashboardPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.is_user = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new ttypes.TDashboardPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDashboardGrantees');
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 1);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.is_user !== null && this.is_user !== undefined) {
      output.writeFieldBegin('is_user', Thrift.Type.BOOL, 2);
      output.writeBool(this.is_user);
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 3);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TDashboard = module.exports.TDashboard = class {
  constructor(args) {
    this.dashboard_name = null;
    this.dashboard_state = null;
    this.image_hash = null;
    this.update_time = null;
    this.dashboard_metadata = null;
    this.dashboard_id = null;
    this.dashboard_owner = null;
    this.is_dash_shared = null;
    this.dashboard_permissions = null;
    if (args) {
      if (args.dashboard_name !== undefined && args.dashboard_name !== null) {
        this.dashboard_name = args.dashboard_name;
      }
      if (args.dashboard_state !== undefined && args.dashboard_state !== null) {
        this.dashboard_state = args.dashboard_state;
      }
      if (args.image_hash !== undefined && args.image_hash !== null) {
        this.image_hash = args.image_hash;
      }
      if (args.update_time !== undefined && args.update_time !== null) {
        this.update_time = args.update_time;
      }
      if (args.dashboard_metadata !== undefined && args.dashboard_metadata !== null) {
        this.dashboard_metadata = args.dashboard_metadata;
      }
      if (args.dashboard_id !== undefined && args.dashboard_id !== null) {
        this.dashboard_id = args.dashboard_id;
      }
      if (args.dashboard_owner !== undefined && args.dashboard_owner !== null) {
        this.dashboard_owner = args.dashboard_owner;
      }
      if (args.is_dash_shared !== undefined && args.is_dash_shared !== null) {
        this.is_dash_shared = args.is_dash_shared;
      }
      if (args.dashboard_permissions !== undefined && args.dashboard_permissions !== null) {
        this.dashboard_permissions = new ttypes.TDashboardPermissions(args.dashboard_permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_state = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.image_hash = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.update_time = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_metadata = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.dashboard_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.dashboard_owner = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.is_dash_shared = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.dashboard_permissions = new ttypes.TDashboardPermissions();
          this.dashboard_permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TDashboard');
    if (this.dashboard_name !== null && this.dashboard_name !== undefined) {
      output.writeFieldBegin('dashboard_name', Thrift.Type.STRING, 1);
      output.writeString(this.dashboard_name);
      output.writeFieldEnd();
    }
    if (this.dashboard_state !== null && this.dashboard_state !== undefined) {
      output.writeFieldBegin('dashboard_state', Thrift.Type.STRING, 2);
      output.writeString(this.dashboard_state);
      output.writeFieldEnd();
    }
    if (this.image_hash !== null && this.image_hash !== undefined) {
      output.writeFieldBegin('image_hash', Thrift.Type.STRING, 3);
      output.writeString(this.image_hash);
      output.writeFieldEnd();
    }
    if (this.update_time !== null && this.update_time !== undefined) {
      output.writeFieldBegin('update_time', Thrift.Type.STRING, 4);
      output.writeString(this.update_time);
      output.writeFieldEnd();
    }
    if (this.dashboard_metadata !== null && this.dashboard_metadata !== undefined) {
      output.writeFieldBegin('dashboard_metadata', Thrift.Type.STRING, 5);
      output.writeString(this.dashboard_metadata);
      output.writeFieldEnd();
    }
    if (this.dashboard_id !== null && this.dashboard_id !== undefined) {
      output.writeFieldBegin('dashboard_id', Thrift.Type.I32, 6);
      output.writeI32(this.dashboard_id);
      output.writeFieldEnd();
    }
    if (this.dashboard_owner !== null && this.dashboard_owner !== undefined) {
      output.writeFieldBegin('dashboard_owner', Thrift.Type.STRING, 7);
      output.writeString(this.dashboard_owner);
      output.writeFieldEnd();
    }
    if (this.is_dash_shared !== null && this.is_dash_shared !== undefined) {
      output.writeFieldBegin('is_dash_shared', Thrift.Type.BOOL, 8);
      output.writeBool(this.is_dash_shared);
      output.writeFieldEnd();
    }
    if (this.dashboard_permissions !== null && this.dashboard_permissions !== undefined) {
      output.writeFieldBegin('dashboard_permissions', Thrift.Type.STRUCT, 9);
      this.dashboard_permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TLicenseInfo = module.exports.TLicenseInfo = class {
  constructor(args) {
    this.claims = null;
    if (args) {
      if (args.claims !== undefined && args.claims !== null) {
        this.claims = Thrift.copyList(args.claims, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.claims = [];
          const _rtmp3201 = input.readListBegin();
          const _size200 = _rtmp3201.size || 0;
          for (let _i202 = 0; _i202 < _size200; ++_i202) {
            let elem203 = null;
            elem203 = input.readString();
            this.claims.push(elem203);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TLicenseInfo');
    if (this.claims !== null && this.claims !== undefined) {
      output.writeFieldBegin('claims', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRING, this.claims.length);
      for (let iter204 in this.claims) {
        if (this.claims.hasOwnProperty(iter204)) {
          iter204 = this.claims[iter204];
          output.writeString(iter204);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TSessionInfo = module.exports.TSessionInfo = class {
  constructor(args) {
    this.user = null;
    this.database = null;
    this.start_time = null;
    this.is_super = null;
    if (args) {
      if (args.user !== undefined && args.user !== null) {
        this.user = args.user;
      }
      if (args.database !== undefined && args.database !== null) {
        this.database = args.database;
      }
      if (args.start_time !== undefined && args.start_time !== null) {
        this.start_time = args.start_time;
      }
      if (args.is_super !== undefined && args.is_super !== null) {
        this.is_super = args.is_super;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.user = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.database = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.start_time = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.is_super = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TSessionInfo');
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRING, 1);
      output.writeString(this.user);
      output.writeFieldEnd();
    }
    if (this.database !== null && this.database !== undefined) {
      output.writeFieldBegin('database', Thrift.Type.STRING, 2);
      output.writeString(this.database);
      output.writeFieldEnd();
    }
    if (this.start_time !== null && this.start_time !== undefined) {
      output.writeFieldBegin('start_time', Thrift.Type.I64, 3);
      output.writeI64(this.start_time);
      output.writeFieldEnd();
    }
    if (this.is_super !== null && this.is_super !== undefined) {
      output.writeFieldBegin('is_super', Thrift.Type.BOOL, 4);
      output.writeBool(this.is_super);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TGeoFileLayerInfo = module.exports.TGeoFileLayerInfo = class {
  constructor(args) {
    this.name = null;
    this.contents = null;
    if (args) {
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.contents !== undefined && args.contents !== null) {
        this.contents = args.contents;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.contents = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TGeoFileLayerInfo');
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 1);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.contents !== null && this.contents !== undefined) {
      output.writeFieldBegin('contents', Thrift.Type.I32, 2);
      output.writeI32(this.contents);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTableEpochInfo = module.exports.TTableEpochInfo = class {
  constructor(args) {
    this.table_id = null;
    this.table_epoch = null;
    this.leaf_index = null;
    if (args) {
      if (args.table_id !== undefined && args.table_id !== null) {
        this.table_id = args.table_id;
      }
      if (args.table_epoch !== undefined && args.table_epoch !== null) {
        this.table_epoch = args.table_epoch;
      }
      if (args.leaf_index !== undefined && args.leaf_index !== null) {
        this.leaf_index = args.leaf_index;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.table_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.table_epoch = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.leaf_index = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTableEpochInfo');
    if (this.table_id !== null && this.table_id !== undefined) {
      output.writeFieldBegin('table_id', Thrift.Type.I32, 1);
      output.writeI32(this.table_id);
      output.writeFieldEnd();
    }
    if (this.table_epoch !== null && this.table_epoch !== undefined) {
      output.writeFieldBegin('table_epoch', Thrift.Type.I32, 2);
      output.writeI32(this.table_epoch);
      output.writeFieldEnd();
    }
    if (this.leaf_index !== null && this.leaf_index !== undefined) {
      output.writeFieldBegin('leaf_index', Thrift.Type.I32, 3);
      output.writeI32(this.leaf_index);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCustomExpression = module.exports.TCustomExpression = class {
  constructor(args) {
    this.id = null;
    this.name = null;
    this.expression_json = null;
    this.data_source_type = null;
    this.data_source_id = null;
    this.is_deleted = null;
    this.data_source_name = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.expression_json !== undefined && args.expression_json !== null) {
        this.expression_json = args.expression_json;
      }
      if (args.data_source_type !== undefined && args.data_source_type !== null) {
        this.data_source_type = args.data_source_type;
      }
      if (args.data_source_id !== undefined && args.data_source_id !== null) {
        this.data_source_id = args.data_source_id;
      }
      if (args.is_deleted !== undefined && args.is_deleted !== null) {
        this.is_deleted = args.is_deleted;
      }
      if (args.data_source_name !== undefined && args.data_source_name !== null) {
        this.data_source_name = args.data_source_name;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.expression_json = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.data_source_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.data_source_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.is_deleted = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.data_source_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCustomExpression');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.I32, 1);
      output.writeI32(this.id);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 2);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.expression_json !== null && this.expression_json !== undefined) {
      output.writeFieldBegin('expression_json', Thrift.Type.STRING, 4);
      output.writeString(this.expression_json);
      output.writeFieldEnd();
    }
    if (this.data_source_type !== null && this.data_source_type !== undefined) {
      output.writeFieldBegin('data_source_type', Thrift.Type.I32, 5);
      output.writeI32(this.data_source_type);
      output.writeFieldEnd();
    }
    if (this.data_source_id !== null && this.data_source_id !== undefined) {
      output.writeFieldBegin('data_source_id', Thrift.Type.I32, 6);
      output.writeI32(this.data_source_id);
      output.writeFieldEnd();
    }
    if (this.is_deleted !== null && this.is_deleted !== undefined) {
      output.writeFieldBegin('is_deleted', Thrift.Type.BOOL, 7);
      output.writeBool(this.is_deleted);
      output.writeFieldEnd();
    }
    if (this.data_source_name !== null && this.data_source_name !== undefined) {
      output.writeFieldBegin('data_source_name', Thrift.Type.STRING, 8);
      output.writeString(this.data_source_name);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TQueryInfo = module.exports.TQueryInfo = class {
  constructor(args) {
    this.query_session_id = null;
    this.query_public_session_id = null;
    this.current_status = null;
    this.executor_id = null;
    this.submitted = null;
    this.query_str = null;
    this.login_name = null;
    this.client_address = null;
    this.db_name = null;
    this.exec_device_type = null;
    if (args) {
      if (args.query_session_id !== undefined && args.query_session_id !== null) {
        this.query_session_id = args.query_session_id;
      }
      if (args.query_public_session_id !== undefined && args.query_public_session_id !== null) {
        this.query_public_session_id = args.query_public_session_id;
      }
      if (args.current_status !== undefined && args.current_status !== null) {
        this.current_status = args.current_status;
      }
      if (args.executor_id !== undefined && args.executor_id !== null) {
        this.executor_id = args.executor_id;
      }
      if (args.submitted !== undefined && args.submitted !== null) {
        this.submitted = args.submitted;
      }
      if (args.query_str !== undefined && args.query_str !== null) {
        this.query_str = args.query_str;
      }
      if (args.login_name !== undefined && args.login_name !== null) {
        this.login_name = args.login_name;
      }
      if (args.client_address !== undefined && args.client_address !== null) {
        this.client_address = args.client_address;
      }
      if (args.db_name !== undefined && args.db_name !== null) {
        this.db_name = args.db_name;
      }
      if (args.exec_device_type !== undefined && args.exec_device_type !== null) {
        this.exec_device_type = args.exec_device_type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.query_session_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.query_public_session_id = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.current_status = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.executor_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.submitted = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.query_str = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.login_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.client_address = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.db_name = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.exec_device_type = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TQueryInfo');
    if (this.query_session_id !== null && this.query_session_id !== undefined) {
      output.writeFieldBegin('query_session_id', Thrift.Type.STRING, 1);
      output.writeString(this.query_session_id);
      output.writeFieldEnd();
    }
    if (this.query_public_session_id !== null && this.query_public_session_id !== undefined) {
      output.writeFieldBegin('query_public_session_id', Thrift.Type.STRING, 2);
      output.writeString(this.query_public_session_id);
      output.writeFieldEnd();
    }
    if (this.current_status !== null && this.current_status !== undefined) {
      output.writeFieldBegin('current_status', Thrift.Type.STRING, 3);
      output.writeString(this.current_status);
      output.writeFieldEnd();
    }
    if (this.executor_id !== null && this.executor_id !== undefined) {
      output.writeFieldBegin('executor_id', Thrift.Type.I32, 4);
      output.writeI32(this.executor_id);
      output.writeFieldEnd();
    }
    if (this.submitted !== null && this.submitted !== undefined) {
      output.writeFieldBegin('submitted', Thrift.Type.STRING, 5);
      output.writeString(this.submitted);
      output.writeFieldEnd();
    }
    if (this.query_str !== null && this.query_str !== undefined) {
      output.writeFieldBegin('query_str', Thrift.Type.STRING, 6);
      output.writeString(this.query_str);
      output.writeFieldEnd();
    }
    if (this.login_name !== null && this.login_name !== undefined) {
      output.writeFieldBegin('login_name', Thrift.Type.STRING, 7);
      output.writeString(this.login_name);
      output.writeFieldEnd();
    }
    if (this.client_address !== null && this.client_address !== undefined) {
      output.writeFieldBegin('client_address', Thrift.Type.STRING, 8);
      output.writeString(this.client_address);
      output.writeFieldEnd();
    }
    if (this.db_name !== null && this.db_name !== undefined) {
      output.writeFieldBegin('db_name', Thrift.Type.STRING, 9);
      output.writeString(this.db_name);
      output.writeFieldEnd();
    }
    if (this.exec_device_type !== null && this.exec_device_type !== undefined) {
      output.writeFieldBegin('exec_device_type', Thrift.Type.STRING, 10);
      output.writeString(this.exec_device_type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TLeafInfo = module.exports.TLeafInfo = class {
  constructor(args) {
    this.leaf_id = null;
    this.num_leaves = null;
    if (args) {
      if (args.leaf_id !== undefined && args.leaf_id !== null) {
        this.leaf_id = args.leaf_id;
      }
      if (args.num_leaves !== undefined && args.num_leaves !== null) {
        this.num_leaves = args.num_leaves;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.leaf_id = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.num_leaves = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TLeafInfo');
    if (this.leaf_id !== null && this.leaf_id !== undefined) {
      output.writeFieldBegin('leaf_id', Thrift.Type.I32, 1);
      output.writeI32(this.leaf_id);
      output.writeFieldEnd();
    }
    if (this.num_leaves !== null && this.num_leaves !== undefined) {
      output.writeFieldBegin('num_leaves', Thrift.Type.I32, 2);
      output.writeI32(this.num_leaves);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 3962:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


const thrift = __webpack_require__(7392);
const Thrift = thrift.Thrift;
const Int64 = __webpack_require__(135);

const common_ttypes = __webpack_require__(2818);


const ttypes = module.exports = {};
ttypes.TResultSetLayout = {
  'GroupByPerfectHash' : 0,
  'GroupByBaselineHash' : 1,
  'Projection' : 2,
  'NonGroupedAggregate' : 3
};
ttypes.TCountDistinctImplType = {
  'Invalid' : 0,
  'Bitmap' : 1,
  'UnorderedSet' : 2
};
ttypes.TAggKind = {
  'AVG' : 0,
  'MIN' : 1,
  'MAX' : 2,
  'SUM' : 3,
  'COUNT' : 4,
  'APPROX_COUNT_DISTINCT' : 5,
  'SAMPLE' : 6,
  'SINGLE_VALUE' : 7,
  'COUNT_IF' : 8,
  'SUM_IF' : 9
};
const TSlotSize = module.exports.TSlotSize = class {
  constructor(args) {
    this.padded = null;
    this.logical = null;
    if (args) {
      if (args.padded !== undefined && args.padded !== null) {
        this.padded = args.padded;
      }
      if (args.logical !== undefined && args.logical !== null) {
        this.logical = args.logical;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I16) {
          this.padded = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I16) {
          this.logical = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TSlotSize');
    if (this.padded !== null && this.padded !== undefined) {
      output.writeFieldBegin('padded', Thrift.Type.I16, 1);
      output.writeI16(this.padded);
      output.writeFieldEnd();
    }
    if (this.logical !== null && this.logical !== undefined) {
      output.writeFieldBegin('logical', Thrift.Type.I16, 2);
      output.writeI16(this.logical);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TColSlotContext = module.exports.TColSlotContext = class {
  constructor(args) {
    this.slot_sizes = null;
    this.col_to_slot_map = null;
    if (args) {
      if (args.slot_sizes !== undefined && args.slot_sizes !== null) {
        this.slot_sizes = Thrift.copyList(args.slot_sizes, [ttypes.TSlotSize]);
      }
      if (args.col_to_slot_map !== undefined && args.col_to_slot_map !== null) {
        this.col_to_slot_map = Thrift.copyList(args.col_to_slot_map, [Thrift.copyList, null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.slot_sizes = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new ttypes.TSlotSize();
            elem3.read(input);
            this.slot_sizes.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.col_to_slot_map = [];
          const _rtmp35 = input.readListBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = [];
            const _rtmp39 = input.readListBegin();
            const _size8 = _rtmp39.size || 0;
            for (let _i10 = 0; _i10 < _size8; ++_i10) {
              let elem11 = null;
              elem11 = input.readI32();
              elem7.push(elem11);
            }
            input.readListEnd();
            this.col_to_slot_map.push(elem7);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TColSlotContext');
    if (this.slot_sizes !== null && this.slot_sizes !== undefined) {
      output.writeFieldBegin('slot_sizes', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.slot_sizes.length);
      for (let iter12 in this.slot_sizes) {
        if (this.slot_sizes.hasOwnProperty(iter12)) {
          iter12 = this.slot_sizes[iter12];
          iter12.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.col_to_slot_map !== null && this.col_to_slot_map !== undefined) {
      output.writeFieldBegin('col_to_slot_map', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.LIST, this.col_to_slot_map.length);
      for (let iter13 in this.col_to_slot_map) {
        if (this.col_to_slot_map.hasOwnProperty(iter13)) {
          iter13 = this.col_to_slot_map[iter13];
          output.writeListBegin(Thrift.Type.I32, iter13.length);
          for (let iter14 in iter13) {
            if (iter13.hasOwnProperty(iter14)) {
              iter14 = iter13[iter14];
              output.writeI32(iter14);
            }
          }
          output.writeListEnd();
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCountDistinctDescriptor = module.exports.TCountDistinctDescriptor = class {
  constructor(args) {
    this.impl_type = null;
    this.min_val = null;
    this.bitmap_sz_bits = null;
    this.approximate = null;
    this.device_type = null;
    this.sub_bitmap_count = null;
    if (args) {
      if (args.impl_type !== undefined && args.impl_type !== null) {
        this.impl_type = args.impl_type;
      }
      if (args.min_val !== undefined && args.min_val !== null) {
        this.min_val = args.min_val;
      }
      if (args.bitmap_sz_bits !== undefined && args.bitmap_sz_bits !== null) {
        this.bitmap_sz_bits = args.bitmap_sz_bits;
      }
      if (args.approximate !== undefined && args.approximate !== null) {
        this.approximate = args.approximate;
      }
      if (args.device_type !== undefined && args.device_type !== null) {
        this.device_type = args.device_type;
      }
      if (args.sub_bitmap_count !== undefined && args.sub_bitmap_count !== null) {
        this.sub_bitmap_count = args.sub_bitmap_count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.impl_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.min_val = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.bitmap_sz_bits = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.approximate = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.device_type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.sub_bitmap_count = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCountDistinctDescriptor');
    if (this.impl_type !== null && this.impl_type !== undefined) {
      output.writeFieldBegin('impl_type', Thrift.Type.I32, 1);
      output.writeI32(this.impl_type);
      output.writeFieldEnd();
    }
    if (this.min_val !== null && this.min_val !== undefined) {
      output.writeFieldBegin('min_val', Thrift.Type.I64, 2);
      output.writeI64(this.min_val);
      output.writeFieldEnd();
    }
    if (this.bitmap_sz_bits !== null && this.bitmap_sz_bits !== undefined) {
      output.writeFieldBegin('bitmap_sz_bits', Thrift.Type.I64, 3);
      output.writeI64(this.bitmap_sz_bits);
      output.writeFieldEnd();
    }
    if (this.approximate !== null && this.approximate !== undefined) {
      output.writeFieldBegin('approximate', Thrift.Type.BOOL, 4);
      output.writeBool(this.approximate);
      output.writeFieldEnd();
    }
    if (this.device_type !== null && this.device_type !== undefined) {
      output.writeFieldBegin('device_type', Thrift.Type.I32, 5);
      output.writeI32(this.device_type);
      output.writeFieldEnd();
    }
    if (this.sub_bitmap_count !== null && this.sub_bitmap_count !== undefined) {
      output.writeFieldBegin('sub_bitmap_count', Thrift.Type.I64, 6);
      output.writeI64(this.sub_bitmap_count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TResultSetBufferDescriptor = module.exports.TResultSetBufferDescriptor = class {
  constructor(args) {
    this.layout = null;
    this.keyless = null;
    this.entry_count = null;
    this.idx_target_as_key = null;
    this.min_val = null;
    this.max_val = null;
    this.bucket = null;
    this.group_col_widths = null;
    this.key_bytewidth = null;
    this.col_slot_context = null;
    this.target_groupby_indices = null;
    this.count_distinct_descriptors = null;
    this.force_4byte_float = null;
    if (args) {
      if (args.layout !== undefined && args.layout !== null) {
        this.layout = args.layout;
      }
      if (args.keyless !== undefined && args.keyless !== null) {
        this.keyless = args.keyless;
      }
      if (args.entry_count !== undefined && args.entry_count !== null) {
        this.entry_count = args.entry_count;
      }
      if (args.idx_target_as_key !== undefined && args.idx_target_as_key !== null) {
        this.idx_target_as_key = args.idx_target_as_key;
      }
      if (args.min_val !== undefined && args.min_val !== null) {
        this.min_val = args.min_val;
      }
      if (args.max_val !== undefined && args.max_val !== null) {
        this.max_val = args.max_val;
      }
      if (args.bucket !== undefined && args.bucket !== null) {
        this.bucket = args.bucket;
      }
      if (args.group_col_widths !== undefined && args.group_col_widths !== null) {
        this.group_col_widths = Thrift.copyList(args.group_col_widths, [null]);
      }
      if (args.key_bytewidth !== undefined && args.key_bytewidth !== null) {
        this.key_bytewidth = args.key_bytewidth;
      }
      if (args.col_slot_context !== undefined && args.col_slot_context !== null) {
        this.col_slot_context = new ttypes.TColSlotContext(args.col_slot_context);
      }
      if (args.target_groupby_indices !== undefined && args.target_groupby_indices !== null) {
        this.target_groupby_indices = Thrift.copyList(args.target_groupby_indices, [null]);
      }
      if (args.count_distinct_descriptors !== undefined && args.count_distinct_descriptors !== null) {
        this.count_distinct_descriptors = Thrift.copyList(args.count_distinct_descriptors, [ttypes.TCountDistinctDescriptor]);
      }
      if (args.force_4byte_float !== undefined && args.force_4byte_float !== null) {
        this.force_4byte_float = args.force_4byte_float;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.layout = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.keyless = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.entry_count = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.idx_target_as_key = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.min_val = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.max_val = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.bucket = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.group_col_widths = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = input.readI16();
            this.group_col_widths.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I16) {
          this.key_bytewidth = input.readI16();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRUCT) {
          this.col_slot_context = new ttypes.TColSlotContext();
          this.col_slot_context.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.LIST) {
          this.target_groupby_indices = [];
          const _rtmp320 = input.readListBegin();
          const _size19 = _rtmp320.size || 0;
          for (let _i21 = 0; _i21 < _size19; ++_i21) {
            let elem22 = null;
            elem22 = input.readI32();
            this.target_groupby_indices.push(elem22);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.LIST) {
          this.count_distinct_descriptors = [];
          const _rtmp324 = input.readListBegin();
          const _size23 = _rtmp324.size || 0;
          for (let _i25 = 0; _i25 < _size23; ++_i25) {
            let elem26 = null;
            elem26 = new ttypes.TCountDistinctDescriptor();
            elem26.read(input);
            this.count_distinct_descriptors.push(elem26);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.force_4byte_float = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TResultSetBufferDescriptor');
    if (this.layout !== null && this.layout !== undefined) {
      output.writeFieldBegin('layout', Thrift.Type.I32, 1);
      output.writeI32(this.layout);
      output.writeFieldEnd();
    }
    if (this.keyless !== null && this.keyless !== undefined) {
      output.writeFieldBegin('keyless', Thrift.Type.BOOL, 2);
      output.writeBool(this.keyless);
      output.writeFieldEnd();
    }
    if (this.entry_count !== null && this.entry_count !== undefined) {
      output.writeFieldBegin('entry_count', Thrift.Type.I32, 3);
      output.writeI32(this.entry_count);
      output.writeFieldEnd();
    }
    if (this.idx_target_as_key !== null && this.idx_target_as_key !== undefined) {
      output.writeFieldBegin('idx_target_as_key', Thrift.Type.I32, 4);
      output.writeI32(this.idx_target_as_key);
      output.writeFieldEnd();
    }
    if (this.min_val !== null && this.min_val !== undefined) {
      output.writeFieldBegin('min_val', Thrift.Type.I64, 5);
      output.writeI64(this.min_val);
      output.writeFieldEnd();
    }
    if (this.max_val !== null && this.max_val !== undefined) {
      output.writeFieldBegin('max_val', Thrift.Type.I64, 6);
      output.writeI64(this.max_val);
      output.writeFieldEnd();
    }
    if (this.bucket !== null && this.bucket !== undefined) {
      output.writeFieldBegin('bucket', Thrift.Type.I64, 7);
      output.writeI64(this.bucket);
      output.writeFieldEnd();
    }
    if (this.group_col_widths !== null && this.group_col_widths !== undefined) {
      output.writeFieldBegin('group_col_widths', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.I16, this.group_col_widths.length);
      for (let iter27 in this.group_col_widths) {
        if (this.group_col_widths.hasOwnProperty(iter27)) {
          iter27 = this.group_col_widths[iter27];
          output.writeI16(iter27);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.key_bytewidth !== null && this.key_bytewidth !== undefined) {
      output.writeFieldBegin('key_bytewidth', Thrift.Type.I16, 9);
      output.writeI16(this.key_bytewidth);
      output.writeFieldEnd();
    }
    if (this.col_slot_context !== null && this.col_slot_context !== undefined) {
      output.writeFieldBegin('col_slot_context', Thrift.Type.STRUCT, 10);
      this.col_slot_context.write(output);
      output.writeFieldEnd();
    }
    if (this.target_groupby_indices !== null && this.target_groupby_indices !== undefined) {
      output.writeFieldBegin('target_groupby_indices', Thrift.Type.LIST, 11);
      output.writeListBegin(Thrift.Type.I32, this.target_groupby_indices.length);
      for (let iter28 in this.target_groupby_indices) {
        if (this.target_groupby_indices.hasOwnProperty(iter28)) {
          iter28 = this.target_groupby_indices[iter28];
          output.writeI32(iter28);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.count_distinct_descriptors !== null && this.count_distinct_descriptors !== undefined) {
      output.writeFieldBegin('count_distinct_descriptors', Thrift.Type.LIST, 12);
      output.writeListBegin(Thrift.Type.STRUCT, this.count_distinct_descriptors.length);
      for (let iter29 in this.count_distinct_descriptors) {
        if (this.count_distinct_descriptors.hasOwnProperty(iter29)) {
          iter29 = this.count_distinct_descriptors[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.force_4byte_float !== null && this.force_4byte_float !== undefined) {
      output.writeFieldBegin('force_4byte_float', Thrift.Type.BOOL, 13);
      output.writeBool(this.force_4byte_float);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TTargetInfo = module.exports.TTargetInfo = class {
  constructor(args) {
    this.is_agg = null;
    this.kind = null;
    this.type = null;
    this.arg_type = null;
    this.skip_nulls = null;
    this.is_distinct = null;
    if (args) {
      if (args.is_agg !== undefined && args.is_agg !== null) {
        this.is_agg = args.is_agg;
      }
      if (args.kind !== undefined && args.kind !== null) {
        this.kind = args.kind;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = new common_ttypes.TTypeInfo(args.type);
      }
      if (args.arg_type !== undefined && args.arg_type !== null) {
        this.arg_type = new common_ttypes.TTypeInfo(args.arg_type);
      }
      if (args.skip_nulls !== undefined && args.skip_nulls !== null) {
        this.skip_nulls = args.skip_nulls;
      }
      if (args.is_distinct !== undefined && args.is_distinct !== null) {
        this.is_distinct = args.is_distinct;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.is_agg = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.kind = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.type = new common_ttypes.TTypeInfo();
          this.type.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.arg_type = new common_ttypes.TTypeInfo();
          this.arg_type.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.skip_nulls = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.is_distinct = input.readBool();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TTargetInfo');
    if (this.is_agg !== null && this.is_agg !== undefined) {
      output.writeFieldBegin('is_agg', Thrift.Type.BOOL, 1);
      output.writeBool(this.is_agg);
      output.writeFieldEnd();
    }
    if (this.kind !== null && this.kind !== undefined) {
      output.writeFieldBegin('kind', Thrift.Type.I32, 2);
      output.writeI32(this.kind);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.STRUCT, 3);
      this.type.write(output);
      output.writeFieldEnd();
    }
    if (this.arg_type !== null && this.arg_type !== undefined) {
      output.writeFieldBegin('arg_type', Thrift.Type.STRUCT, 4);
      this.arg_type.write(output);
      output.writeFieldEnd();
    }
    if (this.skip_nulls !== null && this.skip_nulls !== undefined) {
      output.writeFieldBegin('skip_nulls', Thrift.Type.BOOL, 5);
      output.writeBool(this.skip_nulls);
      output.writeFieldEnd();
    }
    if (this.is_distinct !== null && this.is_distinct !== undefined) {
      output.writeFieldBegin('is_distinct', Thrift.Type.BOOL, 6);
      output.writeBool(this.is_distinct);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCountDistinctSetStorage = module.exports.TCountDistinctSetStorage = class {
  constructor(args) {
    this.bitmap = null;
    this.sparse_set = null;
    if (args) {
      if (args.bitmap !== undefined && args.bitmap !== null) {
        this.bitmap = args.bitmap;
      }
      if (args.sparse_set !== undefined && args.sparse_set !== null) {
        this.sparse_set = Thrift.copyList(args.sparse_set, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.bitmap = input.readBinary();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.SET) {
          this.sparse_set = [];
          const _rtmp331 = input.readSetBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = input.readI64();
            this.sparse_set.push(elem33);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCountDistinctSetStorage');
    if (this.bitmap !== null && this.bitmap !== undefined) {
      output.writeFieldBegin('bitmap', Thrift.Type.STRING, 1);
      output.writeBinary(this.bitmap);
      output.writeFieldEnd();
    }
    if (this.sparse_set !== null && this.sparse_set !== undefined) {
      output.writeFieldBegin('sparse_set', Thrift.Type.SET, 2);
      output.writeSetBegin(Thrift.Type.I64, this.sparse_set.length);
      for (let iter34 in this.sparse_set) {
        if (this.sparse_set.hasOwnProperty(iter34)) {
          iter34 = this.sparse_set[iter34];
          output.writeI64(iter34);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TCountDistinctSet = module.exports.TCountDistinctSet = class {
  constructor(args) {
    this.type = null;
    this.storage = null;
    this.remote_ptr = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.storage !== undefined && args.storage !== null) {
        this.storage = new ttypes.TCountDistinctSetStorage(args.storage);
      }
      if (args.remote_ptr !== undefined && args.remote_ptr !== null) {
        this.remote_ptr = args.remote_ptr;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.storage = new ttypes.TCountDistinctSetStorage();
          this.storage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.remote_ptr = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TCountDistinctSet');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.storage !== null && this.storage !== undefined) {
      output.writeFieldBegin('storage', Thrift.Type.STRUCT, 2);
      this.storage.write(output);
      output.writeFieldEnd();
    }
    if (this.remote_ptr !== null && this.remote_ptr !== undefined) {
      output.writeFieldBegin('remote_ptr', Thrift.Type.I64, 3);
      output.writeI64(this.remote_ptr);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
const TSerializedRows = module.exports.TSerializedRows = class {
  constructor(args) {
    this.buffers = null;
    this.buffer_lengths = null;
    this.buffers_total_size = null;
    this.total_compression_time_ms = null;
    this.descriptor = null;
    this.targets = null;
    this.target_init_vals = null;
    this.varlen_buffer = null;
    this.count_distinct_sets = null;
    this.explanation = null;
    if (args) {
      if (args.buffers !== undefined && args.buffers !== null) {
        this.buffers = Thrift.copyList(args.buffers, [null]);
      }
      if (args.buffer_lengths !== undefined && args.buffer_lengths !== null) {
        this.buffer_lengths = Thrift.copyList(args.buffer_lengths, [null]);
      }
      if (args.buffers_total_size !== undefined && args.buffers_total_size !== null) {
        this.buffers_total_size = args.buffers_total_size;
      }
      if (args.total_compression_time_ms !== undefined && args.total_compression_time_ms !== null) {
        this.total_compression_time_ms = args.total_compression_time_ms;
      }
      if (args.descriptor !== undefined && args.descriptor !== null) {
        this.descriptor = new ttypes.TResultSetBufferDescriptor(args.descriptor);
      }
      if (args.targets !== undefined && args.targets !== null) {
        this.targets = Thrift.copyList(args.targets, [ttypes.TTargetInfo]);
      }
      if (args.target_init_vals !== undefined && args.target_init_vals !== null) {
        this.target_init_vals = Thrift.copyList(args.target_init_vals, [null]);
      }
      if (args.varlen_buffer !== undefined && args.varlen_buffer !== null) {
        this.varlen_buffer = Thrift.copyList(args.varlen_buffer, [null]);
      }
      if (args.count_distinct_sets !== undefined && args.count_distinct_sets !== null) {
        this.count_distinct_sets = Thrift.copyList(args.count_distinct_sets, [ttypes.TCountDistinctSet]);
      }
      if (args.explanation !== undefined && args.explanation !== null) {
        this.explanation = args.explanation;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.buffers = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = input.readBinary();
            this.buffers.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.buffer_lengths = [];
          const _rtmp340 = input.readListBegin();
          const _size39 = _rtmp340.size || 0;
          for (let _i41 = 0; _i41 < _size39; ++_i41) {
            let elem42 = null;
            elem42 = input.readI64();
            this.buffer_lengths.push(elem42);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.buffers_total_size = input.readI64();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.total_compression_time_ms = input.readI32();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.descriptor = new ttypes.TResultSetBufferDescriptor();
          this.descriptor.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.targets = [];
          const _rtmp344 = input.readListBegin();
          const _size43 = _rtmp344.size || 0;
          for (let _i45 = 0; _i45 < _size43; ++_i45) {
            let elem46 = null;
            elem46 = new ttypes.TTargetInfo();
            elem46.read(input);
            this.targets.push(elem46);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.target_init_vals = [];
          const _rtmp348 = input.readListBegin();
          const _size47 = _rtmp348.size || 0;
          for (let _i49 = 0; _i49 < _size47; ++_i49) {
            let elem50 = null;
            elem50 = input.readI64();
            this.target_init_vals.push(elem50);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.varlen_buffer = [];
          const _rtmp352 = input.readListBegin();
          const _size51 = _rtmp352.size || 0;
          for (let _i53 = 0; _i53 < _size51; ++_i53) {
            let elem54 = null;
            elem54 = input.readBinary();
            this.varlen_buffer.push(elem54);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.count_distinct_sets = [];
          const _rtmp356 = input.readListBegin();
          const _size55 = _rtmp356.size || 0;
          for (let _i57 = 0; _i57 < _size55; ++_i57) {
            let elem58 = null;
            elem58 = new ttypes.TCountDistinctSet();
            elem58.read(input);
            this.count_distinct_sets.push(elem58);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.explanation = input.readString();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('TSerializedRows');
    if (this.buffers !== null && this.buffers !== undefined) {
      output.writeFieldBegin('buffers', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRING, this.buffers.length);
      for (let iter59 in this.buffers) {
        if (this.buffers.hasOwnProperty(iter59)) {
          iter59 = this.buffers[iter59];
          output.writeBinary(iter59);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.buffer_lengths !== null && this.buffer_lengths !== undefined) {
      output.writeFieldBegin('buffer_lengths', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I64, this.buffer_lengths.length);
      for (let iter60 in this.buffer_lengths) {
        if (this.buffer_lengths.hasOwnProperty(iter60)) {
          iter60 = this.buffer_lengths[iter60];
          output.writeI64(iter60);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.buffers_total_size !== null && this.buffers_total_size !== undefined) {
      output.writeFieldBegin('buffers_total_size', Thrift.Type.I64, 3);
      output.writeI64(this.buffers_total_size);
      output.writeFieldEnd();
    }
    if (this.total_compression_time_ms !== null && this.total_compression_time_ms !== undefined) {
      output.writeFieldBegin('total_compression_time_ms', Thrift.Type.I32, 4);
      output.writeI32(this.total_compression_time_ms);
      output.writeFieldEnd();
    }
    if (this.descriptor !== null && this.descriptor !== undefined) {
      output.writeFieldBegin('descriptor', Thrift.Type.STRUCT, 5);
      this.descriptor.write(output);
      output.writeFieldEnd();
    }
    if (this.targets !== null && this.targets !== undefined) {
      output.writeFieldBegin('targets', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.targets.length);
      for (let iter61 in this.targets) {
        if (this.targets.hasOwnProperty(iter61)) {
          iter61 = this.targets[iter61];
          iter61.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.target_init_vals !== null && this.target_init_vals !== undefined) {
      output.writeFieldBegin('target_init_vals', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.I64, this.target_init_vals.length);
      for (let iter62 in this.target_init_vals) {
        if (this.target_init_vals.hasOwnProperty(iter62)) {
          iter62 = this.target_init_vals[iter62];
          output.writeI64(iter62);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.varlen_buffer !== null && this.varlen_buffer !== undefined) {
      output.writeFieldBegin('varlen_buffer', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRING, this.varlen_buffer.length);
      for (let iter63 in this.varlen_buffer) {
        if (this.varlen_buffer.hasOwnProperty(iter63)) {
          iter63 = this.varlen_buffer[iter63];
          output.writeBinary(iter63);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.count_distinct_sets !== null && this.count_distinct_sets !== undefined) {
      output.writeFieldBegin('count_distinct_sets', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.count_distinct_sets.length);
      for (let iter64 in this.count_distinct_sets) {
        if (this.count_distinct_sets.hasOwnProperty(iter64)) {
          iter64 = this.count_distinct_sets[iter64];
          iter64.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.explanation !== null && this.explanation !== undefined) {
      output.writeFieldBegin('explanation', Thrift.Type.STRING, 10);
      output.writeString(this.explanation);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};


/***/ }),

/***/ 3521:
/***/ ((module) => {

"use strict";
module.exports = require("apache-arrow");;

/***/ }),

/***/ 3129:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),

/***/ 7619:
/***/ ((module) => {

"use strict";
module.exports = require("constants");;

/***/ }),

/***/ 6417:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 8614:
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),

/***/ 5747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 8605:
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ 7211:
/***/ ((module) => {

"use strict";
module.exports = require("https");;

/***/ }),

/***/ 1631:
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),

/***/ 5622:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ 2413:
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),

/***/ 4016:
/***/ ((module) => {

"use strict";
module.exports = require("tls");;

/***/ }),

/***/ 8835:
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ 1669:
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ 8761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(7123);
/******/ })()
;